{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OlivierFest-Agda","text":"<p>The Agda code provides a lightweight formalization of the denotational semantics of the language ScmQE defined in the paper:</p> <p>Peter D. Mosses. 2025. A Compositional Semantics for <code>eval</code> in Scheme. In Proceedings of the Workshop Dedicated to Olivier Danvy on the Occasion of His 64th Birthday (OLIVIERFEST \u201925), October 12\u201318, 2025, Singapore, Singapore. ACM, New York, NY, USA, 10 pages. DOI</p> <p>The relationship of the formalization to the definitions in the paper is explained in \u00a76 of the paper.</p>"},{"location":"#highlighted-listings","title":"Highlighted listings","text":"<ul> <li> <p>Web pages with hyperlinks, navigation panel, and dark mode</p> <ul> <li>Notation for lightweight formalization</li> </ul> </li> <li> <p>HTML with hyperlinks</p> </li> <li> <p>PDF with table of contents</p> </li> </ul>"},{"location":"md/Agda/Builtin/Bool/","title":"Agda.Builtin.Bool","text":"<pre>{-# OPTIONS --cubical-compatible --safe --no-universe-polymorphism\n            --no-sized-types --no-guardedness --level-universe #-}\n\nmodule Agda.Builtin.Bool where\n\ndata Bool : Set where\n  false true : Bool\n\n{-# BUILTIN BOOL  Bool  #-}\n{-# BUILTIN FALSE false #-}\n{-# BUILTIN TRUE  true  #-}\n\n{-# COMPILE JS Bool  = function (x,v) { return ((x)? v[\"true\"]() : v[\"false\"]()); } #-}\n{-# COMPILE JS false = false #-}\n{-# COMPILE JS true  = true  #-}\n</pre>"},{"location":"md/Agda/Builtin/Char/","title":"Agda.Builtin.Char","text":"<pre>{-# OPTIONS --cubical-compatible --safe --no-universe-polymorphism\n            --no-sized-types --no-guardedness --level-universe #-}\n\nmodule Agda.Builtin.Char where\n\nopen import Agda.Builtin.Nat\nopen import Agda.Builtin.Bool\n\npostulate Char : Set\n{-# BUILTIN CHAR Char #-}\n\nprimitive\n  primIsLower primIsDigit primIsAlpha primIsSpace primIsAscii\n    primIsLatin1 primIsPrint primIsHexDigit : Char \u2192 Bool\n  primToUpper primToLower : Char \u2192 Char\n  primCharToNat : Char \u2192 Nat\n  primNatToChar : Nat \u2192 Char\n  primCharEquality : Char \u2192 Char \u2192 Bool\n</pre>"},{"location":"md/Agda/Builtin/Equality/","title":"Agda.Builtin.Equality","text":"<pre>{-# OPTIONS --cubical-compatible --safe --no-sized-types --no-guardedness --level-universe #-}\n\nmodule Agda.Builtin.Equality where\n\ninfix 4 _\u2261_\ndata _\u2261_ {a} {A : Set a} (x : A) : A \u2192 Set a where\n  instance refl : x \u2261 x\n\n{-# BUILTIN EQUALITY _\u2261_ #-}\n</pre>"},{"location":"md/Agda/Builtin/Equality/Rewrite/","title":"Agda.Builtin.Equality.Rewrite","text":"<pre>{-# OPTIONS --cubical-compatible --rewriting --no-sized-types --no-guardedness --level-universe #-}\n\nmodule Agda.Builtin.Equality.Rewrite where\n\nopen import Agda.Builtin.Equality\n\n{-# BUILTIN REWRITE _\u2261_ #-}\n</pre>"},{"location":"md/Agda/Builtin/Int/","title":"Agda.Builtin.Int","text":"<pre>{-# OPTIONS --cubical-compatible --safe --no-sized-types --no-guardedness --level-universe #-}\n\nmodule Agda.Builtin.Int where\n\nopen import Agda.Builtin.Nat\nopen import Agda.Builtin.String\n\ninfix 8 pos  -- Standard library uses this as +_\n\ndata Int : Set where\n  pos    : (n : Nat) \u2192 Int\n  negsuc : (n : Nat) \u2192 Int\n\n{-# BUILTIN INTEGER       Int    #-}\n{-# BUILTIN INTEGERPOS    pos    #-}\n{-# BUILTIN INTEGERNEGSUC negsuc #-}\n\nprimitive primShowInteger : Int \u2192 String\n</pre>"},{"location":"md/Agda/Builtin/List/","title":"Agda.Builtin.List","text":"<pre>{-# OPTIONS --cubical-compatible --safe --no-sized-types --no-guardedness --level-universe #-}\n\nmodule Agda.Builtin.List where\n\ninfixr 5 _\u2237_\ndata List {a} (A : Set a) : Set a where\n  []  : List A\n  _\u2237_ : (x : A) (xs : List A) \u2192 List A\n\n{-# BUILTIN LIST List #-}\n\n{-# COMPILE JS  List = function(x,v) {\n  if (x.length &lt; 1) { return v[\"[]\"](); } else { return v[\"_\u2237_\"](x[0], x.slice(1)); }\n} #-}\n{-# COMPILE JS [] = Array() #-}\n{-# COMPILE JS _\u2237_ = function (x) { return function(y) { return Array(x).concat(y); }; } #-}\n</pre>"},{"location":"md/Agda/Builtin/Maybe/","title":"Agda.Builtin.Maybe","text":"<pre>{-# OPTIONS --cubical-compatible --safe --no-sized-types --no-guardedness --level-universe #-}\n\nmodule Agda.Builtin.Maybe where\n\ndata Maybe {a} (A : Set a) : Set a where\n  just : A \u2192 Maybe A\n  nothing : Maybe A\n\n{-# BUILTIN MAYBE Maybe #-}\n</pre>"},{"location":"md/Agda/Builtin/Nat/","title":"Agda.Builtin.Nat","text":"<pre>{-# OPTIONS --cubical-compatible --safe --no-universe-polymorphism\n            --no-sized-types --no-guardedness --level-universe #-}\n\nmodule Agda.Builtin.Nat where\n\nopen import Agda.Builtin.Bool\n\ndata Nat : Set where\n  zero : Nat\n  suc  : (n : Nat) \u2192 Nat\n\n{-# BUILTIN NATURAL Nat #-}\n\ninfix  4 _==_ _&lt;_\ninfixl 6 _+_ _-_\ninfixl 7 _*_\n\n_+_ : Nat \u2192 Nat \u2192 Nat\nzero  + m = m\nsuc n + m = suc (n + m)\n\n{-# BUILTIN NATPLUS _+_ #-}\n\n_-_ : Nat \u2192 Nat \u2192 Nat\nn     - zero = n\nzero  - suc m = zero\nsuc n - suc m = n - m\n\n{-# BUILTIN NATMINUS _-_ #-}\n\n_*_ : Nat \u2192 Nat \u2192 Nat\nzero  * m = zero\nsuc n * m = m + n * m\n\n{-# BUILTIN NATTIMES _*_ #-}\n\n_==_ : Nat \u2192 Nat \u2192 Bool\nzero  == zero  = true\nsuc n == suc m = n == m\n_     == _     = false\n\n{-# BUILTIN NATEQUALS _==_ #-}\n\n_&lt;_ : Nat \u2192 Nat \u2192 Bool\n_     &lt; zero  = false\nzero  &lt; suc _ = true\nsuc n &lt; suc m = n &lt; m\n\n{-# BUILTIN NATLESS _&lt;_ #-}\n\n-- Helper function  div-helper  for Euclidean division.\n---------------------------------------------------------------------------\n--\n-- div-helper computes n / 1+m via iteration on n.\n--\n--   n div (suc m) = div-helper 0 m n m\n--\n-- The state of the iterator has two accumulator variables:\n--\n--   k: The quotient, returned once n=0.  Initialized to 0.\n--\n--   j: A counter, initialized to the divisor m, decreased on each iteration step.\n--      Once it reaches 0, the quotient k is increased and j reset to m,\n--      starting the next countdown.\n--\n-- Under the precondition j \u2264 m, the invariant is\n--\n--   div-helper k m n j = k + (n + m - j) div (1 + m)\n\ndiv-helper : (k m n j : Nat) \u2192 Nat\ndiv-helper k m  zero    j      = k\ndiv-helper k m (suc n)  zero   = div-helper (suc k) m n m\ndiv-helper k m (suc n) (suc j) = div-helper k       m n j\n\n{-# BUILTIN NATDIVSUCAUX div-helper #-}\n\n-- Proof of the invariant by induction on n.\n--\n--   clause 1: div-helper k m 0 j\n--           = k                                        by definition\n--           = k + (0 + m - j) div (1 + m)              since m - j &lt; 1 + m\n--\n--   clause 2: div-helper k m (1 + n) 0\n--           = div-helper (1 + k) m n m                 by definition\n--           = 1 + k + (n + m - m) div (1 + m)          by induction hypothesis\n--           = 1 + k +          n  div (1 + m)          by simplification\n--           = k +   (n + (1 + m)) div (1 + m)          by expansion\n--           = k + (1 + n + m - 0) div (1 + m)          by expansion\n--\n--   clause 3: div-helper k m (1 + n) (1 + j)\n--           = div-helper k m n j                       by definition\n--           = k + (n + m - j) div (1 + m)              by induction hypothesis\n--           = k + ((1 + n) + m - (1 + j)) div (1 + m)  by expansion\n--\n-- Q.e.d.\n\n-- Helper function  mod-helper  for the remainder computation.\n---------------------------------------------------------------------------\n--\n-- (Analogous to div-helper.)\n--\n-- mod-helper computes n % 1+m via iteration on n.\n--\n--   n mod (suc m) = mod-helper 0 m n m\n--\n-- The invariant is:\n--\n--   m = k + j  ==&gt;  mod-helper k m n j = (n + k) mod (1 + m).\n\nmod-helper : (k m n j : Nat) \u2192 Nat\nmod-helper k m  zero    j      = k\nmod-helper k m (suc n)  zero   = mod-helper 0       m n m\nmod-helper k m (suc n) (suc j) = mod-helper (suc k) m n j\n\n{-# BUILTIN NATMODSUCAUX mod-helper #-}\n\n-- Proof of the invariant by induction on n.\n--\n--   clause 1: mod-helper k m 0 j\n--           = k                               by definition\n--           = (0 + k) mod (1 + m)             since m = k + j, thus k &lt; m\n--\n--   clause 2: mod-helper k m (1 + n) 0\n--           = mod-helper 0 m n m              by definition\n--           = (n + 0)       mod (1 + m)       by induction hypothesis\n--           = (n + (1 + m)) mod (1 + m)       by expansion\n--           = (1 + n) + k)  mod (1 + m)       since k = m (as l = 0)\n--\n--   clause 3: mod-helper k m (1 + n) (1 + j)\n--           = mod-helper (1 + k) m n j        by definition\n--           = (n + (1 + k)) mod (1 + m)       by induction hypothesis\n--           = ((1 + n) + k) mod (1 + m)       by commutativity\n--\n-- Q.e.d.\n</pre>"},{"location":"md/Agda/Builtin/Sigma/","title":"Agda.Builtin.Sigma","text":"<pre>{-# OPTIONS --cubical-compatible --safe --no-sized-types --no-guardedness --level-universe #-}\n\nmodule Agda.Builtin.Sigma where\n\nopen import Agda.Primitive\n\nrecord \u03a3 {a b} (A : Set a) (B : A \u2192 Set b) : Set (a \u2294 b) where\n  constructor _,_\n  field\n    fst : A\n    snd : B fst\n\nopen \u03a3 public\n\ninfixr 4 _,_\n\n{-# BUILTIN SIGMA \u03a3 #-}\n</pre>"},{"location":"md/Agda/Builtin/Strict/","title":"Agda.Builtin.Strict","text":"<pre>{-# OPTIONS --cubical-compatible --safe --no-sized-types --no-guardedness --level-universe #-}\n\nmodule Agda.Builtin.Strict where\n\nopen import Agda.Builtin.Equality\n\nprimitive\n  primForce      : \u2200 {a b} {A : Set a} {B : A \u2192 Set b} (x : A) \u2192 (\u2200 x \u2192 B x) \u2192 B x\n  primForceLemma : \u2200 {a b} {A : Set a} {B : A \u2192 Set b} (x : A) (f : \u2200 x \u2192 B x) \u2192 primForce x f \u2261 f x\n</pre>"},{"location":"md/Agda/Builtin/String/","title":"Agda.Builtin.String","text":"<pre>{-# OPTIONS --cubical-compatible --safe --no-sized-types --no-guardedness --level-universe #-}\n\nmodule Agda.Builtin.String where\n\nopen import Agda.Builtin.Bool\nopen import Agda.Builtin.Char\nopen import Agda.Builtin.List\nopen import Agda.Builtin.Maybe\nopen import Agda.Builtin.Nat using (Nat)\nopen import Agda.Builtin.Sigma\n\npostulate String : Set\n{-# BUILTIN STRING String #-}\n\nprimitive\n  primStringUncons   : String \u2192 Maybe (\u03a3 Char (\u03bb _ \u2192 String))\n  primStringToList   : String \u2192 List Char\n  primStringFromList : List Char \u2192 String\n  primStringAppend   : String \u2192 String \u2192 String\n  primStringEquality : String \u2192 String \u2192 Bool\n  primShowChar       : Char \u2192 String\n  primShowString     : String \u2192 String\n  primShowNat        : Nat \u2192 String\n\n{-# COMPILE JS primStringUncons = function(x) {\n   if (x === \"\") { return z_jAgda_Agda_Builtin_Maybe[\"Maybe\"][\"nothing\"]; };\n   return z_jAgda_Agda_Builtin_Maybe[\"Maybe\"][\"just\"](z_jAgda_Agda_Builtin_Sigma[\"_,_\"](x.charAt(0))(x.slice(1)));\n   }\n #-}\n{-# COMPILE JS primStringToList = function(x) { return x.split(\"\"); } #-}\n{-# COMPILE JS primStringFromList = function(x) { return x.join(\"\"); } #-}\n{-# COMPILE JS primStringAppend = function(x) { return function(y) { return x+y; }; } #-}\n{-# COMPILE JS primStringEquality = function(x) { return function(y) { return x===y; }; } #-}\n{-# COMPILE JS primShowChar = function(x) { return JSON.stringify(x); } #-}\n{-# COMPILE JS primShowString = function(x) { return JSON.stringify(x); } #-}\n{-# COMPILE JS primShowNat = function(x) { return JSON.stringify(x); } #-}\n</pre>"},{"location":"md/Agda/Builtin/Unit/","title":"Agda.Builtin.Unit","text":"<pre>{-# OPTIONS --cubical-compatible --safe --no-universe-polymorphism\n            --no-sized-types --no-guardedness --level-universe #-}\n\nmodule Agda.Builtin.Unit where\n\nrecord \u22a4 : Set where\n  instance constructor tt\n\n{-# BUILTIN UNIT \u22a4 #-}\n{-# COMPILE GHC \u22a4 = data () (()) #-}\n</pre>"},{"location":"md/Agda/Primitive/","title":"Agda.Primitive","text":"<pre>-- The Agda primitives (preloaded).\n\n{-# OPTIONS --cubical-compatible --no-import-sorts --level-universe #-}\n\nmodule Agda.Primitive where\n\n------------------------------------------------------------------------\n-- Universe levels\n------------------------------------------------------------------------\n\ninfixl 6 _\u2294_\n\n{-# BUILTIN PROP           Prop      #-}\n{-# BUILTIN TYPE           Set       #-}\n{-# BUILTIN STRICTSET      SSet      #-}\n\n{-# BUILTIN PROPOMEGA      Prop\u03c9     #-}\n{-# BUILTIN SETOMEGA       Set\u03c9      #-}\n{-# BUILTIN STRICTSETOMEGA SSet\u03c9     #-}\n\n{-# BUILTIN LEVELUNIV      LevelUniv #-}\n\n-- Level is the first thing we need to define.\n-- The other postulates can only be checked if built-in Level is known.\n\npostulate\n  Level : LevelUniv\n\n-- MAlonzo compiles Level to (). This should be safe, because it is\n-- not possible to pattern match on levels.\n\n{-# BUILTIN LEVEL Level #-}\n\npostulate\n  lzero : Level\n  lsuc  : (\u2113 : Level) \u2192 Level\n  _\u2294_   : (\u2113\u2081 \u2113\u2082 : Level) \u2192 Level\n\n{-# BUILTIN LEVELZERO lzero #-}\n{-# BUILTIN LEVELSUC  lsuc  #-}\n{-# BUILTIN LEVELMAX  _\u2294_   #-}\n</pre>"},{"location":"md/Algebra/Bundles/Raw/","title":"Algebra.Bundles.Raw","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Definitions of 'raw' bundles\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Algebra.Bundles.Raw where\n\nopen import Algebra.Core\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.Bundles.Raw using (RawSetoid)\nopen import Level using (suc; _\u2294_)\nopen import Relation.Nullary.Negation.Core using (\u00ac_)\n\n------------------------------------------------------------------------\n-- Raw bundles with 1 unary operation &amp; 1 element\n------------------------------------------------------------------------\n\n-- A raw SuccessorSet is a SuccessorSet without any laws.\n\nrecord RawSuccessorSet c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    suc#    : Op\u2081 Carrier\n    zero#   : Carrier\n\n  rawSetoid : RawSetoid c \u2113\n  rawSetoid = record { _\u2248_ = _\u2248_ }\n\n  open RawSetoid rawSetoid public using (_\u2249_)\n\n------------------------------------------------------------------------\n-- Raw bundles with 1 binary operation\n------------------------------------------------------------------------\n\nrecord RawMagma c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _\u2219_     : Op\u2082 Carrier\n\n  rawSetoid : RawSetoid c \u2113\n  rawSetoid = record { _\u2248_ = _\u2248_ }\n\n  open RawSetoid rawSetoid public using (_\u2249_)\n\n\n------------------------------------------------------------------------\n-- Raw bundles with 1 binary operation &amp; 1 element\n------------------------------------------------------------------------\n\n-- A raw monoid is a monoid without any laws.\n\nrecord RawMonoid c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _\u2219_     : Op\u2082 Carrier\n    \u03b5       : Carrier\n\n  rawMagma : RawMagma c \u2113\n  rawMagma = record\n    { _\u2248_ = _\u2248_\n    ; _\u2219_ = _\u2219_\n    }\n\n  open RawMagma rawMagma public\n    using (_\u2249_)\n\n------------------------------------------------------------------------\n-- Raw bundles with 1 binary operation, 1 unary operation &amp; 1 element\n------------------------------------------------------------------------\n\nrecord RawGroup c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix  8 _\u207b\u00b9\n  infixl 7 _\u2219_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _\u2219_     : Op\u2082 Carrier\n    \u03b5       : Carrier\n    _\u207b\u00b9     : Op\u2081 Carrier\n\n  rawMonoid : RawMonoid c \u2113\n  rawMonoid = record\n    { _\u2248_ = _\u2248_\n    ; _\u2219_ = _\u2219_\n    ; \u03b5   = \u03b5\n    }\n\n  open RawMonoid rawMonoid public\n    using (_\u2249_; rawMagma)\n\n------------------------------------------------------------------------\n-- Raw bundles with 2 binary operations &amp; 1 element\n------------------------------------------------------------------------\n\nrecord RawNearSemiring c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _+_     : Op\u2082 Carrier\n    _*_     : Op\u2082 Carrier\n    0#      : Carrier\n\n  +-rawMonoid : RawMonoid c \u2113\n  +-rawMonoid = record\n    { _\u2248_ = _\u2248_\n    ; _\u2219_ = _+_\n    ;  \u03b5  = 0#\n    }\n\n  open RawMonoid +-rawMonoid public\n    using (_\u2249_) renaming (rawMagma to +-rawMagma)\n\n  *-rawMagma : RawMagma c \u2113\n  *-rawMagma = record\n    { _\u2248_ = _\u2248_\n    ; _\u2219_ = _*_\n    }\n\n------------------------------------------------------------------------\n-- Raw bundles with 2 binary operations &amp; 2 elements\n------------------------------------------------------------------------\n\nrecord RawSemiring c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _+_     : Op\u2082 Carrier\n    _*_     : Op\u2082 Carrier\n    0#      : Carrier\n    1#      : Carrier\n\n  rawNearSemiring : RawNearSemiring c \u2113\n  rawNearSemiring = record\n    { _\u2248_ = _\u2248_\n    ; _+_ = _+_\n    ; _*_ = _*_\n    ; 0#  = 0#\n    }\n\n  open RawNearSemiring rawNearSemiring public\n    using (_\u2249_; +-rawMonoid; +-rawMagma; *-rawMagma)\n\n  *-rawMonoid : RawMonoid c \u2113\n  *-rawMonoid = record\n    { _\u2248_ = _\u2248_\n    ; _\u2219_ = _*_\n    ; \u03b5   = 1#\n    }\n\n------------------------------------------------------------------------\n-- Raw bundles with 2 binary operations, 1 unary operation &amp; 1 element\n------------------------------------------------------------------------\n\nrecord RawRingWithoutOne c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix  8 -_\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _+_     : Op\u2082 Carrier\n    _*_     : Op\u2082 Carrier\n    -_      : Op\u2081 Carrier\n    0#      : Carrier\n\n  rawNearSemiring : RawNearSemiring c \u2113\n  rawNearSemiring = record\n    { _\u2248_ = _\u2248_\n    ; _+_ = _+_\n    ; _*_ = _*_\n    ; 0#  = 0#\n    }\n\n  open RawNearSemiring rawNearSemiring public\n    using (_\u2249_; *-rawMagma; +-rawMagma; +-rawMonoid)\n\n  +-rawGroup : RawGroup c \u2113\n  +-rawGroup = record\n    { _\u2248_ = _\u2248_\n    ; _\u2219_ = _+_\n    ; \u03b5   = 0#\n    ; _\u207b\u00b9 = -_\n    }\n\n------------------------------------------------------------------------\n-- Raw bundles with 2 binary operations, 1 unary operation &amp; 2 elements\n------------------------------------------------------------------------\n\n-- A raw ring is a ring without any laws.\n\nrecord RawRing c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix  8 -_\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _+_     : Op\u2082 Carrier\n    _*_     : Op\u2082 Carrier\n    -_      : Op\u2081 Carrier\n    0#      : Carrier\n    1#      : Carrier\n\n  rawSemiring : RawSemiring c \u2113\n  rawSemiring = record\n    { _\u2248_ = _\u2248_\n    ; _+_ = _+_\n    ; _*_ = _*_\n    ; 0#  = 0#\n    ; 1#  = 1#\n    }\n\n  open RawSemiring rawSemiring public\n    using\n    ( _\u2249_\n    ; +-rawMagma; +-rawMonoid\n    ; *-rawMagma; *-rawMonoid\n    )\n\n  rawRingWithoutOne : RawRingWithoutOne c \u2113\n  rawRingWithoutOne = record\n    { _\u2248_ = _\u2248_\n    ; _+_ = _+_\n    ; _*_ = _*_\n    ; -_ = -_\n    ; 0# = 0#\n    }\n\n  open RawRingWithoutOne rawRingWithoutOne public\n    using (+-rawGroup)\n\n------------------------------------------------------------------------\n-- Raw bundles with 3 binary operations\n------------------------------------------------------------------------\n\nrecord RawQuasigroup c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infixl 7 _\\\\_\n  infixl 7 _//_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _\u2219_     : Op\u2082 Carrier\n    _\\\\_    : Op\u2082 Carrier\n    _//_    : Op\u2082 Carrier\n\n  \u2219-rawMagma : RawMagma c \u2113\n  \u2219-rawMagma = record\n    { _\u2248_ = _\u2248_\n    ; _\u2219_ = _\u2219_\n    }\n\n  \\\\-rawMagma : RawMagma c \u2113\n  \\\\-rawMagma = record\n    { _\u2248_ = _\u2248_\n    ; _\u2219_ = _\\\\_\n    }\n\n  //-rawMagma : RawMagma c \u2113\n  //-rawMagma = record\n    { _\u2248_ = _\u2248_\n    ; _\u2219_ = _//_\n    }\n\n  open RawMagma \\\\-rawMagma public\n    using (_\u2249_)\n\n------------------------------------------------------------------------\n-- Raw bundles with 3 binary operations &amp; 1 element\n------------------------------------------------------------------------\n\nrecord RawLoop  c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infixl 7 _\u2219_\n  infixl 7 _\\\\_\n  infixl 7 _//_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _\u2219_     : Op\u2082 Carrier\n    _\\\\_    : Op\u2082 Carrier\n    _//_    : Op\u2082 Carrier\n    \u03b5       : Carrier\n\n  rawQuasigroup : RawQuasigroup c \u2113\n  rawQuasigroup = record\n    { _\u2248_ = _\u2248_\n    ; _\u2219_ = _\u2219_\n    ; _\\\\_ = _\\\\_\n    ; _//_ = _//_\n    }\n\n  open RawQuasigroup rawQuasigroup public\n    using (_\u2249_ ; \u2219-rawMagma; \\\\-rawMagma; //-rawMagma)\n\nrecord RawKleeneAlgebra c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix  8 _\u22c6\n  infixl 7 _*_\n  infixl 6 _+_\n  infix  4 _\u2248_\n  field\n    Carrier : Set c\n    _\u2248_     : Rel Carrier \u2113\n    _+_     : Op\u2082 Carrier\n    _*_     : Op\u2082 Carrier\n    _\u22c6      : Op\u2081 Carrier\n    0#      : Carrier\n    1#      : Carrier\n\n  rawSemiring : RawSemiring c \u2113\n  rawSemiring = record\n    { _\u2248_ = _\u2248_\n    ; _+_ = _+_\n    ; _*_ = _*_\n    ; 0#  = 0#\n    ; 1#  = 1#\n    }\n\n  open RawSemiring rawSemiring public\n    using\n    ( _\u2249_\n    ; +-rawMagma; +-rawMonoid\n    ; *-rawMagma; *-rawMonoid\n    )\n</pre>"},{"location":"md/Algebra/Core/","title":"Algebra.Core","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Core algebraic definitions\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via `Algebra`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Algebra.Core where\n\nopen import Level using (_\u2294_)\n\n------------------------------------------------------------------------\n-- Unary and binary operations\n\nOp\u2081 : \u2200 {\u2113} \u2192 Set \u2113 \u2192 Set \u2113\nOp\u2081 A = A \u2192 A\n\nOp\u2082 : \u2200 {\u2113} \u2192 Set \u2113 \u2192 Set \u2113\nOp\u2082 A = A \u2192 A \u2192 A\n</pre>"},{"location":"md/Algebra/Definitions/RawMagma/","title":"Algebra.Definitions.RawMagma","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Basic auxiliary definitions for magma-like structures\n------------------------------------------------------------------------\n\n-- You're unlikely to want to use this module directly. Instead you\n-- probably want to be importing the appropriate module from\n-- `Algebra.Properties.(Magma/Semigroup/...).Divisibility`\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Algebra.Bundles.Raw using (RawMagma)\nopen import Data.Product.Base using (_\u00d7_; \u2203)\nopen import Level using (_\u2294_)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Nullary.Negation.Core using (\u00ac_)\n\nmodule Algebra.Definitions.RawMagma\n  {a \u2113} (M : RawMagma a \u2113)\n  where\n\nopen RawMagma M renaming (Carrier to A)\n\n------------------------------------------------------------------------\n-- Divisibility\n\ninfix 5 _\u2223\u02e1_ _\u2224\u02e1_ _\u2223\u02b3_ _\u2224\u02b3_ _\u2223_ _\u2224_ _\u2223\u2223_ _\u2224\u2224_\n\n-- Divisibility from the left.\n--\n-- This and, the definition of right divisibility below, are defined as\n-- records rather than in terms of the base product type in order to\n-- make the use of pattern synonyms more ergonomic (see #2216 for\n-- further details). The record field names are not designed to be\n-- used explicitly and indeed aren't re-exported publicly by\n-- `Algebra.X.Properties.Divisibility` modules.\n\nrecord _\u2223\u02e1_ (x y : A) : Set (a \u2294 \u2113) where\n  constructor _,_\n  field\n    quotient : A\n    equality : x \u2219 quotient \u2248 y\n\n_\u2224\u02e1_ : Rel A (a \u2294 \u2113)\nx \u2224\u02e1 y = \u00ac x \u2223\u02e1 y\n\n-- Divisibility from the right\n\nrecord _\u2223\u02b3_ (x y : A) : Set (a \u2294 \u2113) where\n  constructor _,_\n  field\n    quotient : A\n    equality : quotient \u2219 x \u2248 y\n\n_\u2224\u02b3_ : Rel A (a \u2294 \u2113)\nx \u2224\u02b3 y = \u00ac x \u2223\u02b3 y\n\n-- General divisibility\n\n-- The relations _\u2223\u02e1_ and _\u2223\u02b3_ are only equivalent when _\u2219_ is\n-- commutative. When that is not the case we take `_\u2223\u02b3_` to be the\n-- primary one.\n\n_\u2223_ : Rel A (a \u2294 \u2113)\n_\u2223_ = _\u2223\u02b3_\n\n_\u2224_ : Rel A (a \u2294 \u2113)\nx \u2224 y = \u00ac x \u2223 y\n\n------------------------------------------------------------------------\n-- Mutual divisibility.\n\n-- In a  monoid, this is an equivalence relation extending _\u2248_.\n-- When in a cancellative monoid,  elements related by _\u2223\u2223_ are called\n-- associated, and `x \u2223\u2223 y` means that `x` and `y` differ by some\n-- invertible factor.\n\n-- Example: for \u2115  this is equivalent to x \u2261 y,\n--          for \u2124  this is equivalent to (x \u2261 y or x \u2261 - y).\n\n_\u2223\u2223_ : Rel A (a \u2294 \u2113)\nx \u2223\u2223 y = x \u2223 y \u00d7 y \u2223 x\n\n_\u2224\u2224_ : Rel A (a \u2294 \u2113)\nx \u2224\u2224 y = \u00ac x \u2223\u2223 y\n</pre>"},{"location":"md/Data/Bool/Base/","title":"Data.Bool.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- The type for booleans and some operations\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Bool.Base where\n\nopen import Data.Unit.Base using (\u22a4)\nopen import Data.Empty\nopen import Level using (Level)\n\nprivate\n  variable\n    a : Level\n    A : Set a\n\n------------------------------------------------------------------------\n-- The boolean type\n\nopen import Agda.Builtin.Bool public\n\n------------------------------------------------------------------------\n-- Relations\n\ninfix 4 _\u2264_ _&lt;_\n\ndata _\u2264_ : Bool \u2192 Bool \u2192 Set where\n  f\u2264t : false \u2264 true\n  b\u2264b : \u2200 {b} \u2192 b \u2264 b\n\ndata _&lt;_ : Bool \u2192 Bool \u2192 Set where\n  f&lt;t : false &lt; true\n\n------------------------------------------------------------------------\n-- Boolean operations\n\ninfixr 6 _\u2227_\ninfixr 5 _\u2228_ _xor_\n\nnot : Bool \u2192 Bool\nnot true  = false\nnot false = true\n\n_\u2227_ : Bool \u2192 Bool \u2192 Bool\ntrue  \u2227 b = b\nfalse \u2227 b = false\n\n_\u2228_ : Bool \u2192 Bool \u2192 Bool\ntrue  \u2228 b = true\nfalse \u2228 b = b\n\n_xor_ : Bool \u2192 Bool \u2192 Bool\ntrue  xor b = not b\nfalse xor b = b\n\n------------------------------------------------------------------------\n-- Conversion to Set\n\n-- A function mapping true to an inhabited type and false to an empty\n-- type.\nT : Bool \u2192 Set\nT true  = \u22a4\nT false = \u22a5\n\n------------------------------------------------------------------------\n-- Other operations\n\ninfix 0 if_then_else_\n\nif_then_else_ : Bool \u2192 A \u2192 A \u2192 A\nif true  then t else f = t\nif false then t else f = f\n</pre>"},{"location":"md/Data/Char/Base/","title":"Data.Char.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Basic definitions for Characters\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Char.Base where\n\nopen import Level using (zero)\nimport Data.Nat.Base as \u2115\nopen import Data.Bool.Base using (Bool)\nopen import Function.Base using (_on_)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.PropositionalEquality.Core\nopen import Relation.Binary.Construct.Closure.Reflexive\n\n------------------------------------------------------------------------\n-- Re-export the type, and renamed primitives\n\nopen import Agda.Builtin.Char public using ( Char )\n  renaming\n  -- testing\n  ( primIsLower    to isLower\n  ; primIsDigit    to isDigit\n  ; primIsAlpha    to isAlpha\n  ; primIsSpace    to isSpace\n  ; primIsAscii    to isAscii\n  ; primIsLatin1   to isLatin1\n  ; primIsPrint    to isPrint\n  ; primIsHexDigit to isHexDigit\n  -- transforming\n  ; primToUpper to toUpper\n  ; primToLower to toLower\n  -- converting\n  ; primCharToNat to to\u2115\n  ; primNatToChar to from\u2115\n  )\n\nopen import Agda.Builtin.String public using ()\n  renaming ( primShowChar to show )\n\ninfix 4 _\u2248_ _\u2249_\n_\u2248_ : Rel Char zero\n_\u2248_ = _\u2261_ on to\u2115\n\n_\u2249_ : Rel Char zero\n_\u2249_ = _\u2262_ on to\u2115\n\ninfix 4 _\u2248\u1d47_\n_\u2248\u1d47_ : (c d : Char) \u2192 Bool\nc \u2248\u1d47 d = to\u2115 c \u2115.\u2261\u1d47 to\u2115 d\n\ninfix 4 _&lt;_\n_&lt;_ : Rel Char zero\n_&lt;_ = \u2115._&lt;_ on to\u2115\n\ninfix 4 _\u2264_\n_\u2264_ : Rel Char zero\n_\u2264_ = ReflClosure _&lt;_\n</pre>"},{"location":"md/Data/Empty/","title":"Data.Empty","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Empty type, judgementally proof irrelevant, Level-monomorphic\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Empty where\n\nopen import Data.Irrelevant using (Irrelevant)\n\n------------------------------------------------------------------------\n-- Definition\n\n-- Note that by default the empty type is not universe polymorphic as it\n-- often results in unsolved metas. See `Data.Empty.Polymorphic` for a\n-- universe polymorphic variant.\n\nprivate\n  data Empty : Set where\n\n-- \u22a5 is defined via Data.Irrelevant (a record with a single irrelevant\n-- field) so that Agda can judgementally declare that all proofs of \u22a5\n-- are equal to each other. In particular this means that all functions\n-- returning a proof of \u22a5 are equal.\n\n\u22a5 : Set\n\u22a5 = Irrelevant Empty\n\n{-# DISPLAY Irrelevant Empty = \u22a5 #-}\n\n------------------------------------------------------------------------\n-- Functions\n\n\u22a5-elim : \u2200 {w} {Whatever : Set w} \u2192 \u22a5 \u2192 Whatever\n\u22a5-elim ()\n\n\u22a5-elim-irr : \u2200 {w} {Whatever : Set w} \u2192 .\u22a5 \u2192 Whatever\n\u22a5-elim-irr ()\n</pre>"},{"location":"md/Data/Fin/Base/","title":"Data.Fin.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Finite sets\n------------------------------------------------------------------------\n\n-- Note that elements of Fin n can be seen as natural numbers in the\n-- set {m | m &lt; n}. The notation \"m\" in comments below refers to this\n-- natural number view.\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Fin.Base where\n\nopen import Data.Bool.Base using (Bool; T)\nopen import Data.Nat.Base as \u2115 using (\u2115; zero; suc)\nopen import Data.Product.Base as Product using (_\u00d7_; _,_; proj\u2081; proj\u2082)\nopen import Data.Sum.Base as Sum using (_\u228e_; inj\u2081; inj\u2082; [_,_]\u2032)\nopen import Function.Base using (id; _\u2218_; _on_; flip; _$_)\nopen import Level using (0\u2113)\nopen import Relation.Binary.Core\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_; _\u2262_; refl; cong)\nopen import Relation.Binary.Indexed.Heterogeneous.Core using (IRel)\nopen import Relation.Nullary.Negation.Core using (contradiction)\n\nprivate\n  variable\n    m n : \u2115\n\n------------------------------------------------------------------------\n-- Types\n\n-- Fin n is a type with n elements.\n\ndata Fin : \u2115 \u2192 Set where\n  zero : Fin (suc n)\n  suc  : (i : Fin n) \u2192 Fin (suc n)\n\n-- A conversion: to\u2115 \"i\" = i.\n\nto\u2115 : Fin n \u2192 \u2115\nto\u2115 zero    = 0\nto\u2115 (suc i) = suc (to\u2115 i)\n\n-- A Fin-indexed variant of Fin.\n\nFin\u2032 : Fin n \u2192 Set\nFin\u2032 i = Fin (to\u2115 i)\n\n------------------------------------------------------------------------\n-- A cast that actually computes on constructors (as opposed to subst)\n\ncast : .(m \u2261 n) \u2192 Fin m \u2192 Fin n\ncast {zero}  {zero}  eq k       = k\ncast {suc m} {suc n} eq zero    = zero\ncast {suc m} {suc n} eq (suc k) = suc (cast (cong \u2115.pred eq) k)\n\n------------------------------------------------------------------------\n-- Conversions\n\n-- to\u2115 is defined above.\n\n-- from\u2115 n = \"n\".\n\nfrom\u2115 : (n : \u2115) \u2192 Fin (suc n)\nfrom\u2115 zero    = zero\nfrom\u2115 (suc n) = suc (from\u2115 n)\n\n-- from\u2115&lt; {m} _ = \"m\".\n\nfrom\u2115&lt; : .(m \u2115.&lt; n) \u2192 Fin n\nfrom\u2115&lt; {zero}  {suc _} _   = zero\nfrom\u2115&lt; {suc m} {suc _} m&lt;n = suc (from\u2115&lt; (\u2115.s&lt;s\u207b\u00b9 m&lt;n))\n\n-- from\u2115&lt;\u2033 m _ = \"m\".\n\nfrom\u2115&lt;\u2033 : \u2200 m {n} \u2192 .(m \u2115.&lt;\u2033 n) \u2192 Fin n\nfrom\u2115&lt;\u2033 zero    {suc _} _    = zero\nfrom\u2115&lt;\u2033 (suc m) {suc _} m&lt;\u2033n = suc (from\u2115&lt;\u2033 m (\u2115.s&lt;\u2033s\u207b\u00b9 m&lt;\u2033n))\n\n-- canonical liftings of i:Fin m to larger index\n\n-- injection on the left: \"i\" \u2191\u02e1 n = \"i\" in Fin (m + n)\ninfixl 5 _\u2191\u02e1_\n_\u2191\u02e1_ : \u2200 {m} \u2192 Fin m \u2192 \u2200 n \u2192 Fin (m \u2115.+ n)\nzero    \u2191\u02e1 n = zero\n(suc i) \u2191\u02e1 n = suc (i \u2191\u02e1 n)\n\n-- injection on the right: n \u2191\u02b3 \"i\" = \"n + i\" in Fin (n + m)\ninfixr 5 _\u2191\u02b3_\n_\u2191\u02b3_ : \u2200 {m} n \u2192 Fin m \u2192 Fin (n \u2115.+ m)\nzero    \u2191\u02b3 i = i\n(suc n) \u2191\u02b3 i = suc (n \u2191\u02b3 i)\n\n-- reduce\u2265 \"m + i\" _ = \"i\".\n\nreduce\u2265 : \u2200 (i : Fin (m \u2115.+ n)) \u2192 .(m \u2115.\u2264 to\u2115 i) \u2192 Fin n\nreduce\u2265 {zero}  i       _   = i\nreduce\u2265 {suc _} (suc i) m\u2264i = reduce\u2265 i (\u2115.s\u2264s\u207b\u00b9 m\u2264i)\n\n-- inject\u22c6 m \"i\" = \"i\".\n\ninject : \u2200 {i : Fin n} \u2192 Fin\u2032 i \u2192 Fin n\ninject {i = suc i} zero    = zero\ninject {i = suc i} (suc j) = suc (inject j)\n\ninject! : \u2200 {i : Fin (suc n)} \u2192 Fin\u2032 i \u2192 Fin n\ninject! {n = suc _} {i = suc _} zero    = zero\ninject! {n = suc _} {i = suc _} (suc j) = suc (inject! j)\n\ninject\u2081 : Fin n \u2192 Fin (suc n)\ninject\u2081 zero    = zero\ninject\u2081 (suc i) = suc (inject\u2081 i)\n\ninject\u2264 : Fin m \u2192 .(m \u2115.\u2264 n) \u2192 Fin n\ninject\u2264 {n = suc _} zero    _   = zero\ninject\u2264 {n = suc _} (suc i) m\u2264n = suc (inject\u2264 i (\u2115.s\u2264s\u207b\u00b9 m\u2264n))\n\n-- lower\u2081 \"i\" _ = \"i\".\n\nlower\u2081 : \u2200 (i : Fin (suc n)) \u2192 n \u2262 to\u2115 i \u2192 Fin n\nlower\u2081 {zero}  zero    ne = contradiction refl ne\nlower\u2081 {suc n} zero    _  = zero\nlower\u2081 {suc n} (suc i) ne = suc (lower\u2081 i (ne \u2218 cong suc))\n\n-- A strengthening injection into the minimal Fin fibre.\nstrengthen : \u2200 (i : Fin n) \u2192 Fin\u2032 (suc i)\nstrengthen zero    = zero\nstrengthen (suc i) = suc (strengthen i)\n\n-- splitAt m \"i\" = inj\u2081 \"i\"      if i &lt; m\n--                 inj\u2082 \"i - m\"  if i \u2265 m\n-- This is dual to splitAt from Data.Vec.\n\nsplitAt : \u2200 m {n} \u2192 Fin (m \u2115.+ n) \u2192 Fin m \u228e Fin n\nsplitAt zero    i       = inj\u2082 i\nsplitAt (suc m) zero    = inj\u2081 zero\nsplitAt (suc m) (suc i) = Sum.map\u2081 suc (splitAt m i)\n\n-- inverse of above function\njoin : \u2200 m n \u2192 Fin m \u228e Fin n \u2192 Fin (m \u2115.+ n)\njoin m n = [ _\u2191\u02e1 n , m \u2191\u02b3_ ]\u2032\n\n-- quotRem k \"i\" = \"i % k\" , \"i / k\"\n-- This is dual to group from Data.Vec.\n\nquotRem : \u2200 n \u2192 Fin (m \u2115.* n) \u2192 Fin n \u00d7 Fin m\nquotRem {suc m} n i =\n  [ (_, zero)\n  , Product.map\u2082 suc \u2218 quotRem {m} n\n  ]\u2032 $ splitAt n i\n\n-- a variant of quotRem the type of whose result matches the order of multiplication\nremQuot : \u2200 n \u2192 Fin (m \u2115.* n) \u2192 Fin m \u00d7 Fin n\nremQuot i = Product.swap \u2218 quotRem i\n\nquotient : \u2200 n \u2192 Fin (m \u2115.* n) \u2192 Fin m\nquotient n = proj\u2081 \u2218 remQuot n\n\nremainder : \u2200 n \u2192 Fin (m \u2115.* n) \u2192 Fin n\nremainder {m} n = proj\u2082 \u2218 remQuot {m} n\n\n-- inverse of remQuot\ncombine : Fin m \u2192 Fin n \u2192 Fin (m \u2115.* n)\ncombine {suc m} {n} zero    j = j \u2191\u02e1 (m \u2115.* n)\ncombine {suc m} {n} (suc i) j = n \u2191\u02b3 (combine i j)\n\n-- Next in progression after splitAt and remQuot\nfinToFun : Fin (m \u2115.^ n) \u2192 (Fin n \u2192 Fin m)\nfinToFun {m} {suc n} i zero    = quotient (m \u2115.^ n) i\nfinToFun {m} {suc n} i (suc j) = finToFun (remainder {m} (m \u2115.^ n) i) j\n\n-- inverse of above function\nfunToFin : (Fin m \u2192 Fin n) \u2192 Fin (n \u2115.^ m)\nfunToFin {zero}  f = zero\nfunToFin {suc m} f = combine (f zero) (funToFin (f \u2218 suc))\n\n------------------------------------------------------------------------\n-- Operations\n\n-- Folds.\n\nfold : \u2200 {t} (T : \u2115 \u2192 Set t) {m} \u2192\n       (\u2200 {n} \u2192 T n \u2192 T (suc n)) \u2192\n       (\u2200 {n} \u2192 T (suc n)) \u2192\n       Fin m \u2192 T m\nfold T f x zero    = x\nfold T f x (suc i) = f (fold T f x i)\n\nfold\u2032 : \u2200 {n t} (T : Fin (suc n) \u2192 Set t) \u2192\n        (\u2200 i \u2192 T (inject\u2081 i) \u2192 T (suc i)) \u2192\n        T zero \u2192\n        \u2200 i \u2192 T i\nfold\u2032             T f x zero     = x\nfold\u2032 {n = suc n} T f x (suc i)  =\n  f i (fold\u2032 (T \u2218 inject\u2081) (f \u2218 inject\u2081) x i)\n\n-- Lifts functions.\n\nlift : \u2200 k \u2192 (Fin m \u2192 Fin n) \u2192 Fin (k \u2115.+ m) \u2192 Fin (k \u2115.+ n)\nlift zero    f i       = f i\nlift (suc k) f zero    = zero\nlift (suc k) f (suc i) = suc (lift k f i)\n\n-- \"i\" + \"j\" = \"i + j\".\n\ninfixl 6 _+_\n\n_+_ : \u2200 (i : Fin m) (j : Fin n) \u2192 Fin (to\u2115 i \u2115.+ n)\nzero  + j = j\nsuc i + j = suc (i + j)\n\n-- \"i\" - \"j\" = \"i \u2238 j\".\n\ninfixl 6 _-_\n\n_-_ : \u2200 (i : Fin n) (j : Fin\u2032 (suc i)) \u2192 Fin (n \u2115.\u2238 to\u2115 j)\ni     - zero   = i\nsuc i - suc j  = i - j\n\n-- m \u2115- \"i\" = \"m \u2238 i\".\n\ninfixl 6 _\u2115-_\n\n_\u2115-_ : (n : \u2115) (j : Fin (suc n)) \u2192 Fin (suc n \u2115.\u2238 to\u2115 j)\nn     \u2115- zero   = from\u2115 n\nsuc n \u2115- suc i  = n \u2115- i\n\n-- m \u2115-\u2115 \"i\" = m \u2238 i.\n\ninfixl 6 _\u2115-\u2115_\n\n_\u2115-\u2115_ : (n : \u2115) \u2192 Fin (suc n) \u2192 \u2115\nn     \u2115-\u2115 zero   = n\nsuc n \u2115-\u2115 suc i  = n \u2115-\u2115 i\n\n-- pred \"i\" = \"pred i\".\n\npred : Fin n \u2192 Fin n\npred zero    = zero\npred (suc i) = inject\u2081 i\n\n-- opposite \"i\" = \"n - i\" (i.e. the additive inverse).\n\nopposite : Fin n \u2192 Fin n\nopposite {suc n} zero    = from\u2115 n\nopposite {suc n} (suc i) = inject\u2081 (opposite i)\n\n-- The function f(i,j) = if j&gt;i then j-1 else j\n-- This is a variant of the thick function from Conor\n-- McBride's \"First-order unification by structural recursion\".\n\npunchOut : \u2200 {i j : Fin (suc n)} \u2192 i \u2262 j \u2192 Fin n\npunchOut {_}     {zero}   {zero}  i\u2262j = contradiction refl i\u2262j\npunchOut {_}     {zero}   {suc j} _   = j\npunchOut {suc _} {suc i}  {zero}  _   = zero\npunchOut {suc _} {suc i}  {suc j} i\u2262j = suc (punchOut (i\u2262j \u2218 cong suc))\n\n-- The function f(i,j) = if j\u2265i then j+1 else j\n\npunchIn : Fin (suc n) \u2192 Fin n \u2192 Fin (suc n)\npunchIn zero    j       = suc j\npunchIn (suc i) zero    = zero\npunchIn (suc i) (suc j) = suc (punchIn i j)\n\n-- The function f(i,j) such that f(i,j) = if j\u2264i then j else j-1\n\npinch : Fin n \u2192 Fin (suc n) \u2192 Fin n\npinch {suc n} _       zero    = zero\npinch {suc n} zero    (suc j) = j\npinch {suc n} (suc i) (suc j) = suc (pinch i j)\n\n------------------------------------------------------------------------\n-- Order relations\n\ninfix 4 _\u2264_ _\u2265_ _&lt;_ _&gt;_\n\n_\u2264_ : IRel Fin 0\u2113\ni \u2264 j = to\u2115 i \u2115.\u2264 to\u2115 j\n\n_\u2265_ : IRel Fin 0\u2113\ni \u2265 j = to\u2115 i \u2115.\u2265 to\u2115 j\n\n_&lt;_ : IRel Fin 0\u2113\ni &lt; j = to\u2115 i \u2115.&lt; to\u2115 j\n\n_&gt;_ : IRel Fin 0\u2113\ni &gt; j = to\u2115 i \u2115.&gt; to\u2115 j\n\n\n------------------------------------------------------------------------\n-- An ordering view.\n\ndata Ordering {n : \u2115} : Fin n \u2192 Fin n \u2192 Set where\n  less    : \u2200 greatest (least : Fin\u2032 greatest) \u2192\n            Ordering (inject least) greatest\n  equal   : \u2200 i \u2192 Ordering i i\n  greater : \u2200 greatest (least : Fin\u2032 greatest) \u2192\n            Ordering greatest (inject least)\n\ncompare : \u2200 (i j : Fin n) \u2192 Ordering i j\ncompare zero    zero    = equal   zero\ncompare zero    (suc j) = less    (suc j) zero\ncompare (suc i) zero    = greater (suc i) zero\ncompare (suc i) (suc j) with compare i j\n... | less    greatest least = less    (suc greatest) (suc least)\n... | greater greatest least = greater (suc greatest) (suc least)\n... | equal   i              = equal   (suc i)\n\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 2.0\n\nraise = _\u2191\u02b3_\n{-# WARNING_ON_USAGE raise\n\"Warning: raise was deprecated in v2.0.\nPlease use _\u2191\u02b3_ instead.\"\n#-}\ninject+ : \u2200 {m} n \u2192 Fin m \u2192 Fin (m \u2115.+ n)\ninject+ n i = i \u2191\u02e1 n\n{-# WARNING_ON_USAGE inject+\n\"Warning: inject+ was deprecated in v2.0.\nPlease use _\u2191\u02e1_ instead.\nNB argument order has been flipped:\nthe left-hand argument is the Fin m\nthe right-hand is the Nat index increment.\"\n#-}\n\ndata _\u227a_ : \u2115 \u2192 \u2115 \u2192 Set where\n  _\u227bto\u2115_ : \u2200 n (i : Fin n) \u2192 to\u2115 i \u227a n\n\n{-# WARNING_ON_USAGE _\u227a_\n\"Warning: _\u227a_ was deprecated in v2.0.\nPlease use equivalent relation _&lt;_ instead.\"\n#-}\n{-# WARNING_ON_USAGE _\u227bto\u2115_\n\"Warning: _\u227bto\u2115_ was deprecated in v2.0.\nPlease use to\u2115&lt;n from Data.Fin.Properties instead.\"\n#-}\n</pre>"},{"location":"md/Data/Integer/Base/","title":"Data.Integer.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Integers, basic types and operations\n------------------------------------------------------------------------\n\n-- See README.Data.Integer for examples of how to use and reason about\n-- integers.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Integer.Base where\n\nopen import Algebra.Bundles.Raw\n  using (RawMagma; RawMonoid; RawGroup; RawNearSemiring; RawSemiring; RawRing)\nopen import Data.Bool.Base using (Bool; T; true; false)\nopen import Data.Nat.Base as \u2115 using (\u2115; z\u2264n; s\u2264s) hiding (module \u2115)\nopen import Data.Sign.Base as Sign using (Sign)\nopen import Level using (0\u2113)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.PropositionalEquality.Core\n  using (_\u2261_; _\u2262_; refl)\nopen import Relation.Nullary.Negation.Core using (\u00ac_; contradiction)\nopen import Relation.Unary using (Pred)\n\ninfix  8 -_\ninfixr 8 _^_\ninfixl 7 _*_ _\u2293_ _/\u2115_ _/_ _%\u2115_ _%_\ninfixl 6 _+_ _-_ _\u2296_ _\u2294_\ninfix  4 _\u2264_ _\u2265_ _&lt;_ _&gt;_ _\u2270_ _\u2271_ _\u226e_ _\u226f_\ninfix  4 _\u2264\u1d47_\n\n------------------------------------------------------------------------\n-- Types\n\nopen import Agda.Builtin.Int public\n  using ()\n  renaming\n  ( Int    to \u2124\n  ; pos    to +_      -- \"+ n\"      stands for \"n\"\n  ; negsuc to -[1+_]  -- \"-[1+ n ]\" stands for \"- (1 + n)\"\n  )\n\n-- Some additional patterns that provide symmetry around 0\n\npattern +0       = + 0\npattern +[1+_] n = + (\u2115.suc n)\n\n------------------------------------------------------------------------\n-- Constants\n\n0\u2124 : \u2124\n0\u2124 = +0\n\n-1\u2124 : \u2124\n-1\u2124 = -[1+ 0 ]\n\n1\u2124 : \u2124\n1\u2124 = +[1+ 0 ]\n\n------------------------------------------------------------------------\n-- Conversion\n\n-- Absolute value.\n\n\u2223_\u2223 : \u2124 \u2192 \u2115\n\u2223 + n      \u2223 = n\n\u2223 -[1+ n ] \u2223 = \u2115.suc n\n\n-- Gives the sign. For zero the sign is arbitrarily chosen to be +.\n\nsign : \u2124 \u2192 Sign\nsign (+ _)    = Sign.+\nsign -[1+ _ ] = Sign.-\n\n------------------------------------------------------------------------\n-- Ordering\n\ndata _\u2264_ : \u2124 \u2192 \u2124 \u2192 Set where\n  -\u2264- : \u2200 {m n} \u2192 (n\u2264m : n \u2115.\u2264 m) \u2192 -[1+ m ] \u2264 -[1+ n ]\n  -\u2264+ : \u2200 {m n} \u2192 -[1+ m ] \u2264 + n\n  +\u2264+ : \u2200 {m n} \u2192 (m\u2264n : m \u2115.\u2264 n) \u2192 + m \u2264 + n\n\ndata _&lt;_ : \u2124 \u2192 \u2124 \u2192 Set where\n  -&lt;- : \u2200 {m n} \u2192 (n&lt;m : n \u2115.&lt; m) \u2192 -[1+ m ] &lt; -[1+ n ]\n  -&lt;+ : \u2200 {m n} \u2192 -[1+ m ] &lt; + n\n  +&lt;+ : \u2200 {m n} \u2192 (m&lt;n : m \u2115.&lt; n) \u2192 + m &lt; + n\n\n_\u2265_ : Rel \u2124 0\u2113\nx \u2265 y = y \u2264 x\n\n_&gt;_ : Rel \u2124 0\u2113\nx &gt; y = y &lt; x\n\n_\u2270_ : Rel \u2124 0\u2113\nx \u2270 y = \u00ac (x \u2264 y)\n\n_\u2271_ : Rel \u2124 0\u2113\nx \u2271 y = \u00ac (x \u2265 y)\n\n_\u226e_ : Rel \u2124 0\u2113\nx \u226e y = \u00ac (x &lt; y)\n\n_\u226f_ : Rel \u2124 0\u2113\nx \u226f y = \u00ac (x &gt; y)\n\n------------------------------------------------------------------------\n-- Boolean ordering\n\n-- A boolean version.\n_\u2264\u1d47_ : \u2124 \u2192 \u2124 \u2192 Bool\n-[1+ m ] \u2264\u1d47 -[1+ n ] = n \u2115.\u2264\u1d47 m\n(+ m)    \u2264\u1d47 -[1+ n ] = false\n-[1+ m ] \u2264\u1d47 (+ n)    = true\n(+ m)    \u2264\u1d47 (+ n)    = m \u2115.\u2264\u1d47 n\n\n------------------------------------------------------------------------\n-- Simple predicates\n\n-- See `Data.Nat.Base` for a discussion on the design of these.\n\nNonZero : Pred \u2124 0\u2113\nNonZero i = \u2115.NonZero \u2223 i \u2223\n\nrecord Positive (i : \u2124) : Set where\n  field\n    pos : T (1\u2124 \u2264\u1d47 i)\n\nrecord NonNegative (i : \u2124) : Set where\n  field\n    nonNeg : T (0\u2124 \u2264\u1d47 i)\n\nrecord NonPositive (i : \u2124) : Set where\n  field\n    nonPos : T (i \u2264\u1d47 0\u2124)\n\nrecord Negative (i : \u2124) : Set where\n  field\n    neg : T (i \u2264\u1d47 -1\u2124)\n\n-- Instances\n\nopen \u2115 public\n  using (nonZero)\n\ninstance\n  pos : \u2200 {n} \u2192 Positive +[1+ n ]\n  pos = _\n\n  nonNeg : \u2200 {n} \u2192 NonNegative (+ n)\n  nonNeg = _\n\n  nonPos0 : NonPositive 0\u2124\n  nonPos0 = _\n\n  nonPos : \u2200 {n} \u2192 NonPositive -[1+ n ]\n  nonPos = _\n\n  neg : \u2200 {n} \u2192 Negative -[1+ n ]\n  neg = _\n\n-- Constructors\n\n\u2262-nonZero : \u2200 {i} \u2192 i \u2262 0\u2124 \u2192 NonZero i\n\u2262-nonZero { +[1+ n ]} _   = _\n\u2262-nonZero { +0}       0\u22620 = contradiction refl 0\u22620\n\u2262-nonZero { -[1+ n ]} _   = _\n\n&gt;-nonZero : \u2200 {i} \u2192 i &gt; 0\u2124 \u2192 NonZero i\n&gt;-nonZero (+&lt;+ (s\u2264s m&lt;n)) = _\n\n&lt;-nonZero : \u2200 {i} \u2192 i &lt; 0\u2124 \u2192 NonZero i\n&lt;-nonZero -&lt;+ = _\n\npositive : \u2200 {i} \u2192 i &gt; 0\u2124 \u2192 Positive i\npositive (+&lt;+ (s\u2264s m&lt;n)) = _\n\nnegative : \u2200 {i} \u2192 i &lt; 0\u2124 \u2192 Negative i\nnegative -&lt;+ = _\n\nnonPositive : \u2200 {i} \u2192 i \u2264 0\u2124 \u2192 NonPositive i\nnonPositive -\u2264+       = _\nnonPositive (+\u2264+ z\u2264n) = _\n\nnonNegative : \u2200 {i} \u2192 i \u2265 0\u2124 \u2192 NonNegative i\nnonNegative {+0}       _ = _\nnonNegative {+[1+ n ]} _ = _\n\n------------------------------------------------------------------------\n-- A view of integers as sign + absolute value\n\ninfix 5 _\u25c2_ _\u25c3_\n\n_\u25c3_ : Sign \u2192 \u2115 \u2192 \u2124\n_      \u25c3 \u2115.zero  = +0\nSign.+ \u25c3 n       = + n\nSign.- \u25c3 \u2115.suc n = -[1+ n ]\n\ndata SignAbs : \u2124 \u2192 Set where\n  _\u25c2_ : (s : Sign) (n : \u2115) \u2192 SignAbs (s \u25c3 n)\n\nsignAbs : \u2200 i \u2192 SignAbs i\nsignAbs -[1+ n ] = Sign.- \u25c2 \u2115.suc n\nsignAbs +0       = Sign.+ \u25c2 \u2115.zero\nsignAbs +[1+ n ] = Sign.+ \u25c2 \u2115.suc n\n\n------------------------------------------------------------------------\n-- Arithmetic\n\n-- Negation.\n\n-_ : \u2124 \u2192 \u2124\n- -[1+ n ] = +[1+ n ]\n- +0       = +0\n- +[1+ n ] = -[1+ n ]\n\n-- Subtraction of natural numbers.\n-- We define it using _&lt;\u1d47_ and _\u2238_ rather than inductively so that it\n-- is backed by builtin operations. This makes it much faster.\n_\u2296_ : \u2115 \u2192 \u2115 \u2192 \u2124\nm \u2296 n with m \u2115.&lt;\u1d47 n\n... | true  = - + (n \u2115.\u2238 m)\n... | false = + (m \u2115.\u2238 n)\n\n-- Addition.\n\n_+_ : \u2124 \u2192 \u2124 \u2192 \u2124\n-[1+ m ] + -[1+ n ] = -[1+ \u2115.suc (m \u2115.+ n) ]\n-[1+ m ] + +    n   = n \u2296 \u2115.suc m\n+    m   + -[1+ n ] = m \u2296 \u2115.suc n\n+    m   + +    n   = + (m \u2115.+ n)\n\n-- Subtraction.\n\n_-_ : \u2124 \u2192 \u2124 \u2192 \u2124\ni - j = i + (- j)\n\n-- Successor.\n\nsuc : \u2124 \u2192 \u2124\nsuc i = 1\u2124 + i\n\n-- Predecessor.\n\npred : \u2124 \u2192 \u2124\npred i = -1\u2124 + i\n\n-- Multiplication.\n\n_*_ : \u2124 \u2192 \u2124 \u2192 \u2124\ni * j = sign i Sign.* sign j \u25c3 \u2223 i \u2223 \u2115.* \u2223 j \u2223\n\n-- Na\u00efve exponentiation.\n\n_^_ : \u2124 \u2192 \u2115 \u2192 \u2124\ni ^ \u2115.zero    = 1\u2124\ni ^ (\u2115.suc m) = i * i ^ m\n\n-- Maximum.\n\n_\u2294_ : \u2124 \u2192 \u2124 \u2192 \u2124\n-[1+ m ] \u2294 -[1+ n ] = -[1+ \u2115._\u2293_ m n ]\n-[1+ m ] \u2294 +    n   = + n\n+    m   \u2294 -[1+ n ] = + m\n+    m   \u2294 +    n   = + (\u2115._\u2294_ m n)\n\n-- Minimum.\n\n_\u2293_ : \u2124 \u2192 \u2124 \u2192 \u2124\n-[1+ m ] \u2293 -[1+ n ] = -[1+ m \u2115.\u2294 n ]\n-[1+ m ] \u2293 +    n   = -[1+ m ]\n+    m   \u2293 -[1+ n ] = -[1+ n ]\n+    m   \u2293 +    n   = + (m \u2115.\u2293 n)\n\n-- Division by a natural\n\n_/\u2115_ : (dividend : \u2124) (divisor : \u2115) .{{_ : \u2115.NonZero divisor}} \u2192 \u2124\n(+ n      /\u2115 d) = + (n \u2115./ d)\n(-[1+ n ] /\u2115 d) with \u2115.suc n \u2115.% d\n... | \u2115.zero  = - (+ (\u2115.suc n \u2115./ d))\n... | \u2115.suc r = -[1+ (\u2115.suc n \u2115./ d) ]\n\n-- Division\n\n_/_ : (dividend divisor : \u2124) .{{_ : NonZero divisor}} \u2192 \u2124\ni / j = (sign j \u25c3 1) * (i /\u2115 \u2223 j \u2223)\n\n-- Modulus by a natural\n\n_%\u2115_ : (dividend : \u2124) (divisor : \u2115) .{{_ : \u2115.NonZero divisor}} \u2192 \u2115\n(+ n      %\u2115 d) = n \u2115.% d\n(-[1+ n ] %\u2115 d) with \u2115.suc n \u2115.% d\n... | \u2115.zero      = 0\n... | r@(\u2115.suc _) = d \u2115.\u2238 r\n\n-- Modulus\n\n_%_ : (dividend divisor : \u2124) .{{_ : NonZero divisor}} \u2192 \u2115\ni % j = i %\u2115 \u2223 j \u2223\n\n------------------------------------------------------------------------\n-- Bundles\n\n+-rawMagma : RawMagma 0\u2113 0\u2113\n+-rawMagma = record { _\u2248_ = _\u2261_ ; _\u2219_ = _+_ }\n\n+-0-rawMonoid : RawMonoid 0\u2113 0\u2113\n+-0-rawMonoid = record { _\u2248_ = _\u2261_ ; _\u2219_ = _+_ ; \u03b5 = 0\u2124 }\n\n+-0-rawGroup : RawGroup 0\u2113 0\u2113\n+-0-rawGroup = record { _\u2248_ = _\u2261_ ; _\u2219_ = _+_ ; _\u207b\u00b9 = -_; \u03b5 = 0\u2124 }\n\n*-rawMagma : RawMagma 0\u2113 0\u2113\n*-rawMagma = record { _\u2248_ = _\u2261_ ; _\u2219_ = _*_ }\n\n*-1-rawMonoid : RawMonoid 0\u2113 0\u2113\n*-1-rawMonoid = record { _\u2248_ = _\u2261_ ; _\u2219_ = _*_ ; \u03b5 = 1\u2124 }\n\n+-*-rawNearSemiring : RawNearSemiring 0\u2113 0\u2113\n+-*-rawNearSemiring = record\n  { Carrier = _\n  ; _\u2248_ = _\u2261_\n  ; _+_ = _+_\n  ; _*_ = _*_\n  ; 0# = 0\u2124\n  }\n\n+-*-rawSemiring : RawSemiring 0\u2113 0\u2113\n+-*-rawSemiring = record\n  { Carrier = _\n  ; _\u2248_ = _\u2261_\n  ; _+_ = _+_\n  ; _*_ = _*_\n  ; 0# = 0\u2124\n  ; 1# = 1\u2124\n  }\n\n+-*-rawRing : RawRing 0\u2113 0\u2113\n+-*-rawRing = record\n  { Carrier = _\n  ; _\u2248_ = _\u2261_\n  ; _+_ = _+_\n  ; _*_ = _*_\n  ; -_ = -_\n  ; 0# = 0\u2124\n  ; 1# = 1\u2124\n  }\n\n</pre>"},{"location":"md/Data/Irrelevant/","title":"Data.Irrelevant","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Wrapper for the proof irrelevance modality\n--\n-- This allows us to store proof irrelevant witnesses in a record and\n-- use projections to manipulate them without having to turn on the\n-- unsafe option --irrelevant-projections.\n-- Cf. Data.Refinement for a use case\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Irrelevant where\n\nopen import Level using (Level)\n\nprivate\n  variable\n    a b c : Level\n    A : Set a\n    B : Set b\n    C : Set c\n\n------------------------------------------------------------------------\n-- Type\n\nrecord Irrelevant (A : Set a) : Set a where\n  constructor [_]\n  field .irrelevant : A\nopen Irrelevant public\n\n------------------------------------------------------------------------\n-- Algebraic structure: Functor, Appplicative and Monad-like\n\nmap : (A \u2192 B) \u2192 Irrelevant A \u2192 Irrelevant B\nmap f [ a ] = [ f a ]\n\npure : A \u2192 Irrelevant A\npure x = [ x ]\n\ninfixl 4 _&lt;*&gt;_\n_&lt;*&gt;_ : Irrelevant (A \u2192 B) \u2192 Irrelevant A \u2192 Irrelevant B\n[ f ] &lt;*&gt; [ a ] = [ f a ]\n\ninfixl 1 _&gt;&gt;=_\n_&gt;&gt;=_ : Irrelevant A \u2192 (.A \u2192 Irrelevant B) \u2192 Irrelevant B\n[ a ] &gt;&gt;= f = f a\n\n------------------------------------------------------------------------\n-- Other functions\n\nzipWith : (A \u2192 B \u2192 C) \u2192 Irrelevant A \u2192 Irrelevant B \u2192 Irrelevant C\nzipWith f a b = \u2987 f a b \u2988\n</pre>"},{"location":"md/Data/List/Base/","title":"Data.List.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Lists, basic types and operations\n------------------------------------------------------------------------\n\n-- See README.Data.List for examples of how to use and reason about\n-- lists.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.List.Base where\n\nopen import Algebra.Bundles.Raw using (RawMagma; RawMonoid)\nopen import Data.Bool.Base as Bool\n  using (Bool; false; true; not; _\u2227_; _\u2228_; if_then_else_)\nopen import Data.Fin.Base using (Fin; zero; suc)\nopen import Data.Maybe.Base as Maybe using (Maybe; nothing; just; maybe\u2032)\nopen import Data.Nat.Base as \u2115 using (\u2115; zero; suc; _+_; _*_ ; _\u2264_ ; s\u2264s)\nopen import Data.Product.Base as Product using (_\u00d7_; _,_; map\u2081; map\u2082\u2032)\nopen import Data.Sum.Base as Sum using (_\u228e_; inj\u2081; inj\u2082)\nopen import Data.These.Base as These using (These; this; that; these)\nopen import Function.Base\n  using (id; _\u2218_ ; _\u2218\u2032_; _\u2218\u2082_; _$_; const; flip)\nopen import Level using (Level)\nopen import Relation.Unary using (Pred; Decidable)\nopen import Relation.Binary.Core using (Rel)\nimport Relation.Binary.Definitions as B\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_)\nopen import Relation.Nullary.Decidable.Core using (T?; does; \u00ac?)\n\nprivate\n  variable\n    a b c p \u2113 : Level\n    A : Set a\n    B : Set b\n    C : Set c\n\n------------------------------------------------------------------------\n-- Types\n\nopen import Agda.Builtin.List public\n  using (List; []; _\u2237_)\n\n------------------------------------------------------------------------\n-- Operations for transforming lists\n\nmap : (A \u2192 B) \u2192 List A \u2192 List B\nmap f []       = []\nmap f (x \u2237 xs) = f x \u2237 map f xs\n\ninfixr 5 _++_\n\n_++_ : List A \u2192 List A \u2192 List A\n[]       ++ ys = ys\n(x \u2237 xs) ++ ys = x \u2237 (xs ++ ys)\n\nintersperse : A \u2192 List A \u2192 List A\nintersperse x []       = []\nintersperse x (y \u2237 []) = y \u2237 []\nintersperse x (y \u2237 ys) = y \u2237 x \u2237 intersperse x ys\n\nintercalate : List A \u2192 List (List A) \u2192 List A\nintercalate xs []         = []\nintercalate xs (ys \u2237 [])  = ys\nintercalate xs (ys \u2237 yss) = ys ++ xs ++ intercalate xs yss\n\ncartesianProductWith : (A \u2192 B \u2192 C) \u2192 List A \u2192 List B \u2192 List C\ncartesianProductWith f []       _  = []\ncartesianProductWith f (x \u2237 xs) ys = map (f x) ys ++ cartesianProductWith f xs ys\n\ncartesianProduct : List A \u2192 List B \u2192 List (A \u00d7 B)\ncartesianProduct = cartesianProductWith _,_\n\n------------------------------------------------------------------------\n-- Aligning and zipping\n\nalignWith : (These A B \u2192 C) \u2192 List A \u2192 List B \u2192 List C\nalignWith f []       bs       = map (f \u2218\u2032 that) bs\nalignWith f as       []       = map (f \u2218\u2032 this) as\nalignWith f (a \u2237 as) (b \u2237 bs) = f (these a b) \u2237 alignWith f as bs\n\nzipWith : (A \u2192 B \u2192 C) \u2192 List A \u2192 List B \u2192 List C\nzipWith f (x \u2237 xs) (y \u2237 ys) = f x y \u2237 zipWith f xs ys\nzipWith f _        _        = []\n\nunalignWith : (A \u2192 These B C) \u2192 List A \u2192 List B \u00d7 List C\nunalignWith f []       = [] , []\nunalignWith f (a \u2237 as) with f a\n... | this b    = Product.map\u2081 (b \u2237_) (unalignWith f as)\n... | that c    = Product.map\u2082 (c \u2237_) (unalignWith f as)\n... | these b c = Product.map (b \u2237_) (c \u2237_) (unalignWith f as)\n\nunzipWith : (A \u2192 B \u00d7 C) \u2192 List A \u2192 List B \u00d7 List C\nunzipWith f []         = [] , []\nunzipWith f (xy \u2237 xys) = Product.zip _\u2237_ _\u2237_ (f xy) (unzipWith f xys)\n\npartitionSumsWith : (A \u2192 B \u228e C) \u2192 List A \u2192 List B \u00d7 List C\npartitionSumsWith f = unalignWith (These.fromSum \u2218\u2032 f)\n\nalign : List A \u2192 List B \u2192 List (These A B)\nalign = alignWith id\n\nzip : List A \u2192 List B \u2192 List (A \u00d7 B)\nzip = zipWith (_,_)\n\nunalign : List (These A B) \u2192 List A \u00d7 List B\nunalign = unalignWith id\n\nunzip : List (A \u00d7 B) \u2192 List A \u00d7 List B\nunzip = unzipWith id\n\npartitionSums : List (A \u228e B) \u2192 List A \u00d7 List B\npartitionSums = partitionSumsWith id\n\nmerge : {R : Rel A \u2113} \u2192 B.Decidable R \u2192 List A \u2192 List A \u2192 List A\nmerge R? []           ys           = ys\nmerge R? xs           []           = xs\nmerge R? x\u2237xs@(x \u2237 xs) y\u2237ys@(y \u2237 ys) = if does (R? x y)\n  then x \u2237 merge R? xs   y\u2237ys\n  else y \u2237 merge R? x\u2237xs ys\n\n------------------------------------------------------------------------\n-- Operations for reducing lists\n\nfoldr : (A \u2192 B \u2192 B) \u2192 B \u2192 List A \u2192 B\nfoldr c n []       = n\nfoldr c n (x \u2237 xs) = c x (foldr c n xs)\n\nfoldl : (A \u2192 B \u2192 A) \u2192 A \u2192 List B \u2192 A\nfoldl c n []       = n\nfoldl c n (x \u2237 xs) = foldl c (c n x) xs\n\nconcat : List (List A) \u2192 List A\nconcat = foldr _++_ []\n\nconcatMap : (A \u2192 List B) \u2192 List A \u2192 List B\nconcatMap f = concat \u2218 map f\n\nap : List (A \u2192 B) \u2192 List A \u2192 List B\nap fs as = concatMap (flip map as) fs\n\ncatMaybes : List (Maybe A) \u2192 List A\ncatMaybes = foldr (maybe\u2032 _\u2237_ id) []\n\nmapMaybe : (A \u2192 Maybe B) \u2192 List A \u2192 List B\nmapMaybe p = catMaybes \u2218 map p\n\nnull : List A \u2192 Bool\nnull []       = true\nnull (x \u2237 xs) = false\n\nand : List Bool \u2192 Bool\nand = foldr _\u2227_ true\n\nor : List Bool \u2192 Bool\nor = foldr _\u2228_ false\n\nany : (A \u2192 Bool) \u2192 List A \u2192 Bool\nany p = or \u2218 map p\n\nall : (A \u2192 Bool) \u2192 List A \u2192 Bool\nall p = and \u2218 map p\n\nsum : List \u2115 \u2192 \u2115\nsum = foldr _+_ 0\n\nproduct : List \u2115 \u2192 \u2115\nproduct = foldr _*_ 1\n\nlength : List A \u2192 \u2115\nlength = foldr (const suc) 0\n\n------------------------------------------------------------------------\n-- Operations for constructing lists\n\n[_] : A \u2192 List A\n[ x ] = x \u2237 []\n\nfromMaybe : Maybe A \u2192 List A\nfromMaybe (just x) = [ x ]\nfromMaybe nothing  = []\n\nreplicate : \u2115 \u2192 A \u2192 List A\nreplicate zero    x = []\nreplicate (suc n) x = x \u2237 replicate n x\n\niterate : (A \u2192 A) \u2192 A \u2192 \u2115 \u2192 List A\niterate f e zero    = []\niterate f e (suc n) = e \u2237 iterate f (f e) n\n\ninits : List A \u2192 List (List A)\ninits {A = A} = \u03bb xs \u2192 [] \u2237 tail xs\n  module Inits where\n    tail : List A \u2192 List (List A)\n    tail []       = []\n    tail (x \u2237 xs) = [ x ] \u2237 map (x \u2237_) (tail xs)\n\ntails : List A \u2192 List (List A)\ntails {A = A} = \u03bb xs \u2192 xs \u2237 tail xs\n  module Tails where\n    tail : List A \u2192 List (List A)\n    tail []       = []\n    tail (_ \u2237 xs) = xs \u2237 tail xs\n\ninsertAt : (xs : List A) \u2192 Fin (suc (length xs)) \u2192 A \u2192 List A\ninsertAt xs       zero    v = v \u2237 xs\ninsertAt (x \u2237 xs) (suc i) v = x \u2237 insertAt xs i v\n\nupdateAt : (xs : List A) \u2192 Fin (length xs) \u2192 (A \u2192 A) \u2192 List A\nupdateAt (x \u2237 xs) zero    f = f x \u2237 xs\nupdateAt (x \u2237 xs) (suc i) f = x \u2237 updateAt xs i f\n\n-- Tabulation\n\napplyUpTo : (\u2115 \u2192 A) \u2192 \u2115 \u2192 List A\napplyUpTo f zero    = []\napplyUpTo f (suc n) = f zero \u2237 applyUpTo (f \u2218 suc) n\n\napplyDownFrom : (\u2115 \u2192 A) \u2192 \u2115 \u2192 List A\napplyDownFrom f zero    = []\napplyDownFrom f (suc n) = f n \u2237 applyDownFrom f n\n\ntabulate : \u2200 {n} (f : Fin n \u2192 A) \u2192 List A\ntabulate {n = zero}  f = []\ntabulate {n = suc n} f = f zero \u2237 tabulate (f \u2218 suc)\n\nlookup : \u2200 (xs : List A) \u2192 Fin (length xs) \u2192 A\nlookup (x \u2237 xs) zero    = x\nlookup (x \u2237 xs) (suc i) = lookup xs i\n\n-- Numerical\n\nupTo : \u2115 \u2192 List \u2115\nupTo = applyUpTo id\n\ndownFrom : \u2115 \u2192 List \u2115\ndownFrom = applyDownFrom id\n\nallFin : \u2200 n \u2192 List (Fin n)\nallFin n = tabulate id\n\nunfold : \u2200 (P : \u2115 \u2192 Set b)\n         (f : \u2200 {n} \u2192 P (suc n) \u2192 Maybe (A \u00d7 P n)) \u2192\n         \u2200 {n} \u2192 P n \u2192 List A\nunfold P f {n = zero}  s = []\nunfold P f {n = suc n} s = maybe\u2032 (\u03bb (x , s\u2032) \u2192 x \u2237 unfold P f s\u2032) [] (f s)\n\n------------------------------------------------------------------------\n-- Operations for reversing lists\n\nreverseAcc : List A \u2192 List A \u2192 List A\nreverseAcc = foldl (flip _\u2237_)\n\nreverse : List A \u2192 List A\nreverse = reverseAcc []\n\n-- \"Reverse append\" xs \u02b3++ ys = reverse xs ++ ys\n\ninfixr 5 _\u02b3++_\n\n_\u02b3++_ : List A \u2192 List A \u2192 List A\n_\u02b3++_ = flip reverseAcc\n\n-- Snoc: Cons, but from the right.\n\ninfixl 6 _\u2237\u02b3_\n\n_\u2237\u02b3_ : List A \u2192 A \u2192 List A\nxs \u2237\u02b3 x = xs ++ [ x ]\n\n\n\n-- Backwards initialisation\n\ninfixl 5 _\u2237\u02b3\u2032_\n\ndata InitLast {A : Set a} : List A \u2192 Set a where\n  []    : InitLast []\n  _\u2237\u02b3\u2032_ : (xs : List A) (x : A) \u2192 InitLast (xs \u2237\u02b3 x)\n\ninitLast : (xs : List A) \u2192 InitLast xs\ninitLast []               = []\ninitLast (x \u2237 xs)         with initLast xs\n... | []       = [] \u2237\u02b3\u2032 x\n... | ys \u2237\u02b3\u2032 y = (x \u2237 ys) \u2237\u02b3\u2032 y\n\n-- uncons, but from the right\nunsnoc : List A \u2192 Maybe (List A \u00d7 A)\nunsnoc as with initLast as\n... | []       = nothing\n... | xs \u2237\u02b3\u2032 x = just (xs , x)\n\n------------------------------------------------------------------------\n-- Operations for deconstructing lists\n\n-- Note that although the following three combinators can be useful for\n-- programming, when proving it is often a better idea to manually\n-- destruct a list argument as each branch of the pattern-matching will\n-- have a refined type.\n\nuncons : List A \u2192 Maybe (A \u00d7 List A)\nuncons []       = nothing\nuncons (x \u2237 xs) = just (x , xs)\n\nhead : List A \u2192 Maybe A\nhead []      = nothing\nhead (x \u2237 _) = just x\n\ntail : List A \u2192 Maybe (List A)\ntail []       = nothing\ntail (_ \u2237 xs) = just xs\n\nlast : List A \u2192 Maybe A\nlast []       = nothing\nlast (x \u2237 []) = just x\nlast (_ \u2237 xs) = last xs\n\ntake : \u2115 \u2192 List A \u2192 List A\ntake zero    xs       = []\ntake (suc n) []       = []\ntake (suc n) (x \u2237 xs) = x \u2237 take n xs\n\ndrop : \u2115 \u2192 List A \u2192 List A\ndrop zero    xs       = xs\ndrop (suc n) []       = []\ndrop (suc n) (x \u2237 xs) = drop n xs\n\nsplitAt : \u2115 \u2192 List A \u2192 List A \u00d7 List A\nsplitAt zero    xs       = ([] , xs)\nsplitAt (suc n) []       = ([] , [])\nsplitAt (suc n) (x \u2237 xs) = Product.map\u2081 (x \u2237_) (splitAt n xs)\n\nremoveAt : (xs : List A) \u2192 Fin (length xs) \u2192 List A\nremoveAt (x \u2237 xs) zero     = xs\nremoveAt (x \u2237 xs) (suc i)  = x \u2237 removeAt xs i\n\n------------------------------------------------------------------------\n-- Operations for filtering lists\n\n-- The following are a variety of functions that can be used to\n-- construct sublists using a predicate.\n--\n-- Each function has two forms. The first main variant uses a\n-- proof-relevant decidable predicate, while the second variant uses\n-- a irrelevant boolean predicate and are suffixed with a `\u1d47` character,\n-- typed as \\^b.\n--\n-- The decidable versions have several advantages: 1) easier to prove\n-- properties, 2) better meta-variable inference and 3) most of the rest\n-- of the library is set-up to work with decidable predicates. However,\n-- in rare cases the boolean versions can be useful, mainly when one\n-- wants to minimise dependencies.\n--\n-- In summary, in most cases you probably want to use the decidable\n-- versions over the boolean versions, e.g. use `takeWhile (_\u2264? 10) xs`\n-- rather than `takeWhile\u1d47 (_\u2264\u1d47 10) xs`.\n\ntakeWhile : \u2200 {P : Pred A p} \u2192 Decidable P \u2192 List A \u2192 List A\ntakeWhile P? []       = []\ntakeWhile P? (x \u2237 xs) with does (P? x)\n... | true  = x \u2237 takeWhile P? xs\n... | false = []\n\ntakeWhile\u1d47 : (A \u2192 Bool) \u2192 List A \u2192 List A\ntakeWhile\u1d47 p = takeWhile (T? \u2218 p)\n\ndropWhile : \u2200 {P : Pred A p} \u2192 Decidable P \u2192 List A \u2192 List A\ndropWhile P? []       = []\ndropWhile P? (x \u2237 xs) with does (P? x)\n... | true  = dropWhile P? xs\n... | false = x \u2237 xs\n\ndropWhile\u1d47 : (A \u2192 Bool) \u2192 List A \u2192 List A\ndropWhile\u1d47 p = dropWhile (T? \u2218 p)\n\nfilter : \u2200 {P : Pred A p} \u2192 Decidable P \u2192 List A \u2192 List A\nfilter P? [] = []\nfilter P? (x \u2237 xs) with does (P? x)\n... | false = filter P? xs\n... | true  = x \u2237 filter P? xs\n\nfilter\u1d47 : (A \u2192 Bool) \u2192 List A \u2192 List A\nfilter\u1d47 p = filter (T? \u2218 p)\n\npartition : \u2200 {P : Pred A p} \u2192 Decidable P \u2192 List A \u2192 (List A \u00d7 List A)\npartition P? []       = ([] , [])\npartition P? (x \u2237 xs) with does (P? x) | partition P? xs\n... | true  | (ys , zs) = (x \u2237 ys , zs)\n... | false | (ys , zs) = (ys , x \u2237 zs)\n\npartition\u1d47 : (A \u2192 Bool) \u2192 List A \u2192 List A \u00d7 List A\npartition\u1d47 p = partition (T? \u2218 p)\n\nspan : \u2200 {P : Pred A p} \u2192 Decidable P \u2192 List A \u2192 (List A \u00d7 List A)\nspan P? []       = ([] , [])\nspan P? ys@(x \u2237 xs) with does (P? x)\n... | true  = Product.map (x \u2237_) id (span P? xs)\n... | false = ([] , ys)\n\n\nspan\u1d47 : (A \u2192 Bool) \u2192 List A \u2192 List A \u00d7 List A\nspan\u1d47 p = span (T? \u2218 p)\n\nbreak : \u2200 {P : Pred A p} \u2192 Decidable P \u2192 List A \u2192 (List A \u00d7 List A)\nbreak P? = span (\u00ac? \u2218 P?)\n\nbreak\u1d47 : (A \u2192 Bool) \u2192 List A \u2192 List A \u00d7 List A\nbreak\u1d47 p = break (T? \u2218 p)\n\n-- The predicate `P` represents the notion of newline character for the\n-- type `A`. It is used to split the input list into a list of lines.\n-- Some lines may be empty if the input contains at least two\n-- consecutive newline characters.\nlinesBy : \u2200 {P : Pred A p} \u2192 Decidable P \u2192 List A \u2192 List (List A)\nlinesBy {A = A} P? = go nothing where\n\n  go : Maybe (List A) \u2192 List A \u2192 List (List A)\n  go acc []       = maybe\u2032 ([_] \u2218\u2032 reverse) [] acc\n  go acc (c \u2237 cs) = if does (P? c)\n    then reverse acc\u2032 \u2237 go nothing cs\n    else go (just (c \u2237 acc\u2032)) cs\n    where acc\u2032 = Maybe.fromMaybe [] acc\n\nlinesBy\u1d47 : (A \u2192 Bool) \u2192 List A \u2192 List (List A)\nlinesBy\u1d47 p = linesBy (T? \u2218 p)\n\n-- The predicate `P` represents the notion of space character for the\n-- type `A`. It is used to split the input list into a list of words.\n-- All the words are non empty and the output does not contain any space\n-- characters.\nwordsBy : \u2200 {P : Pred A p} \u2192 Decidable P \u2192 List A \u2192 List (List A)\nwordsBy {A = A} P? = go [] where\n\n  cons : List A \u2192 List (List A) \u2192 List (List A)\n  cons [] ass = ass\n  cons as ass = reverse as \u2237 ass\n\n  go : List A \u2192 List A \u2192 List (List A)\n  go acc []       = cons acc []\n  go acc (c \u2237 cs) = if does (P? c)\n    then cons acc (go [] cs)\n    else go (c \u2237 acc) cs\n\nwordsBy\u1d47 : (A \u2192 Bool) \u2192 List A \u2192 List (List A)\nwordsBy\u1d47 p = wordsBy (T? \u2218 p)\n\nderun : \u2200 {R : Rel A p} \u2192 B.Decidable R \u2192 List A \u2192 List A\nderun R? [] = []\nderun R? (x \u2237 []) = x \u2237 []\nderun R? (x \u2237 xs@(y \u2237 _)) with does (R? x y) | derun R? xs\n... | true  | ys = ys\n... | false | ys = x \u2237 ys\n\nderun\u1d47 : (A \u2192 A \u2192 Bool) \u2192 List A \u2192 List A\nderun\u1d47 r = derun (T? \u2218\u2082 r)\n\ndeduplicate : \u2200 {R : Rel A p} \u2192 B.Decidable R \u2192 List A \u2192 List A\ndeduplicate R? [] = []\ndeduplicate R? (x \u2237 xs) = x \u2237 filter (\u00ac? \u2218 R? x) (deduplicate R? xs)\n\ndeduplicate\u1d47 : (A \u2192 A \u2192 Bool) \u2192 List A \u2192 List A\ndeduplicate\u1d47 r = deduplicate (T? \u2218\u2082 r)\n\n-- Finds the first element satisfying the boolean predicate\nfind : \u2200 {P : Pred A p} \u2192 Decidable P \u2192 List A \u2192 Maybe A\nfind P? []       = nothing\nfind P? (x \u2237 xs) = if does (P? x) then just x else find P? xs\n\nfind\u1d47 : (A \u2192 Bool) \u2192 List A \u2192 Maybe A\nfind\u1d47 p = find (T? \u2218 p)\n\n-- Finds the index of the first element satisfying the boolean predicate\nfindIndex : \u2200 {P : Pred A p} \u2192 Decidable P \u2192 (xs : List A) \u2192 Maybe $ Fin (length xs)\nfindIndex P? [] = nothing\nfindIndex P? (x \u2237 xs) = if does (P? x)\n  then just zero\n  else Maybe.map suc (findIndex P? xs)\n\nfindIndex\u1d47 : (A \u2192 Bool) \u2192 (xs : List A) \u2192 Maybe $ Fin (length xs)\nfindIndex\u1d47 p = findIndex (T? \u2218 p)\n\n-- Finds indices of all the elements satisfying the boolean predicate\nfindIndices : \u2200 {P : Pred A p} \u2192 Decidable P \u2192 (xs : List A) \u2192 List $ Fin (length xs)\nfindIndices P? []       = []\nfindIndices P? (x \u2237 xs) = if does (P? x)\n  then zero \u2237 indices\n  else indices\n    where indices = map suc (findIndices P? xs)\n\nfindIndices\u1d47 : (A \u2192 Bool) \u2192 (xs : List A) \u2192 List $ Fin (length xs)\nfindIndices\u1d47 p = findIndices (T? \u2218 p)\n\n------------------------------------------------------------------------\n-- Actions on single elements\n\ninfixl 5 _[_]%=_ _[_]\u2237=_\n\n-- xs [ i ]%= f  modifies the i-th element of xs according to f\n\n_[_]%=_ : (xs : List A) \u2192 Fin (length xs) \u2192 (A \u2192 A) \u2192 List A\nxs [ i ]%= f = updateAt xs i f\n\n-- xs [ i ]\u2254 y  overwrites the i-th element of xs with y\n\n_[_]\u2237=_ : (xs : List A) \u2192 Fin (length xs) \u2192 A \u2192 List A\nxs [ k ]\u2237= v = xs [ k ]%= const v\n\n------------------------------------------------------------------------\n-- Conditional versions of cons and snoc\n\ninfixr 5 _?\u2237_\n_?\u2237_ : Maybe A \u2192 List A \u2192 List A\n_?\u2237_ = maybe\u2032 _\u2237_ id\n\ninfixl 6 _\u2237\u02b3?_\n_\u2237\u02b3?_ : List A \u2192 Maybe A \u2192 List A\nxs \u2237\u02b3? x = maybe\u2032 (xs \u2237\u02b3_) xs x\n\n------------------------------------------------------------------------\n-- Raw algebraic bundles\n\nmodule _ (A : Set a) where\n  ++-rawMagma : RawMagma a _\n  ++-rawMagma = record\n    { Carrier = List A\n    ; _\u2248_ = _\u2261_\n    ; _\u2219_ = _++_\n    }\n\n  ++-[]-rawMonoid : RawMonoid a _\n  ++-[]-rawMonoid = record\n    { Carrier = List A\n    ; _\u2248_ = _\u2261_\n    ; _\u2219_ = _++_\n    ; \u03b5 = []\n    }\n\n------------------------------------------------------------------------\n-- DEPRECATED\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 1.4\n\ninfixl 5 _\u2237\u02b3'_\n_\u2237\u02b3'_ : (xs : List A) (x : A) \u2192 InitLast (xs \u2237\u02b3 x)\n_\u2237\u02b3'_ = InitLast._\u2237\u02b3\u2032_\n{-# WARNING_ON_USAGE _\u2237\u02b3'_\n\"Warning: _\u2237\u02b3'_ (ending in an apostrophe) was deprecated in v1.4.\nPlease use _\u2237\u02b3\u2032_ (ending in a prime) instead.\"\n#-}\n\n-- Version 2.0\n\ninfixl 5 _\u2500_\n_\u2500_ = removeAt\n{-# WARNING_ON_USAGE _\u2500_\n\"Warning: _\u2500_ was deprecated in v2.0.\nPlease use removeAt instead.\"\n#-}\n\n-- Version 2.1\n\nscanr : (A \u2192 B \u2192 B) \u2192 B \u2192 List A \u2192 List B\nscanr f e []       = e \u2237 []\nscanr f e (x \u2237 xs) with scanr f e xs\n... | []         = []                -- dead branch\n... | ys@(y \u2237 _) = f x y \u2237 ys\n{-# WARNING_ON_USAGE scanr\n\"Warning: scanr was deprecated in v2.1.\nPlease use Data.List.Scans.Base.scanr instead.\"\n#-}\n\nscanl : (A \u2192 B \u2192 A) \u2192 A \u2192 List B \u2192 List A\nscanl f e []       = e \u2237 []\nscanl f e (x \u2237 xs) = e \u2237 scanl f (f e x) xs\n{-# WARNING_ON_USAGE scanl\n\"Warning: scanl was deprecated in v2.1.\nPlease use Data.List.Scans.Base.scanl instead.\"\n#-}\n</pre>"},{"location":"md/Data/List/NonEmpty/Base/","title":"Data.List.NonEmpty.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Non-empty lists: base type and operations\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.List.NonEmpty.Base where\n\nopen import Level using (Level)\nopen import Data.Bool.Base using (Bool; false; true)\nopen import Data.List.Base as List using (List; []; _\u2237_)\nopen import Data.Maybe.Base using (Maybe ; nothing; just)\nopen import Data.Nat.Base as \u2115\nopen import Data.Product.Base as Prod using (\u2203; _\u00d7_; proj\u2081; proj\u2082; _,_; -,_)\nopen import Data.Sum.Base as Sum using (_\u228e_; inj\u2081; inj\u2082)\nopen import Data.These.Base as These using (These; this; that; these)\nopen import Data.Vec.Base as Vec using (Vec; []; _\u2237_)\nopen import Function.Base\nopen import Relation.Binary.PropositionalEquality.Core\n  using (_\u2261_; _\u2262_; refl)\nopen import Relation.Unary using (Pred; Decidable; U; \u2205)\nopen import Relation.Unary.Properties using (U?; \u2205?)\nopen import Relation.Nullary.Decidable using (does)\n\nprivate\n  variable\n    a p : Level\n    A B C : Set a\n\n------------------------------------------------------------------------\n-- Definition\n\ninfixr 5 _\u2237_\n\nrecord List\u207a (A : Set a) : Set a where\n  constructor _\u2237_\n  field\n    head : A\n    tail : List A\n\nopen List\u207a public\n\n------------------------------------------------------------------------\n-- Basic combinators\n\nuncons : List\u207a A \u2192 A \u00d7 List A\nuncons (hd \u2237 tl) = hd , tl\n\n[_] : A \u2192 List\u207a A\n[ x ] = x \u2237 []\n\ninfixr 5 _\u2237\u207a_\n\n_\u2237\u207a_ : A \u2192 List\u207a A \u2192 List\u207a A\nx \u2237\u207a y \u2237 xs = x \u2237 y \u2237 xs\n\nlength : List\u207a A \u2192 \u2115\nlength (x \u2237 xs) = suc (List.length xs)\n\n------------------------------------------------------------------------\n-- Conversion\n\ntoList : List\u207a A \u2192 List A\ntoList (x \u2237 xs) = x \u2237 xs\n\nfromList : List A \u2192 Maybe (List\u207a A)\nfromList []       = nothing\nfromList (x \u2237 xs) = just (x \u2237 xs)\n\nfromVec : \u2200 {n} \u2192 Vec A (suc n) \u2192 List\u207a A\nfromVec (x \u2237 xs) = x \u2237 Vec.toList xs\n\ntoVec : (xs : List\u207a A) \u2192 Vec A (length xs)\ntoVec (x \u2237 xs) = x \u2237 Vec.fromList xs\n\nlift : (\u2200 {m} \u2192 Vec A (suc m) \u2192 \u2203 \u03bb n \u2192 Vec B (suc n)) \u2192\n       List\u207a A \u2192 List\u207a B\nlift f xs = fromVec (proj\u2082 (f (toVec xs)))\n\n------------------------------------------------------------------------\n-- Other operations\n\nmap : (A \u2192 B) \u2192 List\u207a A \u2192 List\u207a B\nmap f (x \u2237 xs) = (f x \u2237 List.map f xs)\n\nreplicate : \u2200 n \u2192 n \u2262 0 \u2192 A \u2192 List\u207a A\nreplicate n n\u22620 a = a \u2237 List.replicate (pred n) a\n\n-- when dropping more than the size of the length of the list, the\n-- last element remains\ndrop+ : \u2115 \u2192 List\u207a A \u2192 List\u207a A\ndrop+ zero    xs           = xs\ndrop+ (suc n) (x \u2237 [])     = x \u2237 []\ndrop+ (suc n) (x \u2237 y \u2237 xs) = drop+ n (y \u2237 xs)\n\n-- Right fold. Note that s is only applied to the last element (see\n-- the examples below).\n\nfoldr : (A \u2192 B \u2192 B) \u2192 (A \u2192 B) \u2192 List\u207a A \u2192 B\nfoldr {A = A} {B = B} c s (x \u2237 xs) = foldr\u2032 x xs\n  where\n  foldr\u2032 : A \u2192 List A \u2192 B\n  foldr\u2032 x []       = s x\n  foldr\u2032 x (y \u2237 xs) = c x (foldr\u2032 y xs)\n\n-- Right fold.\n\nfoldr\u2081 : (A \u2192 A \u2192 A) \u2192 List\u207a A \u2192 A\nfoldr\u2081 f = foldr f id\n\n-- Left fold. Note that s is only applied to the first element (see\n-- the examples below).\n\nfoldl : (B \u2192 A \u2192 B) \u2192 (A \u2192 B) \u2192 List\u207a A \u2192 B\nfoldl c s (x \u2237 xs) = List.foldl c (s x) xs\n\n-- Left fold.\n\nfoldl\u2081 : (A \u2192 A \u2192 A) \u2192 List\u207a A \u2192 A\nfoldl\u2081 f = foldl f id\n\n-- Append (several variants).\n\ninfixr 5 _\u207a++\u207a_ _++\u207a_ _\u207a++_\n\n_\u207a++\u207a_ : List\u207a A \u2192 List\u207a A \u2192 List\u207a A\n(x \u2237 xs) \u207a++\u207a (y \u2237 ys) = x \u2237 (xs List.++ y \u2237 ys)\n\n_\u207a++_ : List\u207a A \u2192 List A \u2192 List\u207a A\n(x \u2237 xs) \u207a++ ys = x \u2237 (xs List.++ ys)\n\n_++\u207a_ : List A \u2192 List\u207a A \u2192 List\u207a A\nxs ++\u207a ys = List.foldr _\u2237\u207a_ ys xs\n\nconcat : List\u207a (List\u207a A) \u2192 List\u207a A\nconcat (xs \u2237 xss) = xs \u207a++ List.concat (List.map toList xss)\n\nconcatMap : (A \u2192 List\u207a B) \u2192 List\u207a A \u2192 List\u207a B\nconcatMap f = concat \u2218\u2032 map f\n\nap : List\u207a (A \u2192 B) \u2192 List\u207a A \u2192 List\u207a B\nap fs as = concatMap (\u03bb f \u2192 map f as) fs\n\n-- Inits\n\ninits : List A \u2192 List\u207a (List A)\ninits xs = [] \u2237 List.Inits.tail xs\n\n-- Tails\n\ntails : List A \u2192 List\u207a (List A)\ntails xs = xs \u2237 List.Tails.tail xs\n\n-- Reverse\n\nreverse : List\u207a A \u2192 List\u207a A\nreverse = lift (-,_ \u2218\u2032 Vec.reverse)\n\n-- Align and Zip\n\nalignWith : (These A B \u2192 C) \u2192 List\u207a A \u2192 List\u207a B \u2192 List\u207a C\nalignWith f (a \u2237 as) (b \u2237 bs) = f (these a b) \u2237 List.alignWith f as bs\n\nzipWith : (A \u2192 B \u2192 C) \u2192 List\u207a A \u2192 List\u207a B \u2192 List\u207a C\nzipWith f (a \u2237 as) (b \u2237 bs) = f a b \u2237 List.zipWith f as bs\n\nunalignWith : (A \u2192 These B C) \u2192 List\u207a A \u2192 These (List\u207a B) (List\u207a C)\nunalignWith f = foldr (These.alignWith mcons mcons \u2218\u2032 f)\n                    (These.map [_] [_] \u2218\u2032 f)\n\n  where mcons : \u2200 {e} {E : Set e} \u2192 These E (List\u207a E) \u2192 List\u207a E\n        mcons = These.fold [_] id _\u2237\u207a_\n\nunzipWith : (A \u2192 B \u00d7 C) \u2192 List\u207a A \u2192 List\u207a B \u00d7 List\u207a C\nunzipWith f (a \u2237 as) = Prod.zip _\u2237_ _\u2237_ (f a) (List.unzipWith f as)\n\nalign : List\u207a A \u2192 List\u207a B \u2192 List\u207a (These A B)\nalign = alignWith id\n\nzip : List\u207a A \u2192 List\u207a B \u2192 List\u207a (A \u00d7 B)\nzip = zipWith _,_\n\nunalign : List\u207a (These A B) \u2192 These (List\u207a A) (List\u207a B)\nunalign = unalignWith id\n\nunzip : List\u207a (A \u00d7 B) \u2192 List\u207a A \u00d7 List\u207a B\nunzip = unzipWith id\n\n-- Snoc.\n\ninfixl 5 _\u2237\u02b3_ _\u207a\u2237\u02b3_\n\n_\u2237\u02b3_ : List A \u2192 A \u2192 List\u207a A\n[]       \u2237\u02b3 y = [ y ]\n(x \u2237 xs) \u2237\u02b3 y = x \u2237 (xs List.\u2237\u02b3 y)\n\n_\u207a\u2237\u02b3_ : List\u207a A \u2192 A \u2192 List\u207a A\nxs \u207a\u2237\u02b3 x = toList xs \u2237\u02b3 x\n\n-- A snoc-view of non-empty lists.\n\ninfixl 5 _\u2237\u02b3\u2032_\n\ndata SnocView {A : Set a} : List\u207a A \u2192 Set a where\n  _\u2237\u02b3\u2032_ : (xs : List A) (x : A) \u2192 SnocView (xs \u2237\u02b3 x)\n\nsnocView : (xs : List\u207a A) \u2192 SnocView xs\nsnocView (x \u2237 xs)              with List.initLast xs\nsnocView (x \u2237 .[])             | []            = []       \u2237\u02b3\u2032 x\nsnocView (x \u2237 .(xs List.\u2237\u02b3 y)) | xs List.\u2237\u02b3\u2032 y = (x \u2237 xs) \u2237\u02b3\u2032 y\n\n-- The last element in the list.\n\nprivate\n  last\u2032 : \u2200 {l} \u2192 SnocView {A = A} l \u2192 A\n  last\u2032 (_ \u2237\u02b3\u2032 y) = y\n\nlast : List\u207a A \u2192 A\nlast = last\u2032 \u2218 snocView\n\n-- Groups all contiguous elements for which the predicate returns the\n-- same result into lists. The left sums are the ones for which the\n-- predicate holds, the right ones are the ones for which it doesn't.\ngroupSeqs\u1d47 : (A \u2192 Bool) \u2192 List A \u2192 List (List\u207a A \u228e List\u207a A)\ngroupSeqs\u1d47 p []       = []\ngroupSeqs\u1d47 p (x \u2237 xs) with p x | groupSeqs\u1d47 p xs\n... | true  | inj\u2081 xs\u2032 \u2237 xss = inj\u2081 (x \u2237\u207a xs\u2032) \u2237 xss\n... | true  | xss            = inj\u2081 [ x ]      \u2237 xss\n... | false | inj\u2082 xs\u2032 \u2237 xss = inj\u2082 (x \u2237\u207a xs\u2032) \u2237 xss\n... | false | xss            = inj\u2082 [ x ]      \u2237 xss\n\n-- Groups all contiguous elements /not/ satisfying the predicate into\n-- lists. Elements satisfying the predicate are dropped.\nwordsBy\u1d47 : (A \u2192 Bool) \u2192 List A \u2192 List (List\u207a A)\nwordsBy\u1d47 p = List.mapMaybe Sum.[ const nothing , just ] \u2218 groupSeqs\u1d47 p\n\ngroupSeqs : {P : Pred A p} \u2192 Decidable P \u2192 List A \u2192 List (List\u207a A \u228e List\u207a A)\ngroupSeqs P? = groupSeqs\u1d47 (does \u2218 P?)\n\nwordsBy : {P : Pred A p} \u2192 Decidable P \u2192 List A \u2192 List (List\u207a A)\nwordsBy P? = wordsBy\u1d47 (does \u2218 P?)\n\n-- Inverse operation for groupSequences.\nungroupSeqs : List (List\u207a A \u228e List\u207a A) \u2192 List A\nungroupSeqs = List.concat \u2218 List.map Sum.[ toList , toList ]\n\n------------------------------------------------------------------------\n-- Examples\n\n-- Note that these examples are simple unit tests, because the type\n-- checker verifies them.\n\nprivate\n module Examples {A B : Set}\n                 (_\u2295_ : A \u2192 B \u2192 B)\n                 (_\u2297_ : B \u2192 A \u2192 B)\n                 (_\u2299_ : A \u2192 A \u2192 A)\n                 (f : A \u2192 B)\n                 (a b c : A)\n                 where\n\n  hd : head (a \u2237\u207a b \u2237\u207a [ c ]) \u2261 a\n  hd = refl\n\n  tl : tail (a \u2237\u207a b \u2237\u207a [ c ]) \u2261 b \u2237 c \u2237 []\n  tl = refl\n\n  mp : map f (a \u2237\u207a b \u2237\u207a [ c ]) \u2261 f a \u2237\u207a f b \u2237\u207a [ f c ]\n  mp = refl\n\n  right : foldr _\u2295_ f (a \u2237\u207a b \u2237\u207a [ c ]) \u2261 (a \u2295 (b \u2295 f c))\n  right = refl\n\n  right\u2081 : foldr\u2081 _\u2299_ (a \u2237\u207a b \u2237\u207a [ c ]) \u2261 (a \u2299 (b \u2299 c))\n  right\u2081 = refl\n\n  left : foldl _\u2297_ f (a \u2237\u207a b \u2237\u207a [ c ]) \u2261 ((f a \u2297 b) \u2297 c)\n  left = refl\n\n  left\u2081 : foldl\u2081 _\u2299_ (a \u2237\u207a b \u2237\u207a [ c ]) \u2261 ((a \u2299 b) \u2299 c)\n  left\u2081 = refl\n\n  \u207aapp\u207a : (a \u2237\u207a b \u2237\u207a [ c ]) \u207a++\u207a (b \u2237\u207a [ c ]) \u2261\n          a \u2237\u207a b \u2237\u207a c \u2237\u207a b \u2237\u207a [ c ]\n  \u207aapp\u207a = refl\n\n  \u207aapp : (a \u2237\u207a b \u2237\u207a [ c ]) \u207a++ (b \u2237 c \u2237 []) \u2261\n          a \u2237\u207a b \u2237\u207a c \u2237\u207a b \u2237\u207a [ c ]\n  \u207aapp = refl\n\n  app\u207a : (a \u2237 b \u2237 c \u2237 []) ++\u207a (b \u2237\u207a [ c ]) \u2261\n          a \u2237\u207a b \u2237\u207a c \u2237\u207a b \u2237\u207a [ c ]\n  app\u207a = refl\n\n  conc : concat ((a \u2237\u207a b \u2237\u207a [ c ]) \u2237\u207a [ b \u2237\u207a [ c ] ]) \u2261\n         a \u2237\u207a b \u2237\u207a c \u2237\u207a b \u2237\u207a [ c ]\n  conc = refl\n\n  rev : reverse (a \u2237\u207a b \u2237\u207a [ c ]) \u2261 c \u2237\u207a b \u2237\u207a [ a ]\n  rev = refl\n\n  snoc : (a \u2237 b \u2237 c \u2237 []) \u2237\u02b3 a \u2261 a \u2237\u207a b \u2237\u207a c \u2237\u207a [ a ]\n  snoc = refl\n\n  snoc\u207a : (a \u2237\u207a b \u2237\u207a [ c ]) \u207a\u2237\u02b3 a \u2261 a \u2237\u207a b \u2237\u207a c \u2237\u207a [ a ]\n  snoc\u207a = refl\n\n  groupSeqs-true : groupSeqs U? (a \u2237 b \u2237 c \u2237 []) \u2261\n               inj\u2081 (a \u2237\u207a b \u2237\u207a [ c ]) \u2237 []\n  groupSeqs-true = refl\n\n  groupSeqs-false : groupSeqs \u2205? (a \u2237 b \u2237 c \u2237 []) \u2261\n                inj\u2082 (a \u2237\u207a b \u2237\u207a [ c ]) \u2237 []\n  groupSeqs-false = refl\n\n  groupSeqs-\u22611 : groupSeqs\u1d47 (\u2115._\u2261\u1d47 1) (1 \u2237 2 \u2237 3 \u2237 1 \u2237 1 \u2237 2 \u2237 1 \u2237 []) \u2261\n                 inj\u2081 [ 1 ] \u2237\n                 inj\u2082 (2 \u2237\u207a [ 3 ]) \u2237\n                 inj\u2081 (1 \u2237\u207a [ 1 ]) \u2237\n                 inj\u2082 [ 2 ] \u2237\n                 inj\u2081 [ 1 ] \u2237\n                 []\n  groupSeqs-\u22611 = refl\n\n  wordsBy-true : wordsBy\u1d47 (const true) (a \u2237 b \u2237 c \u2237 []) \u2261 []\n  wordsBy-true = refl\n\n  wordsBy-false : wordsBy\u1d47 (const false) (a \u2237 b \u2237 c \u2237 []) \u2261\n                  (a \u2237\u207a b \u2237\u207a [ c ]) \u2237 []\n  wordsBy-false = refl\n\n  wordsBy-\u22611 : wordsBy\u1d47 (\u2115._\u2261\u1d47 1) (1 \u2237 2 \u2237 3 \u2237 1 \u2237 1 \u2237 2 \u2237 1 \u2237 []) \u2261\n               (2 \u2237\u207a [ 3 ]) \u2237\n               [ 2 ] \u2237\n               []\n  wordsBy-\u22611 = refl\n</pre>"},{"location":"md/Data/List/Relation/Binary/Lex/Core/","title":"Data.List.Relation.Binary.Lex.Core","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Lexicographic ordering of lists\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.List.Relation.Binary.Lex.Core where\n\nopen import Data.Empty using (\u22a5; \u22a5-elim)\nopen import Data.Unit.Base using (\u22a4; tt)\nopen import Data.Product.Base using (_\u00d7_; _,_; proj\u2081; proj\u2082; uncurry)\nopen import Data.List.Base using (List; []; _\u2237_)\nopen import Function.Base using (_\u2218_; flip; id)\nopen import Level using (Level; _\u2294_)\nopen import Relation.Nullary.Negation using (\u00ac_)\nopen import Relation.Binary.Core using (Rel)\nopen import Data.List.Relation.Binary.Pointwise.Base\n   using (Pointwise; []; _\u2237_; head; tail)\n\nprivate\n  variable\n    a \u2113\u2081 \u2113\u2082 : Level\n\n-- The lexicographic ordering itself can be either strict or non-strict,\n-- depending on whether type P is inhabited.\n\ndata Lex {A : Set a} (P : Set)\n         (_\u2248_ : Rel A \u2113\u2081) (_\u227a_ : Rel A \u2113\u2082) :\n         Rel (List A) (a \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  base : P                             \u2192 Lex P _\u2248_ _\u227a_ []       []\n  halt : \u2200 {y ys}                      \u2192 Lex P _\u2248_ _\u227a_ []       (y \u2237 ys)\n  this : \u2200 {x xs y ys} (x\u227ay : x \u227a y)   \u2192 Lex P _\u2248_ _\u227a_ (x \u2237 xs) (y \u2237 ys)\n  next : \u2200 {x xs y ys} (x\u2248y : x \u2248 y)\n         (xs&lt;ys : Lex P _\u2248_ _\u227a_ xs ys) \u2192 Lex P _\u2248_ _\u227a_ (x \u2237 xs) (y \u2237 ys)\n\n------------------------------------------------------------------------\n-- Lexicographic orderings, using a strict ordering as the base\n\nLex-&lt; : {A : Set a} (_\u2248_ : Rel A \u2113\u2081) (_\u227a_ : Rel A \u2113\u2082) \u2192\n        Rel (List A) (a \u2294 \u2113\u2081 \u2294 \u2113\u2082)\nLex-&lt; = Lex \u22a5\n\nLex-\u2264 : {A : Set a} (_\u2248_ : Rel A \u2113\u2081) (_\u227a_ : Rel A \u2113\u2082) \u2192\n        Rel (List A) (a \u2294 \u2113\u2081 \u2294 \u2113\u2082)\nLex-\u2264 = Lex \u22a4\n</pre>"},{"location":"md/Data/List/Relation/Binary/Pointwise/Base/","title":"Data.List.Relation.Binary.Pointwise.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Pointwise lifting of relations to lists\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.List.Relation.Binary.Pointwise.Base where\n\nopen import Data.Product.Base as Product using (_\u00d7_; _,_; &lt;_,_&gt;; \u2203-syntax)\nopen import Data.List.Base using (List; []; _\u2237_)\nopen import Level using (Level; _\u2294_)\nopen import Relation.Binary.Core using (REL; _\u21d2_)\nopen import Relation.Binary.Construct.Composition using (_\u037e_)\n\nprivate\n  variable\n    a b c \u2113 : Level\n    A B : Set a\n    x y : A\n    xs ys : List A\n    R S : REL A B \u2113\n\n------------------------------------------------------------------------\n-- Definition\n------------------------------------------------------------------------\n\ninfixr 5 _\u2237_\n\ndata Pointwise {A : Set a} {B : Set b} (R : REL A B \u2113)\n               : List A \u2192 List B \u2192 Set (a \u2294 b \u2294 \u2113) where\n  []  : Pointwise R [] []\n  _\u2237_ : (x\u223cy : R x y) (xs\u223cys : Pointwise R xs ys) \u2192\n        Pointwise R (x \u2237 xs) (y \u2237 ys)\n\n------------------------------------------------------------------------\n-- Operations\n------------------------------------------------------------------------\n\nhead : Pointwise R (x \u2237 xs) (y \u2237 ys) \u2192 R x y\nhead (x\u223cy \u2237 xs\u223cys) = x\u223cy\n\ntail : Pointwise R (x \u2237 xs) (y \u2237 ys) \u2192 Pointwise R xs ys\ntail (x\u223cy \u2237 xs\u223cys) = xs\u223cys\n\nuncons : Pointwise R (x \u2237 xs) (y \u2237 ys) \u2192 R x y \u00d7 Pointwise R xs ys\nuncons = &lt; head , tail &gt;\n\nrec : \u2200 (P : \u2200 {xs ys} \u2192 Pointwise R xs ys \u2192 Set c) \u2192\n      (\u2200 {x y xs ys} {Rxsys : Pointwise R xs ys} \u2192\n        (Rxy : R x y) \u2192 P Rxsys \u2192 P (Rxy \u2237 Rxsys)) \u2192\n      P [] \u2192\n      \u2200 {xs ys} (Rxsys : Pointwise R xs ys) \u2192 P Rxsys\nrec P c n []            = n\nrec P c n (Rxy \u2237 Rxsys) = c Rxy (rec P c n Rxsys)\n\nmap : R \u21d2 S \u2192 Pointwise R \u21d2 Pointwise S\nmap R\u21d2S []            = []\nmap R\u21d2S (Rxy \u2237 Rxsys) = R\u21d2S Rxy \u2237 map R\u21d2S Rxsys\n\nunzip : Pointwise (R \u037e S) \u21d2 (Pointwise R \u037e Pointwise S)\nunzip [] = [] , [] , []\nunzip ((y , r , s) \u2237 xs\u223cys) =\n  Product.map (y \u2237_) (Product.map (r \u2237_) (s \u2237_)) (unzip xs\u223cys)\n</pre>"},{"location":"md/Data/Maybe/Base/","title":"Data.Maybe.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- The Maybe type and some operations\n------------------------------------------------------------------------\n\n-- The definitions in this file are reexported by Data.Maybe.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Maybe.Base where\n\nopen import Level using (Level; Lift)\nopen import Data.Bool.Base using (Bool; true; false; not)\nopen import Data.Unit.Base using (\u22a4)\nopen import Data.These.Base using (These; this; that; these)\nopen import Data.Product.Base as Prod using (_\u00d7_; _,_)\nopen import Function.Base using (_\u2218_; id; const)\nimport Relation.Nullary.Decidable.Core as Dec\n\nprivate\n  variable\n    a b c : Level\n    A : Set a\n    B : Set b\n    C : Set c\n\n------------------------------------------------------------------------\n-- Definition\n\nopen import Agda.Builtin.Maybe public\n  using (Maybe; just; nothing)\n\n------------------------------------------------------------------------\n-- Some operations\n\nboolToMaybe : Bool \u2192 Maybe \u22a4\nboolToMaybe true  = just _\nboolToMaybe false = nothing\n\nis-just : Maybe A \u2192 Bool\nis-just (just _) = true\nis-just nothing  = false\n\nis-nothing : Maybe A \u2192 Bool\nis-nothing = not \u2218 is-just\n\n-- A dependent eliminator.\n\nmaybe : \u2200 {A : Set a} {B : Maybe A \u2192 Set b} \u2192\n        ((x : A) \u2192 B (just x)) \u2192 B nothing \u2192 (x : Maybe A) \u2192 B x\nmaybe j n (just x) = j x\nmaybe j n nothing  = n\n\n-- A non-dependent eliminator.\n\nmaybe\u2032 : (A \u2192 B) \u2192 B \u2192 Maybe A \u2192 B\nmaybe\u2032 = maybe\n\n-- A defaulting mechanism\n\nfromMaybe : A \u2192 Maybe A \u2192 A\nfromMaybe = maybe\u2032 id\n\n-- A safe variant of \"fromJust\". If the value is nothing, then the\n-- return type is the unit type.\n\nmodule _ {a} {A : Set a} where\n\n  From-just : Maybe A \u2192 Set a\n  From-just (just _) = A\n  From-just nothing  = Lift a \u22a4\n\n  from-just : (x : Maybe A) \u2192 From-just x\n  from-just (just x) = x\n  from-just nothing  = _\n\n-- Functoriality: map\n\nmap : (A \u2192 B) \u2192 Maybe A \u2192 Maybe B\nmap f = maybe (just \u2218 f) nothing\n\n-- Applicative: ap\n\nap : Maybe (A \u2192 B) \u2192 Maybe A \u2192 Maybe B\nap nothing  = const nothing\nap (just f) = map f\n\n-- Monad: bind\n\ninfixl 1 _&gt;&gt;=_\n_&gt;&gt;=_ : Maybe A \u2192 (A \u2192 Maybe B) \u2192 Maybe B\nnothing &gt;&gt;= f = nothing\njust a  &gt;&gt;= f = f a\n\n-- Alternative: &lt;\u2223&gt;\n\ninfixr 6 _&lt;\u2223&gt;_\n_&lt;\u2223&gt;_ : Maybe A \u2192 Maybe A \u2192 Maybe A\njust x  &lt;\u2223&gt; my = just x\nnothing &lt;\u2223&gt; my = my\n\n-- Just when the boolean is true\n\nwhen : Bool \u2192 A \u2192 Maybe A\nwhen b c = map (const c) (boolToMaybe b)\n\n------------------------------------------------------------------------\n-- Aligning and zipping\n\nalignWith : (These A B \u2192 C) \u2192 Maybe A \u2192 Maybe B \u2192 Maybe C\nalignWith f (just a) (just b) = just (f (these a b))\nalignWith f (just a) nothing  = just (f (this a))\nalignWith f nothing  (just b) = just (f (that b))\nalignWith f nothing  nothing  = nothing\n\nzipWith : (A \u2192 B \u2192 C) \u2192 Maybe A \u2192 Maybe B \u2192 Maybe C\nzipWith f (just a) (just b) = just (f a b)\nzipWith _ _        _        = nothing\n\nalign : Maybe A \u2192 Maybe B \u2192 Maybe (These A B)\nalign = alignWith id\n\nzip : Maybe A \u2192 Maybe B \u2192 Maybe (A \u00d7 B)\nzip = zipWith _,_\n\n------------------------------------------------------------------------\n-- Injections.\n\nthisM : A \u2192 Maybe B \u2192 These A B\nthisM a = maybe\u2032 (these a) (this a)\n\nthatM : Maybe A \u2192 B \u2192 These A B\nthatM = maybe\u2032 these that\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 2.1\n-- decToMaybe\n\nopen Dec using (decToMaybe) public\n</pre>"},{"location":"md/Data/Nat/Base/","title":"Data.Nat.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Natural numbers, basic types and operations\n------------------------------------------------------------------------\n\n-- See README.Data.Nat for examples of how to use and reason about\n-- naturals.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Nat.Base where\n\nopen import Algebra.Bundles.Raw using (RawMagma; RawMonoid; RawNearSemiring; RawSemiring)\nopen import Algebra.Definitions.RawMagma using (_\u2223\u02e1_; _,_)\nopen import Data.Bool.Base using (Bool; true; false; T; not)\nopen import Data.Parity.Base using (Parity; 0\u2119; 1\u2119)\nopen import Level using (0\u2113)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.PropositionalEquality.Core\n  using (_\u2261_; _\u2262_; refl; cong)\nopen import Relation.Nullary.Negation.Core using (\u00ac_; contradiction)\nopen import Relation.Unary using (Pred)\n\n------------------------------------------------------------------------\n-- Types\n\nopen import Agda.Builtin.Nat public\n  using (zero; suc) renaming (Nat to \u2115)\n\n--smart constructor\npattern 2+ n = suc (suc n)\n\n------------------------------------------------------------------------\n-- Boolean equality relation\n\nopen import Agda.Builtin.Nat public\n  using () renaming (_==_ to _\u2261\u1d47_)\n\n------------------------------------------------------------------------\n-- Boolean ordering relation\n\nopen import Agda.Builtin.Nat public\n  using () renaming (_&lt;_ to _&lt;\u1d47_)\n\ninfix 4 _\u2264\u1d47_\n_\u2264\u1d47_ : (m n : \u2115) \u2192 Bool\nzero  \u2264\u1d47 n = true\nsuc m \u2264\u1d47 n = m &lt;\u1d47 n\n\n------------------------------------------------------------------------\n-- Standard ordering relations\n\ninfix 4 _\u2264_ _&lt;_ _\u2265_ _&gt;_ _\u2270_ _\u226e_ _\u2271_ _\u226f_\n\ndata _\u2264_ : Rel \u2115 0\u2113 where\n  z\u2264n : \u2200 {n}                 \u2192 zero  \u2264 n\n  s\u2264s : \u2200 {m n} (m\u2264n : m \u2264 n) \u2192 suc m \u2264 suc n\n\n_&lt;_ : Rel \u2115 0\u2113\nm &lt; n = suc m \u2264 n\n\n-- Smart constructors of _&lt;_\n\npattern z&lt;s     {n}     = s\u2264s (z\u2264n {n})\npattern s&lt;s {m} {n} m&lt;n = s\u2264s {m} {n} m&lt;n\npattern sz&lt;ss   {n}     = s&lt;s (z&lt;s {n})\n\n-- Smart destructors of _\u2264_, _&lt;_\n\ns\u2264s\u207b\u00b9 : \u2200 {m n} \u2192 suc m \u2264 suc n \u2192 m \u2264 n\ns\u2264s\u207b\u00b9 (s\u2264s m\u2264n) = m\u2264n\n\ns&lt;s\u207b\u00b9 : \u2200 {m n} \u2192 suc m &lt; suc n \u2192 m &lt; n\ns&lt;s\u207b\u00b9 (s&lt;s m&lt;n) = m&lt;n\n\n\n------------------------------------------------------------------------\n-- Other derived ordering relations\n\n_\u2265_ : Rel \u2115 0\u2113\nm \u2265 n = n \u2264 m\n\n_&gt;_ : Rel \u2115 0\u2113\nm &gt; n = n &lt; m\n\n_\u2270_ : Rel \u2115 0\u2113\na \u2270 b = \u00ac a \u2264 b\n\n_\u226e_ : Rel \u2115 0\u2113\na \u226e b = \u00ac a &lt; b\n\n_\u2271_ : Rel \u2115 0\u2113\na \u2271 b = \u00ac a \u2265 b\n\n_\u226f_ : Rel \u2115 0\u2113\na \u226f b = \u00ac a &gt; b\n\n------------------------------------------------------------------------\n-- Simple predicates\n\n-- Defining these predicates in terms of `T` and therefore ultimately\n-- `\u22a4` and `\u22a5` allows Agda to automatically infer them for any natural\n-- of the correct form. Consequently in many circumstances this\n-- eliminates the need to explicitly pass a proof when the predicate\n-- argument is either an implicit or an instance argument. See `_/_`\n-- and `_%_` further down this file for examples.\n--\n-- Furthermore, defining these predicates as single-field records\n-- (rather defining them directly as the type of their field) is\n-- necessary as the current version of Agda is far better at\n-- reconstructing meta-variable values for the record parameters.\n\n-- A predicate saying that a number is not equal to 0.\n\nrecord NonZero (n : \u2115) : Set where\n  field\n    nonZero : T (not (n \u2261\u1d47 0))\n\n-- Instances\n\ninstance\n  nonZero : \u2200 {n} \u2192 NonZero (suc n)\n  nonZero = _\n\n-- Constructors\n\n\u2262-nonZero : \u2200 {n} \u2192 n \u2262 0 \u2192 NonZero n\n\u2262-nonZero {zero}  0\u22620 = contradiction refl 0\u22620\n\u2262-nonZero {suc n} n\u22620 = _\n\n&gt;-nonZero : \u2200 {n} \u2192 n &gt; 0 \u2192 NonZero n\n&gt;-nonZero z&lt;s = _\n\n-- Destructors\n\n\u2262-nonZero\u207b\u00b9 : \u2200 n \u2192 .{{NonZero n}} \u2192 n \u2262 0\n\u2262-nonZero\u207b\u00b9 (suc n) ()\n\n&gt;-nonZero\u207b\u00b9 : \u2200 n \u2192 .{{NonZero n}} \u2192 n &gt; 0\n&gt;-nonZero\u207b\u00b9 (suc n) = z&lt;s\n\n-- The property of being a non-zero, non-unit\n\nrecord NonTrivial (n : \u2115) : Set where\n  field\n    nonTrivial : T (1 &lt;\u1d47 n)\n\n-- Instances\n\ninstance\n  nonTrivial : \u2200 {n} \u2192 NonTrivial (2+ n)\n  nonTrivial = _\n\n-- Constructors\n\nn&gt;1\u21d2nonTrivial : \u2200 {n} \u2192 n &gt; 1 \u2192 NonTrivial n\nn&gt;1\u21d2nonTrivial sz&lt;ss = _\n\n-- Destructors\n\nnonTrivial\u21d2nonZero : \u2200 n \u2192 .{{NonTrivial n}} \u2192 NonZero n\nnonTrivial\u21d2nonZero (2+ _) = _\n\nnonTrivial\u21d2n&gt;1 : \u2200 n \u2192 .{{NonTrivial n}} \u2192 n &gt; 1\nnonTrivial\u21d2n&gt;1 (2+ _) = sz&lt;ss\n\nnonTrivial\u21d2\u22621 : \u2200 {n} \u2192 .{{NonTrivial n}} \u2192 n \u2262 1\nnonTrivial\u21d2\u22621 {{()}} refl\n\n------------------------------------------------------------------------\n-- Raw bundles\n\nopen import Agda.Builtin.Nat public\n  using (_+_; _*_) renaming (_-_ to _\u2238_)\n\n+-rawMagma : RawMagma 0\u2113 0\u2113\n+-rawMagma = record\n  { _\u2248_ = _\u2261_\n  ; _\u2219_ = _+_\n  }\n\n+-0-rawMonoid : RawMonoid 0\u2113 0\u2113\n+-0-rawMonoid = record\n  { _\u2248_ = _\u2261_\n  ; _\u2219_ = _+_\n  ; \u03b5   = 0\n  }\n\n*-rawMagma : RawMagma 0\u2113 0\u2113\n*-rawMagma = record\n  { _\u2248_ = _\u2261_\n  ; _\u2219_ = _*_\n  }\n\n*-1-rawMonoid : RawMonoid 0\u2113 0\u2113\n*-1-rawMonoid = record\n  { _\u2248_ = _\u2261_\n  ; _\u2219_ = _*_\n  ; \u03b5 = 1\n  }\n\n+-*-rawNearSemiring : RawNearSemiring 0\u2113 0\u2113\n+-*-rawNearSemiring = record\n  { Carrier = _\n  ; _\u2248_ = _\u2261_\n  ; _+_ = _+_\n  ; _*_ = _*_\n  ; 0# = 0\n  }\n\n+-*-rawSemiring : RawSemiring 0\u2113 0\u2113\n+-*-rawSemiring = record\n  { Carrier = _\n  ; _\u2248_ = _\u2261_\n  ; _+_ = _+_\n  ; _*_ = _*_\n  ; 0# = 0\n  ; 1# = 1\n  }\n\n------------------------------------------------------------------------\n-- Arithmetic\n\nopen import Agda.Builtin.Nat\n  using (div-helper; mod-helper)\n\npred : \u2115 \u2192 \u2115\npred n = n \u2238 1\n\ninfix  8 _!\ninfixl 7 _\u2293_ _\u2293\u2032_ _/_ _%_\ninfixl 6 _+\u22ce_ _\u2294_ _\u2294\u2032_\n\n-- Argument-swapping addition. Used by Data.Vec._\u22ce_.\n\n_+\u22ce_ : \u2115 \u2192 \u2115 \u2192 \u2115\nzero  +\u22ce n = n\nsuc m +\u22ce n = suc (n +\u22ce m)\n\n-- Max.\n\n_\u2294_ : \u2115 \u2192 \u2115 \u2192 \u2115\nzero  \u2294 n     = n\nsuc m \u2294 zero  = suc m\nsuc m \u2294 suc n = suc (m \u2294 n)\n\n-- Max defined in terms of primitive operations.\n-- This is much faster than `_\u2294_` but harder to reason about. For proofs\n-- involving this function, convert it to `_\u2294_` with `Data.Nat.Properties.\u2294\u2261\u2294\u2035`.\n_\u2294\u2032_ : \u2115 \u2192 \u2115 \u2192 \u2115\nm \u2294\u2032 n with m &lt;\u1d47 n\n... | false = m\n... | true  = n\n\n-- Min.\n\n_\u2293_ : \u2115 \u2192 \u2115 \u2192 \u2115\nzero  \u2293 n     = zero\nsuc m \u2293 zero  = zero\nsuc m \u2293 suc n = suc (m \u2293 n)\n\n-- Min defined in terms of primitive operations.\n-- This is much faster than `_\u2293_` but harder to reason about. For proofs\n-- involving this function, convert it to `_\u2293_` wtih `Data.Nat.properties.\u2293\u2261\u2293\u2032`.\n_\u2293\u2032_ : \u2115 \u2192 \u2115 \u2192 \u2115\nm \u2293\u2032 n with m &lt;\u1d47 n\n... | false = n\n... | true  = m\n\n-- Parity\n\nparity : \u2115 \u2192 Parity\nparity 0             = 0\u2119\nparity 1             = 1\u2119\nparity (suc (suc n)) = parity n\n\n-- Division by 2, rounded downwards.\n\n\u230a_/2\u230b : \u2115 \u2192 \u2115\n\u230a 0 /2\u230b           = 0\n\u230a 1 /2\u230b           = 0\n\u230a suc (suc n) /2\u230b = suc \u230a n /2\u230b\n\n-- Division by 2, rounded upwards.\n\n\u2308_/2\u2309 : \u2115 \u2192 \u2115\n\u2308 n /2\u2309 = \u230a suc n /2\u230b\n\n-- Na\u00efve exponentiation\n\ninfixr 8 _^_\n\n_^_ : \u2115 \u2192 \u2115 \u2192 \u2115\nx ^ zero  = 1\nx ^ suc n = x * x ^ n\n\n-- Distance\n\n\u2223_-_\u2223 : \u2115 \u2192 \u2115 \u2192 \u2115\n\u2223 zero  - y     \u2223 = y\n\u2223 x     - zero  \u2223 = x\n\u2223 suc x - suc y \u2223 = \u2223 x - y \u2223\n\n-- Distance in terms of primitive operations.\n-- This is much faster than `\u2223_-_\u2223` but harder to reason about.\n-- For proofs involving this function, convert it to `\u2223_-_\u2223` with\n-- `Data.Nat.Properties.\u2223-\u2223\u2261\u2223-\u2223\u2032`.\n\u2223_-_\u2223\u2032 : \u2115 \u2192 \u2115 \u2192 \u2115\n\u2223 x - y \u2223\u2032 with x &lt;\u1d47 y\n... | false = x \u2238 y\n... | true  = y \u2238 x\n\n-- Division\n-- Note properties of these are in `Nat.DivMod` not `Nat.Properties`\n\n_/_ : (dividend divisor : \u2115) .{{_ : NonZero divisor}} \u2192 \u2115\nm / (suc n) = div-helper 0 n m n\n\n-- Remainder/modulus\n-- Note properties of these are in `Nat.DivMod` not `Nat.Properties`\n\n_%_ : (dividend divisor : \u2115) .{{_ : NonZero divisor}} \u2192 \u2115\nm % (suc n) = mod-helper 0 n m n\n\n-- Factorial\n\n_! : \u2115 \u2192 \u2115\nzero  ! = 1\nsuc n ! = suc n * n !\n\n------------------------------------------------------------------------\n-- Extensionally equivalent alternative definitions of _\u2264_/_&lt;_ etc.\n\n-- _\u2264\u2032_: this definition is more suitable for well-founded induction\n-- (see Data.Nat.Induction)\n\ninfix 4 _\u2264\u2032_ _&lt;\u2032_ _\u2265\u2032_ _&gt;\u2032_\n\ndata _\u2264\u2032_ (m : \u2115) : \u2115 \u2192 Set where\n  \u2264\u2032-reflexive : \u2200 {n} \u2192 m \u2261 n \u2192 m \u2264\u2032 n\n  \u2264\u2032-step : \u2200 {n} \u2192 m \u2264\u2032 n \u2192 m \u2264\u2032 suc n\n\npattern \u2264\u2032-refl {m} = \u2264\u2032-reflexive {n = m} refl\n\n_&lt;\u2032_ : Rel \u2115 0\u2113\nm &lt;\u2032 n = suc m \u2264\u2032 n\n\n-- Smart constructors of _&lt;\u2032_\n\npattern &lt;\u2032-base          = \u2264\u2032-refl\npattern &lt;\u2032-step {n} m&lt;\u2032n = \u2264\u2032-step {n} m&lt;\u2032n\n\n_\u2265\u2032_ : Rel \u2115 0\u2113\nm \u2265\u2032 n = n \u2264\u2032 m\n\n_&gt;\u2032_ : Rel \u2115 0\u2113\nm &gt;\u2032 n = n &lt;\u2032 m\n\n-- _\u2264\u2033_: this definition of _\u2264_ is used for proof-irrelevant \u2035DivMod`\n-- and is a specialised instance of a general algebraic construction\n\ninfix 4 _\u2264\u2033_ _&lt;\u2033_ _\u2265\u2033_ _&gt;\u2033_\n\n_\u2264\u2033_ : (m n : \u2115)  \u2192 Set\n_\u2264\u2033_ = _\u2223\u02e1_ +-rawMagma\n\n_&lt;\u2033_ : Rel \u2115 0\u2113\nm &lt;\u2033 n = suc m \u2264\u2033 n\n\n_\u2265\u2033_ : Rel \u2115 0\u2113\nm \u2265\u2033 n = n \u2264\u2033 m\n\n_&gt;\u2033_ : Rel \u2115 0\u2113\nm &gt;\u2033 n = n &lt;\u2033 m\n\n-- Smart destructor of _&lt;\u2033_\n\ns&lt;\u2033s\u207b\u00b9 : \u2200 {m n} \u2192 suc m &lt;\u2033 suc n \u2192 m &lt;\u2033 n\ns&lt;\u2033s\u207b\u00b9 (k , eq) = k , cong pred eq\n\n-- _\u2264\u2034_: this definition is useful for induction with an upper bound.\n\ninfix 4 _\u2264\u2034_ _&lt;\u2034_ _\u2265\u2034_ _&gt;\u2034_\n\ndata _\u2264\u2034_ (m n : \u2115) : Set\n\n_&lt;\u2034_ : Rel \u2115 0\u2113\nm &lt;\u2034 n = suc m \u2264\u2034 n\n\ndata _\u2264\u2034_ m n where\n  \u2264\u2034-reflexive : m \u2261 n \u2192 m \u2264\u2034 n\n  \u2264\u2034-step      : m &lt;\u2034 n \u2192 m \u2264\u2034 n\n\npattern \u2264\u2034-refl = \u2264\u2034-reflexive refl\n\n_\u2265\u2034_ : Rel \u2115 0\u2113\nm \u2265\u2034 n = n \u2264\u2034 m\n\n_&gt;\u2034_ : Rel \u2115 0\u2113\nm &gt;\u2034 n = n &lt;\u2034 m\n\n------------------------------------------------------------------------\n-- A comparison view. Taken from \"View from the left\"\n-- (McBride/McKinna); details may differ.\n\ndata Ordering : Rel \u2115 0\u2113 where\n  less    : \u2200 m k \u2192 Ordering m (suc (m + k))\n  equal   : \u2200 m   \u2192 Ordering m m\n  greater : \u2200 m k \u2192 Ordering (suc (m + k)) m\n\ncompare : \u2200 m n \u2192 Ordering m n\ncompare zero    zero    = equal   zero\ncompare (suc m) zero    = greater zero m\ncompare zero    (suc n) = less    zero n\ncompare (suc m) (suc n) with compare m n\n... | less    m k = less (suc m) k\n... | equal   m   = equal (suc m)\n... | greater n k = greater (suc n) k\n\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 2.1\n\n-- Smart constructors of _\u2264\u2033_ and _&lt;\u2033_\npattern less-than-or-equal {k} eq = k , eq\n{-# WARNING_ON_USAGE less-than-or-equal\n\"Warning: less-than-or-equal was deprecated in v2.1. Please match directly on proofs of \u2264\u2033 using constructor Algebra.Definitions.RawMagma._\u2223\u02e1_._,_ instead. \"\n#-}\npattern \u2264\u2033-offset k = k , refl\n{-# WARNING_ON_USAGE \u2264\u2033-offset\n\"Warning: \u2264\u2033-offset was deprecated in v2.1. Please match directly on proofs of \u2264\u2033 using pattern (_, refl) from Algebra.Definitions.RawMagma._\u2223\u02e1_ instead. \"\n#-}\npattern &lt;\u2033-offset k = k , refl\n{-# WARNING_ON_USAGE &lt;\u2033-offset\n\"Warning: &lt;\u2033-offset was deprecated in v2.1. Please match directly on proofs of \u2264\u2033 using pattern (_, refl) from Algebra.Definitions.RawMagma._\u2223\u02e1_ instead. \"\n#-}\n\n-- Smart destructor of _\u2264\u2033_\n\ns\u2264\u2033s\u207b\u00b9 : \u2200 {m n} \u2192 suc m \u2264\u2033 suc n \u2192 m \u2264\u2033 n\ns\u2264\u2033s\u207b\u00b9 (k , eq) = k , cong pred eq\n{-# WARNING_ON_USAGE s\u2264\u2033s\u207b\u00b9\n\"Warning: s\u2264\u2033s\u207b\u00b9 was deprecated in v2.1. Please match directly on proofs of \u2264\u2033 using constructor Algebra.Definitions.RawMagma._\u2223\u02e1_._,_ instead. \"\n#-}\n</pre>"},{"location":"md/Data/Parity/Base/","title":"Data.Parity.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Parity\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Parity.Base where\n\nopen import Algebra.Bundles.Raw\n  using (RawMagma; RawMonoid; RawGroup; RawNearSemiring; RawSemiring)\nopen import Data.Sign.Base using (Sign; +; -)\nopen import Level using (0\u2113)\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_)\n\n------------------------------------------------------------------------\n-- Definition\n\ndata Parity : Set where\n  0\u2119 : Parity\n  1\u2119 : Parity\n\n------------------------------------------------------------------------\n-- Operations\n\n-- The opposite parity.\n\ninfix 8 _\u207b\u00b9\n\n_\u207b\u00b9 : Parity \u2192 Parity\n1\u2119 \u207b\u00b9 = 0\u2119\n0\u2119 \u207b\u00b9 = 1\u2119\n\n-- Addition.\n\ninfixl 7 _+_\n\n_+_ : Parity \u2192 Parity \u2192 Parity\n0\u2119 + p = p\n1\u2119 + p = p \u207b\u00b9\n\n-- Multiplication.\n\ninfixl 7 _*_\n\n_*_ : Parity \u2192 Parity \u2192 Parity\n0\u2119 * p = 0\u2119\n1\u2119 * p = p\n\n------------------------------------------------------------------------\n-- Raw Bundles\n\n+-rawMagma : RawMagma 0\u2113 0\u2113\n+-rawMagma = record\n  { _\u2248_ = _\u2261_\n  ; _\u2219_ = _+_\n  }\n\n+-0-rawMonoid : RawMonoid 0\u2113 0\u2113\n+-0-rawMonoid = record\n  { _\u2248_ = _\u2261_\n  ; _\u2219_ = _+_\n  ; \u03b5 = 0\u2119\n  }\n\n+-0-rawGroup : RawGroup 0\u2113 0\u2113\n+-0-rawGroup = record\n  { _\u2248_ = _\u2261_\n  ; _\u2219_ = _+_\n  ; _\u207b\u00b9 = _\u207b\u00b9\n  ; \u03b5 = 0\u2119\n  }\n\n*-rawMagma : RawMagma 0\u2113 0\u2113\n*-rawMagma = record\n  { _\u2248_ = _\u2261_\n  ; _\u2219_ = _*_\n  }\n\n*-1-rawMonoid : RawMonoid 0\u2113 0\u2113\n*-1-rawMonoid = record\n  { _\u2248_ = _\u2261_\n  ; _\u2219_ = _*_\n  ; \u03b5 = 1\u2119\n  }\n\n+-*-rawNearSemiring : RawNearSemiring 0\u2113 0\u2113\n+-*-rawNearSemiring = record\n  { Carrier = _\n  ; _\u2248_ = _\u2261_\n  ; _+_ = _+_\n  ; _*_ = _*_\n  ; 0# = 0\u2119\n  }\n\n+-*-rawSemiring : RawSemiring 0\u2113 0\u2113\n+-*-rawSemiring = record\n  { Carrier = _\n  ; _\u2248_ = _\u2261_\n  ; _+_ = _+_\n  ; _*_ = _*_\n  ; 0# = 0\u2119\n  ; 1# = 1\u2119\n  }\n\n\n------------------------------------------------------------------------\n-- Homomorphisms between Parity and Sign\n\ntoSign : Parity \u2192 Sign\ntoSign 0\u2119 = +\ntoSign 1\u2119 = -\n\nfromSign : Sign \u2192 Parity\nfromSign + = 0\u2119\nfromSign - = 1\u2119\n</pre>"},{"location":"md/Data/Product/Base/","title":"Data.Product.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Products\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Product.Base where\n\nopen import Function.Base\nopen import Level using (Level; _\u2294_)\n\nprivate\n  variable\n    a b c d e f \u2113 p q r : Level\n    A : Set a\n    B : Set b\n    C : Set c\n    D : Set d\n    E : Set e\n    F : Set f\n\n------------------------------------------------------------------------\n-- Definition of dependent products\n\nopen import Agda.Builtin.Sigma public\n  renaming (fst to proj\u2081; snd to proj\u2082)\n  hiding (module \u03a3)\n\nmodule \u03a3 = Agda.Builtin.Sigma.\u03a3\n  renaming (fst to proj\u2081; snd to proj\u2082)\n\n------------------------------------------------------------------------\n-- Existential quantifiers\n\n\u2203 : \u2200 {A : Set a} \u2192 (A \u2192 Set b) \u2192 Set (a \u2294 b)\n\u2203 = \u03a3 _\n\n\u2203\u2082 : \u2200 {A : Set a} {B : A \u2192 Set b}\n     (C : (x : A) \u2192 B x \u2192 Set c) \u2192 Set (a \u2294 b \u2294 c)\n\u2203\u2082 C = \u2203 \u03bb a \u2192 \u2203 \u03bb b \u2192 C a b\n\n------------------------------------------------------------------------\n-- Syntaxes\n\n-- The syntax declaration below is attached to \u03a3-syntax, to make it\n-- easy to import \u03a3 without the special syntax.\n\ninfix 2 \u03a3-syntax\n\n\u03a3-syntax : (A : Set a) \u2192 (A \u2192 Set b) \u2192 Set (a \u2294 b)\n\u03a3-syntax = \u03a3\n\nsyntax \u03a3-syntax A (\u03bb x \u2192 B) = \u03a3[ x \u2208 A ] B\n\ninfix 2 \u2203-syntax\n\n\u2203-syntax : \u2200 {A : Set a} \u2192 (A \u2192 Set b) \u2192 Set (a \u2294 b)\n\u2203-syntax = \u2203\n\nsyntax \u2203-syntax (\u03bb x \u2192 B) = \u2203[ x ] B\n\n------------------------------------------------------------------------\n-- Definition of non-dependent products\n\ninfixr 4 _,\u2032_\ninfixr 2 _\u00d7_\n\n_\u00d7_ : \u2200 (A : Set a) (B : Set b) \u2192 Set (a \u2294 b)\nA \u00d7 B = \u03a3[ x \u2208 A ] B\n\n_,\u2032_ : A \u2192 B \u2192 A \u00d7 B\n_,\u2032_ = _,_\n\n------------------------------------------------------------------------\n-- Operations over dependent products\n\ninfix  4 -,_\ninfixr 2 _-\u00d7-_ _-,-_\ninfixl 2 _&lt;*&gt;_\n\n-- Sometimes the first component can be inferred.\n\n-,_ : \u2200 {A : Set a} {B : A \u2192 Set b} {x} \u2192 B x \u2192 \u03a3 _ B\n-, y = _ , y\n\n&lt;_,_&gt; : \u2200 {A : Set a} {B : A \u2192 Set b} {C : \u2200 {x} \u2192 B x \u2192 Set c}\n        (f : (x : A) \u2192 B x) \u2192 ((x : A) \u2192 C (f x)) \u2192\n        ((x : A) \u2192 \u03a3 (B x) C)\n&lt; f , g &gt; x = (f x , g x)\n\nmap : \u2200 {P : A \u2192 Set p} {Q : B \u2192 Set q} \u2192\n      (f : A \u2192 B) \u2192 (\u2200 {x} \u2192 P x \u2192 Q (f x)) \u2192\n      \u03a3 A P \u2192 \u03a3 B Q\nmap f g (x , y) = (f x , g y)\n\nmap\u2081 : (A \u2192 B) \u2192 A \u00d7 C \u2192 B \u00d7 C\nmap\u2081 f = map f id\n\nmap\u2082 : \u2200 {A : Set a} {B : A \u2192 Set b} {C : A \u2192 Set c} \u2192\n       (\u2200 {x} \u2192 B x \u2192 C x) \u2192 \u03a3 A B \u2192 \u03a3 A C\nmap\u2082 f = map id f\n\n-- A version of map where the output can depend on the input\ndmap : \u2200 {B : A \u2192 Set b} {P : A \u2192 Set p} {Q : \u2200 {a} \u2192 P a \u2192 B a \u2192 Set q} \u2192\n       (f : (a : A) \u2192 B a) \u2192 (\u2200 {a} (b : P a) \u2192 Q b (f a)) \u2192\n       ((a , b) : \u03a3 A P) \u2192 \u03a3 (B a) (Q b)\ndmap f g (x , y) = f x , g y\n\nzip : \u2200 {P : A \u2192 Set p} {Q : B \u2192 Set q} {R : C \u2192 Set r} \u2192\n      (_\u2219_ : A \u2192 B \u2192 C) \u2192\n      (\u2200 {x y} \u2192 P x \u2192 Q y \u2192 R (x \u2219 y)) \u2192\n      \u03a3 A P \u2192 \u03a3 B Q \u2192 \u03a3 C R\nzip _\u2219_ _\u2218_ (a , p) (b , q) = ((a \u2219 b) , (p \u2218 q))\n\ncurry : \u2200 {A : Set a} {B : A \u2192 Set b} {C : \u03a3 A B \u2192 Set c} \u2192\n        ((p : \u03a3 A B) \u2192 C p) \u2192\n        ((x : A) \u2192 (y : B x) \u2192 C (x , y))\ncurry f x y = f (x , y)\n\nuncurry : \u2200 {A : Set a} {B : A \u2192 Set b} {C : \u03a3 A B \u2192 Set c} \u2192\n          ((x : A) \u2192 (y : B x) \u2192 C (x , y)) \u2192\n          ((p : \u03a3 A B) \u2192 C p)\nuncurry f (x , y) = f x y\n\n-- Rewriting dependent products\nassoc\u02b3 : {B : A \u2192 Set b} {C : (a : A) \u2192 B a \u2192 Set c} \u2192\n          \u03a3 (\u03a3 A B) (uncurry C) \u2192 \u03a3 A (\u03bb a \u2192 \u03a3 (B a) (C a))\nassoc\u02b3 ((a , b) , c) = (a , (b , c))\n\nassoc\u02e1 : {B : A \u2192 Set b} {C : (a : A) \u2192 B a \u2192 Set c} \u2192\n          \u03a3 A (\u03bb a \u2192 \u03a3 (B a) (C a)) \u2192 \u03a3 (\u03a3 A B) (uncurry C)\nassoc\u02e1 (a , (b , c)) = ((a , b) , c)\n\n-- Alternate form of associativity for dependent products\n-- where the C parameter is uncurried.\nassoc\u02b3-curried : {B : A \u2192 Set b} {C : \u03a3 A B \u2192 Set c} \u2192\n                 \u03a3 (\u03a3 A B) C \u2192 \u03a3 A (\u03bb a \u2192 \u03a3 (B a) (curry C a))\nassoc\u02b3-curried ((a , b) , c) = (a , (b , c))\n\nassoc\u02e1-curried : {B : A \u2192 Set b} {C : \u03a3 A B \u2192 Set c} \u2192\n          \u03a3 A (\u03bb a \u2192 \u03a3 (B a) (curry C a)) \u2192 \u03a3 (\u03a3 A B) C\nassoc\u02e1-curried (a , (b , c)) = ((a , b) , c)\n\n------------------------------------------------------------------------\n-- Operations for non-dependent products\n\n-- Any of the above operations for dependent products will also work for\n-- non-dependent products but sometimes Agda has difficulty inferring\n-- the non-dependency. Primed (\u2032 = \\prime) versions of the operations\n-- are therefore provided below that sometimes have better inference\n-- properties.\n\nzip\u2032 : (A \u2192 B \u2192 C) \u2192 (D \u2192 E \u2192 F) \u2192 A \u00d7 D \u2192 B \u00d7 E \u2192 C \u00d7 F\nzip\u2032 f g = zip f g\n\ncurry\u2032 : (A \u00d7 B \u2192 C) \u2192 (A \u2192 B \u2192 C)\ncurry\u2032 = curry\n\nuncurry\u2032 : (A \u2192 B \u2192 C) \u2192 (A \u00d7 B \u2192 C)\nuncurry\u2032 = uncurry\n\nmap\u2082\u2032 : (B \u2192 C) \u2192 A \u00d7 B \u2192 A \u00d7 C\nmap\u2082\u2032 f = map\u2082 f\n\ndmap\u2032 : \u2200 {x y} {X : A \u2192 Set x} {Y : B \u2192 Set y} \u2192\n        ((a : A) \u2192 X a) \u2192 ((b : B) \u2192 Y b) \u2192\n        ((a , b) : A \u00d7 B) \u2192 X a \u00d7 Y b\ndmap\u2032 f g = dmap f g\n\n_&lt;*&gt;_ : \u2200 {x y} {X : A \u2192 Set x} {Y : B \u2192 Set y} \u2192\n        ((a : A) \u2192 X a) \u00d7 ((b : B) \u2192 Y b) \u2192\n        ((a , b) : A \u00d7 B) \u2192 X a \u00d7 Y b\n_&lt;*&gt;_ = uncurry dmap\u2032\n\n-- Operations that can only be defined for non-dependent products\n\nswap : A \u00d7 B \u2192 B \u00d7 A\nswap (x , y) = (y , x)\n\n_-\u00d7-_ : (A \u2192 B \u2192 Set p) \u2192 (A \u2192 B \u2192 Set q) \u2192 (A \u2192 B \u2192 Set _)\nf -\u00d7- g = f -\u27ea _\u00d7_ \u27eb- g\n\n_-,-_ : (A \u2192 B \u2192 C) \u2192 (A \u2192 B \u2192 D) \u2192 (A \u2192 B \u2192 C \u00d7 D)\nf -,- g = f -\u27ea _,_ \u27eb- g\n\n-- Rewriting non-dependent products\nassoc\u02b3\u2032 : (A \u00d7 B) \u00d7 C \u2192 A \u00d7 (B \u00d7 C)\nassoc\u02b3\u2032 ((a , b) , c) = (a , (b , c))\n\nassoc\u02e1\u2032 : A \u00d7 (B \u00d7 C) \u2192 (A \u00d7 B) \u00d7 C\nassoc\u02e1\u2032 (a , (b , c)) = ((a , b) , c)\n</pre>"},{"location":"md/Data/Sign/Base/","title":"Data.Sign.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Signs\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Sign.Base where\n\nopen import Algebra.Bundles.Raw using (RawMagma; RawMonoid; RawGroup)\nopen import Level using (0\u2113)\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_)\n\n------------------------------------------------------------------------\n-- Definition\n\ndata Sign : Set where\n  - : Sign\n  + : Sign\n\n------------------------------------------------------------------------\n-- Operations\n\n-- The opposite sign.\n\nopposite : Sign \u2192 Sign\nopposite - = +\nopposite + = -\n\n-- \"Multiplication\".\n\ninfixl 7 _*_\n\n_*_ : Sign \u2192 Sign \u2192 Sign\n+ * s\u2082 = s\u2082\n- * s\u2082 = opposite s\u2082\n\n------------------------------------------------------------------------\n-- Raw Bundles\n\n*-rawMagma : RawMagma 0\u2113 0\u2113\n*-rawMagma = record\n  { _\u2248_ = _\u2261_\n  ; _\u2219_ = _*_\n  }\n\n*-1-rawMonoid : RawMonoid 0\u2113 0\u2113\n*-1-rawMonoid = record\n  { _\u2248_ = _\u2261_\n  ; _\u2219_ = _*_\n  ; \u03b5 = +\n  }\n\n*-1-rawGroup : RawGroup 0\u2113 0\u2113\n*-1-rawGroup = record\n  { _\u2248_ = _\u2261_\n  ; _\u2219_ = _*_\n  ; _\u207b\u00b9 = opposite\n  ; \u03b5 = +\n  }\n\n</pre>"},{"location":"md/Data/String/Base/","title":"Data.String.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Strings: builtin type and basic operations\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.String.Base where\n\nopen import Data.Bool.Base using (Bool; true; false; if_then_else_)\nopen import Data.Char.Base as Char using (Char)\nopen import Data.List.Base as List using (List; [_]; _\u2237_; [])\nopen import Data.List.NonEmpty.Base as NE using (List\u207a)\nopen import Data.List.Relation.Binary.Pointwise.Base using (Pointwise)\nopen import Data.List.Relation.Binary.Lex.Core using (Lex-&lt;; Lex-\u2264)\nopen import Data.Maybe.Base as Maybe using (Maybe)\nopen import Data.Nat.Base using (\u2115; _\u2238_; \u230a_/2\u230b; \u2308_/2\u2309; _\u2261\u1d47_)\nopen import Data.Product.Base using (proj\u2081; proj\u2082)\nopen import Function.Base using (_on_; _\u2218\u2032_; _\u2218_)\nopen import Level using (Level; 0\u2113)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_; refl)\nopen import Relation.Unary using (Pred; Decidable)\nopen import Relation.Nullary.Decidable.Core using (does; T?)\n\n------------------------------------------------------------------------\n-- From Agda.Builtin: type and renamed primitives\n\n-- Note that we do not re-export primStringAppend because we want to\n-- give it an infix definition and be able to assign it a level.\n\nimport Agda.Builtin.String as String\n\nopen String public using ( String )\n  renaming\n  ( primStringUncons   to uncons\n  ; primStringToList   to toList\n  ; primStringFromList to fromList\n  ; primShowString     to show\n  )\n\n------------------------------------------------------------------------\n-- Relations\n\n-- Pointwise equality on Strings\n\ninfix 4 _\u2248_\n_\u2248_ : Rel String 0\u2113\n_\u2248_ = Pointwise _\u2261_ on toList\n\n-- Lexicographic ordering on Strings\n\ninfix 4 _&lt;_\n_&lt;_ : Rel String 0\u2113\n_&lt;_ = Lex-&lt; _\u2261_ Char._&lt;_ on toList\n\ninfix 4 _\u2264_\n_\u2264_ : Rel String 0\u2113\n_\u2264_ = Lex-\u2264 _\u2261_ Char._&lt;_ on toList\n\n------------------------------------------------------------------------\n-- Operations\n\n-- List-like operations\n\nhead : String \u2192 Maybe Char\nhead = Maybe.map proj\u2081 \u2218\u2032 uncons\n\ntail : String \u2192 Maybe String\ntail = Maybe.map proj\u2082 \u2218\u2032 uncons\n\n-- Additional conversion functions\n\nfromChar : Char \u2192 String\nfromChar = fromList \u2218\u2032 [_]\n\nfromList\u207a : List\u207a Char \u2192 String\nfromList\u207a = fromList \u2218\u2032 NE.toList\n\n-- List-like functions\n\ninfixr 5 _++_\n_++_ : String \u2192 String \u2192 String\n_++_ = String.primStringAppend\n\nlength : String \u2192 \u2115\nlength = List.length \u2218 toList\n\nreplicate : \u2115 \u2192 Char \u2192 String\nreplicate n = fromList \u2218 List.replicate n\n\nconcat : List String \u2192 String\nconcat = List.foldr _++_ \"\"\n\nintersperse : String \u2192 List String \u2192 String\nintersperse sep = concat \u2218\u2032 (List.intersperse sep)\n\nunwords : List String \u2192 String\nunwords = intersperse \" \"\n\nunlines : List String \u2192 String\nunlines = intersperse \"\\n\"\n\nbetween : String \u2192 String \u2192 String \u2192 String\nbetween left right middle = left ++ middle ++ right\n\nparens : String \u2192 String\nparens = between \"(\" \")\"\n\nbraces : String \u2192 String\nbraces = between \"{\" \"}\"\n\n-- append that also introduces spaces, if necessary\ninfixr 5 _&lt;+&gt;_\n_&lt;+&gt;_ : String \u2192 String \u2192 String\n\"\" &lt;+&gt; b = b\na &lt;+&gt; \"\" = a\na &lt;+&gt; b = a ++ \" \" ++ b\n\n------------------------------------------------------------------------\n-- Padding\n\n-- Each one of the padding functions should verify the following\n-- invariant:\n--   If length str \u2264 n then length (padLeft c n str) \u2261 n\n--   and otherwise padLeft c n str \u2261 str.\n\n-- Appending an empty string is expensive (append for Haskell's\n-- Text creates a fresh Text value in which both contents are\n-- copied) so we precompute `n \u2238 length str` and check whether\n-- it is equal to 0.\n\npadLeft : Char \u2192 \u2115 \u2192 String \u2192 String\npadLeft c n str =\n  let l = n \u2238 length str in\n  if l \u2261\u1d47 0 then str else replicate l c ++ str\n\npadRight : Char \u2192 \u2115 \u2192 String \u2192 String\npadRight c n str =\n  let l = n \u2238 length str in\n  if l \u2261\u1d47 0 then str else str ++ replicate l c\n\npadBoth : Char \u2192 Char \u2192 \u2115 \u2192 String \u2192 String\npadBoth c\u2097 c\u1d63 n str =\n  let l = n \u2238 length str in\n  if l \u2261\u1d47 0 then str else replicate \u230a l /2\u230b c\u2097 ++ str ++ replicate \u2308 l /2\u2309 c\u1d63\n\n------------------------------------------------------------------------\n-- Alignment\n\n-- We can align a String left, center or right in a column of a given\n-- width by padding it with whitespace.\n\ndata Alignment : Set where\n  Left Center Right : Alignment\n\nfromAlignment : Alignment \u2192 \u2115 \u2192 String \u2192 String\nfromAlignment Left   = padRight ' '\nfromAlignment Center = padBoth ' ' ' '\nfromAlignment Right  = padLeft ' '\n\n------------------------------------------------------------------------\n-- Splitting strings\n\nwordsBy : \u2200 {p} {P : Pred Char p} \u2192 Decidable P \u2192 String \u2192 List String\nwordsBy P? = List.map fromList \u2218 List.wordsBy P? \u2218 toList\n\nwordsBy\u1d47 : (Char \u2192 Bool) \u2192 String \u2192 List String\nwordsBy\u1d47 p = wordsBy (T? \u2218 p)\n\nwords : String \u2192 List String\nwords = wordsBy\u1d47 Char.isSpace\n\n-- `words` ignores contiguous whitespace\n_ : words \" abc  b   \" \u2261 \"abc\" \u2237 \"b\" \u2237 []\n_ = refl\n\nlinesBy : \u2200 {p} {P : Pred Char p} \u2192 Decidable P \u2192 String \u2192 List String\nlinesBy P? = List.map fromList \u2218 List.linesBy P? \u2218 toList\n\nlinesBy\u1d47 : (Char \u2192 Bool) \u2192 String \u2192 List String\nlinesBy\u1d47 p = linesBy (T? \u2218 p)\n\nlines : String \u2192 List String\nlines = linesBy\u1d47 ('\\n' Char.\u2248\u1d47_)\n\n-- `lines` preserves empty lines\n_ : lines \"\\nabc\\n\\nb\\n\\n\\n\" \u2261 \"\" \u2237 \"abc\" \u2237 \"\" \u2237 \"b\" \u2237 \"\" \u2237 \"\" \u2237 []\n_ = refl\n\nmap : (Char \u2192 Char) \u2192 String \u2192 String\nmap f = fromList \u2218 List.map f \u2218 toList\n\n_ : map Char.toUpper \"abc\" \u2261 \"ABC\"\n_ = refl\n</pre>"},{"location":"md/Data/Sum/Base/","title":"Data.Sum.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Sums (disjoint unions)\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Sum.Base where\n\nopen import Data.Bool.Base using (true; false)\nopen import Function.Base using (_\u2218_; _\u2218\u2032_; _-\u27ea_\u27eb-_ ; id)\nopen import Level using (Level; _\u2294_)\n\nprivate\n  variable\n    a b c d : Level\n    A : Set a\n    B : Set b\n    C : Set c\n    D : Set d\n\n------------------------------------------------------------------------\n-- Definition\n\ninfixr 1 _\u228e_\n\ndata _\u228e_ (A : Set a) (B : Set b) : Set (a \u2294 b) where\n  inj\u2081 : (x : A) \u2192 A \u228e B\n  inj\u2082 : (y : B) \u2192 A \u228e B\n\n------------------------------------------------------------------------\n-- Functions\n\n[_,_] : \u2200 {C : A \u228e B \u2192 Set c} \u2192\n        ((x : A) \u2192 C (inj\u2081 x)) \u2192 ((x : B) \u2192 C (inj\u2082 x)) \u2192\n        ((x : A \u228e B) \u2192 C x)\n[ f , g ] (inj\u2081 x) = f x\n[ f , g ] (inj\u2082 y) = g y\n\n[_,_]\u2032 : (A \u2192 C) \u2192 (B \u2192 C) \u2192 (A \u228e B \u2192 C)\n[_,_]\u2032 = [_,_]\n\nfromInj\u2081 : (B \u2192 A) \u2192 A \u228e B \u2192 A\nfromInj\u2081 = [ id ,_]\u2032\n\nfromInj\u2082 : (A \u2192 B) \u2192 A \u228e B \u2192 B\nfromInj\u2082 = [_, id ]\u2032\n\nreduce : A \u228e A \u2192 A\nreduce = [ id , id ]\u2032\n\nswap : A \u228e B \u2192 B \u228e A\nswap (inj\u2081 x) = inj\u2082 x\nswap (inj\u2082 x) = inj\u2081 x\n\nmap : (A \u2192 C) \u2192 (B \u2192 D) \u2192 (A \u228e B \u2192 C \u228e D)\nmap f g = [ inj\u2081 \u2218 f , inj\u2082 \u2218 g ]\u2032\n\nmap\u2081 : (A \u2192 C) \u2192 (A \u228e B \u2192 C \u228e B)\nmap\u2081 f = map f id\n\nmap\u2082 : (B \u2192 D) \u2192 (A \u228e B \u2192 A \u228e D)\nmap\u2082 = map id\n\nassoc\u02b3 : (A \u228e B) \u228e C \u2192 A \u228e B \u228e C\nassoc\u02b3 = [ map\u2082 inj\u2081 , inj\u2082 \u2218\u2032 inj\u2082 ]\u2032\n\nassoc\u02e1 : A \u228e B \u228e C \u2192 (A \u228e B) \u228e C\nassoc\u02e1 = [ inj\u2081 \u2218\u2032 inj\u2081 , map\u2081 inj\u2082 ]\u2032\n\ninfixr 1 _-\u228e-_\n_-\u228e-_ : (A \u2192 B \u2192 Set c) \u2192 (A \u2192 B \u2192 Set d) \u2192 (A \u2192 B \u2192 Set (c \u2294 d))\nf -\u228e- g = f -\u27ea _\u228e_ \u27eb- g\n</pre>"},{"location":"md/Data/These/Base/","title":"Data.These.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- An either-or-both data type, basic type and operations\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.These.Base where\n\nopen import Level\nopen import Data.Sum.Base using (_\u228e_; [_,_]\u2032)\nopen import Function.Base\n\nprivate\n  variable\n    a b c d e f : Level\n    A : Set a\n    B : Set b\n    C : Set c\n    D : Set d\n    E : Set e\n    F : Set f\n\ndata These {a b} (A : Set a) (B : Set b) : Set (a \u2294 b) where\n  this  : A     \u2192 These A B\n  that  :     B \u2192 These A B\n  these : A \u2192 B \u2192 These A B\n\n------------------------------------------------------------------------\n-- Operations\n\n-- injection\n\nfromSum : A \u228e B \u2192 These A B\nfromSum = [ this , that ]\u2032\n\n-- map\n\nmap : (f : A \u2192 B) (g : C \u2192 D) \u2192 These A C \u2192 These B D\nmap f g (this a)    = this (f a)\nmap f g (that b)    = that (g b)\nmap f g (these a b) = these (f a) (g b)\n\nmap\u2081 : (f : A \u2192 B) \u2192 These A C \u2192 These B C\nmap\u2081 f = map f id\n\nmap\u2082 : (g : B \u2192 C) \u2192 These A B \u2192 These A C\nmap\u2082 = map id\n\n-- fold\n\nfold : (A \u2192 C) \u2192 (B \u2192 C) \u2192 (A \u2192 B \u2192 C) \u2192 These A B \u2192 C\nfold l r lr (this a)    = l a\nfold l r lr (that b)    = r b\nfold l r lr (these a b) = lr a b\n\nfoldWithDefaults : A \u2192 B \u2192 (A \u2192 B \u2192 C) \u2192 These A B \u2192 C\nfoldWithDefaults a b lr = fold (flip lr b) (lr a) lr\n\n-- swap\n\nswap : These A B \u2192 These B A\nswap = fold that this (flip these)\n\n-- align\n\nalignWith : (These A C \u2192 E) \u2192 (These B D \u2192 F) \u2192 These A B \u2192 These C D \u2192 These E F\nalignWith f g (this a)    (this c)    = this (f (these a c))\nalignWith f g (this a)    (that d)    = these (f (this a)) (g (that d))\nalignWith f g (this a)    (these c d) = these (f (these a c)) (g (that d))\nalignWith f g (that b)    (this c)    = these (f (that c)) (g (this b))\nalignWith f g (that b)    (that d)    = that (g (these b d))\nalignWith f g (that b)    (these c d) = these (f (that c)) (g (these b d))\nalignWith f g (these a b) (this c)    = these (f (these a c)) (g (this b))\nalignWith f g (these a b) (that d)    = these (f (this a)) (g (these b d))\nalignWith f g (these a b) (these c d) = these (f (these a c)) (g (these b d))\n\nalign : These A B \u2192 These C D \u2192 These (These A C) (These B D)\nalign = alignWith id id\n</pre>"},{"location":"md/Data/Unit/Base/","title":"Data.Unit.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- The unit type and the total relation on unit\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Unit.Base where\n\n------------------------------------------------------------------------\n-- A unit type defined as a record type\n\n-- Note that by default the unit type is not universe polymorphic as it\n-- often results in unsolved metas. See `Data.Unit.Polymorphic` for a\n-- universe polymorphic variant.\n\n-- Note also that the name of this type is \"\\top\", not T.\n\nopen import Agda.Builtin.Unit public\n  using (\u22a4; tt)\n</pre>"},{"location":"md/Data/Unit/Polymorphic/Base/","title":"Data.Unit.Polymorphic.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- A universe polymorphic unit type, as a Lift of the Level 0 one.\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Unit.Polymorphic.Base where\n\nopen import Level\nimport Data.Unit.Base as \u22a4\n\n------------------------------------------------------------------------\n-- A unit type defined as a synonym\n\n\u22a4 : {\u2113 : Level} \u2192 Set \u2113\n\u22a4 {\u2113} = Lift \u2113 \u22a4.\u22a4\n\ntt : {\u2113 : Level} \u2192 \u22a4 {\u2113}\ntt = lift \u22a4.tt\n</pre>"},{"location":"md/Data/Vec/Base/","title":"Data.Vec.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Vectors, basic types and operations\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Data.Vec.Base where\n\nopen import Data.Bool.Base using (Bool; true; false; if_then_else_)\nopen import Data.Nat.Base\nopen import Data.Fin.Base using (Fin; zero; suc)\nopen import Data.List.Base as List using (List)\nopen import Data.Product.Base as Product using (\u2203; \u2203\u2082; _\u00d7_; _,_; proj\u2081; proj\u2082)\nopen import Data.These.Base as These using (These; this; that; these)\nopen import Function.Base using (const; _\u2218\u2032_; id; _\u2218_; _$_)\nopen import Level using (Level)\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_; refl; trans; cong)\nopen import Relation.Nullary.Decidable.Core using (does; T?)\nopen import Relation.Unary using (Pred; Decidable)\n\nprivate\n  variable\n    a b c p : Level\n    A : Set a\n    B : Set b\n    C : Set c\n    m n : \u2115\n\n------------------------------------------------------------------------\n-- Types\n\ninfixr 5 _\u2237_\n\ndata Vec (A : Set a) : \u2115 \u2192 Set a where\n  []  : Vec A zero\n  _\u2237_ : \u2200 (x : A) (xs : Vec A n) \u2192 Vec A (suc n)\n\ninfix 4 _[_]=_\n\ndata _[_]=_ {A : Set a} : Vec A n \u2192 Fin n \u2192 A \u2192 Set a where\n  here  : \u2200     {x}   {xs : Vec A n} \u2192 x \u2237 xs [ zero ]= x\n  there : \u2200 {i} {x y} {xs : Vec A n}\n    (xs[i]=x : xs [ i ]= x) \u2192 y \u2237 xs [ suc i ]= x\n\n------------------------------------------------------------------------\n-- Basic operations\n\nlength : Vec A n \u2192 \u2115\nlength {n = n} _ = n\n\nhead : Vec A (1 + n) \u2192 A\nhead (x \u2237 xs) = x\n\ntail : Vec A (1 + n) \u2192 Vec A n\ntail (x \u2237 xs) = xs\n\nlookup : Vec A n \u2192 Fin n \u2192 A\nlookup (x \u2237 xs) zero    = x\nlookup (x \u2237 xs) (suc i) = lookup xs i\n\niterate : (A \u2192 A) \u2192 A \u2192 \u2200 n \u2192 Vec A n\niterate s z zero    = []\niterate s z (suc n) = z \u2237 iterate s (s z) n\n\ninsertAt : Vec A n \u2192 Fin (suc n) \u2192 A \u2192 Vec A (suc n)\ninsertAt xs       zero     v = v \u2237 xs\ninsertAt (x \u2237 xs) (suc i)  v = x \u2237 insertAt xs i v\n\nremoveAt : Vec A (suc n) \u2192 Fin (suc n) \u2192 Vec A n\nremoveAt (x \u2237 xs)         zero    = xs\nremoveAt (x \u2237 xs@(_ \u2237 _)) (suc i) = x \u2237 removeAt xs i\n\nupdateAt : Vec A n \u2192 Fin n \u2192 (A \u2192 A) \u2192 Vec A n\nupdateAt (x \u2237 xs) zero    f = f x \u2237 xs\nupdateAt (x \u2237 xs) (suc i) f = x   \u2237 updateAt xs i f\n\n-- xs [ i ]%= f  modifies the i-th element of xs according to f\n\ninfixl 6 _[_]%=_ _[_]\u2254_\n\n_[_]%=_ : Vec A n \u2192 Fin n \u2192 (A \u2192 A) \u2192 Vec A n\nxs [ i ]%= f = updateAt xs i f\n\n-- xs [ i ]\u2254 y  overwrites the i-th element of xs with y\n\n_[_]\u2254_ : Vec A n \u2192 Fin n \u2192 A \u2192 Vec A n\nxs [ i ]\u2254 y = xs [ i ]%= const y\n\n------------------------------------------------------------------------\n-- Operations for transforming vectors\n\n-- See README.Data.Vec.Relation.Binary.Equality.Cast for the reasoning\n-- system of `cast`-ed equality.\ncast : .(eq : m \u2261 n) \u2192 Vec A m \u2192 Vec A n\ncast {n = zero}  eq []       = []\ncast {n = suc _} eq (x \u2237 xs) = x \u2237 cast (cong pred eq) xs\n\nmap : (A \u2192 B) \u2192 Vec A n \u2192 Vec B n\nmap f []       = []\nmap f (x \u2237 xs) = f x \u2237 map f xs\n\n-- Concatenation.\n\ninfixr 5 _++_\n\n_++_ : Vec A m \u2192 Vec A n \u2192 Vec A (m + n)\n[]       ++ ys = ys\n(x \u2237 xs) ++ ys = x \u2237 (xs ++ ys)\n\nconcat : Vec (Vec A m) n \u2192 Vec A (n * m)\nconcat []         = []\nconcat (xs \u2237 xss) = xs ++ concat xss\n\n-- Align, Restrict, and Zip.\n\nalignWith : (These A B \u2192 C) \u2192 Vec A m \u2192 Vec B n \u2192 Vec C (m \u2294 n)\nalignWith f []         bs       = map (f \u2218\u2032 that) bs\nalignWith f as@(_ \u2237 _) []       = map (f \u2218\u2032 this) as\nalignWith f (a \u2237 as)   (b \u2237 bs) = f (these a b) \u2237 alignWith f as bs\n\nrestrictWith : (A \u2192 B \u2192 C) \u2192 Vec A m \u2192 Vec B n \u2192 Vec C (m \u2293 n)\nrestrictWith f []       bs       = []\nrestrictWith f (_ \u2237 _)  []       = []\nrestrictWith f (a \u2237 as) (b \u2237 bs) = f a b \u2237 restrictWith f as bs\n\nzipWith : (A \u2192 B \u2192 C) \u2192 Vec A n \u2192 Vec B n \u2192 Vec C n\nzipWith f []       []       = []\nzipWith f (x \u2237 xs) (y \u2237 ys) = f x y \u2237 zipWith f xs ys\n\nunzipWith : (A \u2192 B \u00d7 C) \u2192 Vec A n \u2192 Vec B n \u00d7 Vec C n\nunzipWith f []       = [] , []\nunzipWith f (a \u2237 as) = Product.zip _\u2237_ _\u2237_ (f a) (unzipWith f as)\n\nalign : Vec A m \u2192 Vec B n \u2192 Vec (These A B) (m \u2294 n)\nalign = alignWith id\n\nrestrict : Vec A m \u2192 Vec B n \u2192 Vec (A \u00d7 B) (m \u2293 n)\nrestrict = restrictWith _,_\n\nzip : Vec A n \u2192 Vec B n \u2192 Vec (A \u00d7 B) n\nzip = zipWith _,_\n\nunzip : Vec (A \u00d7 B) n \u2192 Vec A n \u00d7 Vec B n\nunzip = unzipWith id\n\n-- Interleaving.\n\ninfixr 5 _\u22ce_\n\n_\u22ce_ : Vec A m \u2192 Vec A n \u2192 Vec A (m +\u22ce n)\n[]       \u22ce ys = ys\n(x \u2237 xs) \u22ce ys = x \u2237 (ys \u22ce xs)\n\n-- Pointwise application\n\ninfixl 4 _\u229b_\n\n_\u229b_ : Vec (A \u2192 B) n \u2192 Vec A n \u2192 Vec B n\n[]       \u229b []       = []\n(f \u2237 fs) \u229b (x \u2237 xs) = f x \u2237 (fs \u229b xs)\n\n-- Multiplication\n\nmodule CartesianBind where\n  infixl 1 _&gt;&gt;=_\n\n  _&gt;&gt;=_ : Vec A m \u2192 (A \u2192 Vec B n) \u2192 Vec B (m * n)\n  xs &gt;&gt;= f = concat (map f xs)\n\ninfixl 4 _\u229b*_\n\n_\u229b*_ : Vec (A \u2192 B) m \u2192 Vec A n \u2192 Vec B (m * n)\nfs \u229b* xs = fs CartesianBind.&gt;&gt;= \u03bb f \u2192 map f xs\n\nallPairs : Vec A m \u2192 Vec B n \u2192 Vec (A \u00d7 B) (m * n)\nallPairs xs ys = map _,_ xs \u229b* ys\n\n-- Diagonal\n\ndiagonal : Vec (Vec A n) n \u2192 Vec A n\ndiagonal [] = []\ndiagonal (xs \u2237 xss) = head xs \u2237 diagonal (map tail xss)\n\nmodule DiagonalBind where\n  infixl 1 _&gt;&gt;=_\n\n  _&gt;&gt;=_ : Vec A n \u2192 (A \u2192 Vec B n) \u2192 Vec B n\n  xs &gt;&gt;= f = diagonal (map f xs)\n\n\n------------------------------------------------------------------------\n-- Operations for reducing vectors\n\n-- Dependent folds\n\nmodule _ (A : Set a) (B : \u2115 \u2192 Set b) where\n\n  FoldrOp = \u2200 {n} \u2192 A \u2192 B n \u2192 B (suc n)\n  FoldlOp = \u2200 {n} \u2192 B n \u2192 A \u2192 B (suc n)\n\nfoldr : \u2200 (B : \u2115 \u2192 Set b) \u2192 FoldrOp A B \u2192 B zero \u2192 Vec A n \u2192 B n\nfoldr B _\u2295_ e []       = e\nfoldr B _\u2295_ e (x \u2237 xs) = x \u2295 foldr B _\u2295_ e xs\n\nfoldl : \u2200 (B : \u2115 \u2192 Set b) \u2192 FoldlOp A B \u2192 B zero \u2192 Vec A n \u2192 B n\nfoldl B _\u2295_ e []       = e\nfoldl B _\u2295_ e (x \u2237 xs) = foldl (B \u2218 suc) _\u2295_ (e \u2295 x) xs\n\n-- Non-dependent folds\n\nfoldr\u2032 : (A \u2192 B \u2192 B) \u2192 B \u2192 Vec A n \u2192 B\nfoldr\u2032 _\u2295_ = foldr _ _\u2295_\n\nfoldl\u2032 : (B \u2192 A \u2192 B) \u2192 B \u2192 Vec A n \u2192 B\nfoldl\u2032 _\u2295_ = foldl _ _\u2295_\n\n-- Non-empty folds\n\nfoldr\u2081 : (A \u2192 A \u2192 A) \u2192 Vec A (suc n) \u2192 A\nfoldr\u2081 _\u2295_ (x \u2237 [])     = x\nfoldr\u2081 _\u2295_ (x \u2237 y \u2237 ys) = x \u2295 foldr\u2081 _\u2295_ (y \u2237 ys)\n\nfoldl\u2081 : (A \u2192 A \u2192 A) \u2192 Vec A (suc n) \u2192 A\nfoldl\u2081 _\u2295_ (x \u2237 xs) = foldl _ _\u2295_ x xs\n\n-- Special folds\n\nsum : Vec \u2115 n \u2192 \u2115\nsum = foldr _ _+_ 0\n\ncount : \u2200 {P : Pred A p} \u2192 Decidable P \u2192 Vec A n \u2192 \u2115\ncount P? []       = zero\ncount P? (x \u2237 xs) = if does (P? x) then suc else id $ count P? xs\n\ncount\u1d47 : (A \u2192 Bool) \u2192 Vec A n \u2192 \u2115\ncount\u1d47 p = count (T? \u2218 p)\n\n------------------------------------------------------------------------\n-- Operations for building vectors\n\n[_] : A \u2192 Vec A 1\n[ x ] = x \u2237 []\n\nreplicate : (n : \u2115) \u2192 A \u2192 Vec A n\nreplicate zero    x = []\nreplicate (suc n) x = x \u2237 replicate n x\n\ntabulate : (Fin n \u2192 A) \u2192 Vec A n\ntabulate {n = zero}  f = []\ntabulate {n = suc n} f = f zero \u2237 tabulate (f \u2218 suc)\n\nallFin : \u2200 n \u2192 Vec (Fin n) n\nallFin _ = tabulate id\n\n------------------------------------------------------------------------\n-- Operations for dividing vectors\n\nsplitAt : \u2200 m {n} (xs : Vec A (m + n)) \u2192\n          \u2203\u2082 \u03bb (ys : Vec A m) (zs : Vec A n) \u2192 xs \u2261 ys ++ zs\nsplitAt zero    xs                = [] , xs , refl\nsplitAt (suc m) (x \u2237 xs) =\n  let ys , zs , eq = splitAt m xs in x \u2237 ys , zs , cong (x \u2237_) eq\n\ntake : \u2200 m {n} \u2192 Vec A (m + n) \u2192 Vec A m\ntake m xs = proj\u2081 (splitAt m xs)\n\ndrop : \u2200 m {n} \u2192 Vec A (m + n) \u2192 Vec A n\ndrop m xs = proj\u2081 (proj\u2082 (splitAt m xs))\n\ngroup : \u2200 n k (xs : Vec A (n * k)) \u2192\n        \u2203 \u03bb (xss : Vec (Vec A k) n) \u2192 xs \u2261 concat xss\ngroup zero    k []                  = ([] , refl)\ngroup (suc n) k xs  =\n  let ys , zs , eq-split = splitAt k xs in\n  let zss , eq-group     = group n k zs in\n   (ys \u2237 zss) , trans eq-split (cong (ys ++_) eq-group)\n\nsplit : Vec A n \u2192 Vec A \u2308 n /2\u2309 \u00d7 Vec A \u230a n /2\u230b\nsplit []           = ([]     , [])\nsplit (x \u2237 [])     = (x \u2237 [] , [])\nsplit (x \u2237 y \u2237 xs) = Product.map (x \u2237_) (y \u2237_) (split xs)\n\nuncons : Vec A (suc n) \u2192 A \u00d7 Vec A n\nuncons (x \u2237 xs) = x , xs\n\n------------------------------------------------------------------------\n-- Operations involving \u2264\n\n-- Take the first 'm' elements of a vector.\ntruncate : \u2200 {m n} \u2192 m \u2264 n \u2192 Vec A n \u2192 Vec A m\ntruncate {m = zero} _ _    = []\ntruncate (s\u2264s le) (x \u2237 xs) = x \u2237 (truncate le xs)\n\n-- Pad out a vector with extra elements.\npadRight : \u2200 {m n} \u2192 m \u2264 n \u2192 A \u2192 Vec A m \u2192 Vec A n\npadRight z\u2264n      a xs       = replicate _ a\npadRight (s\u2264s le) a (x \u2237 xs) = x \u2237 padRight le a xs\n\n------------------------------------------------------------------------\n-- Operations for converting between lists\n\ntoList : Vec A n \u2192 List A\ntoList []       = List.[]\ntoList (x \u2237 xs) = List._\u2237_ x (toList xs)\n\nfromList : (xs : List A) \u2192 Vec A (List.length xs)\nfromList List.[]         = []\nfromList (List._\u2237_ x xs) = x \u2237 fromList xs\n\n------------------------------------------------------------------------\n-- Operations for reversing vectors\n\n-- snoc\n\ninfixl 5 _\u2237\u02b3_\n\n_\u2237\u02b3_ : Vec A n \u2192 A \u2192 Vec A (suc n)\n[]       \u2237\u02b3 y = [ y ]\n(x \u2237 xs) \u2237\u02b3 y = x \u2237 (xs \u2237\u02b3 y)\n\n-- vanilla reverse\n\nreverse : Vec A n \u2192 Vec A n\nreverse = foldl (Vec _) (\u03bb rev x \u2192 x \u2237 rev) []\n\n-- reverse-append\n\ninfix 5 _\u02b3++_\n\n_\u02b3++_ : Vec A m \u2192 Vec A n \u2192 Vec A (m + n)\nxs \u02b3++ ys = foldl (Vec _ \u2218 (_+ _)) (\u03bb rev x \u2192 x \u2237 rev) ys xs\n\n-- init and last\n\ninitLast : \u2200 (xs : Vec A (1 + n)) \u2192 \u2203\u2082 \u03bb ys y \u2192 xs \u2261 ys \u2237\u02b3 y\ninitLast {n = zero}  (x \u2237 []) = [] , x , refl\ninitLast {n = suc n} (x \u2237 xs) =\n  let ys , y , eq = initLast xs in\n  x \u2237 ys , y , cong (x \u2237_) eq\n\ninit : Vec A (1 + n) \u2192 Vec A n\ninit xs = proj\u2081 (initLast xs)\n\nlast : Vec A (1 + n) \u2192 A\nlast xs = proj\u2081 (proj\u2082 (initLast xs))\n\n------------------------------------------------------------------------\n-- Other operations\n\ntranspose : Vec (Vec A n) m \u2192 Vec (Vec A m) n\ntranspose {n = n} []          = replicate n []\ntranspose {n = n} (as \u2237 ass) = ((replicate n _\u2237_) \u229b as) \u229b transpose ass\n\n------------------------------------------------------------------------\n-- DEPRECATED\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 2.0\n\nremove = removeAt\n{-# WARNING_ON_USAGE remove\n\"Warning: remove was deprecated in v2.0.\nPlease use removeAt instead.\"\n#-}\ninsert = insertAt\n{-# WARNING_ON_USAGE insert\n\"Warning: insert was deprecated in v2.0.\nPlease use insertAt instead.\"\n#-}\n</pre>"},{"location":"md/Effect/Applicative/","title":"Effect.Applicative","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Applicative functors\n------------------------------------------------------------------------\n\n-- Note that currently the applicative functor laws are not included\n-- here.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Effect.Applicative where\n\nopen import Data.Bool.Base using (Bool; true; false)\nopen import Data.Product.Base using (_\u00d7_; _,_)\nopen import Data.Unit.Polymorphic.Base using (\u22a4)\n\nopen import Effect.Choice using (RawChoice)\nopen import Effect.Empty using (RawEmpty)\nopen import Effect.Functor as Fun using (RawFunctor)\n\nopen import Function.Base using (const; flip; _\u2218\u2032_)\nopen import Level using (Level; suc; _\u2294_)\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_)\n\nprivate\n  variable\n    f g : Level\n    A B C : Set f\n------------------------------------------------------------------------\n-- The type of raw applicatives\n\nrecord RawApplicative (F : Set f \u2192 Set g) : Set (suc f \u2294 g) where\n  infixl 4 _&lt;*&gt;_ _&lt;*_ _*&gt;_\n  infixl 4 _\u229b_ _&lt;\u229b_ _\u229b&gt;_\n  infix  4 _\u2297_\n  field\n    rawFunctor : RawFunctor F\n    pure : A \u2192 F A\n    _&lt;*&gt;_ : F (A \u2192 B) \u2192 F A \u2192 F B\n\n  open RawFunctor rawFunctor public\n\n  _&lt;*_ : F A \u2192 F B \u2192 F A\n  a &lt;* b = const &lt;$&gt; a &lt;*&gt; b\n\n  _*&gt;_ : F A \u2192 F B \u2192 F B\n  a *&gt; b = flip const &lt;$&gt; a &lt;*&gt; b\n\n  zipWith : (A \u2192 B \u2192 C) \u2192 F A \u2192 F B \u2192 F C\n  zipWith f x y = f &lt;$&gt; x &lt;*&gt; y\n\n  zip : F A \u2192 F B \u2192 F (A \u00d7 B)\n  zip = zipWith _,_\n\n  -- Haskell-style alternative name for pure\n  return : A \u2192 F A\n  return = pure\n\n  -- backwards compatibility: unicode variants\n  _\u229b_ : F (A \u2192 B) \u2192 F A \u2192 F B\n  _\u229b_ = _&lt;*&gt;_\n\n  _&lt;\u229b_ : F A \u2192 F B \u2192 F A\n  _&lt;\u229b_ = _&lt;*_\n\n  _\u229b&gt;_ : F A \u2192 F B \u2192 F B\n  _\u229b&gt;_ = _*&gt;_\n\n  _\u2297_ : F A \u2192 F B \u2192 F (A \u00d7 B)\n  _\u2297_ = zip\n\nmodule _ where\n\n  open RawApplicative\n  open RawFunctor\n\n  -- Smart constructor\n  mkRawApplicative :\n    (F : Set f \u2192 Set g) \u2192\n    (pure : \u2200 {A} \u2192 A \u2192 F A) \u2192\n    (app : \u2200 {A B} \u2192 F (A \u2192 B) \u2192 F A \u2192 F B) \u2192\n    RawApplicative F\n  mkRawApplicative F pure app .rawFunctor ._&lt;$&gt;_ = app \u2218\u2032 pure\n  mkRawApplicative F pure app .pure = pure\n  mkRawApplicative F pure app ._&lt;*&gt;_ = app\n\n------------------------------------------------------------------------\n-- The type of raw applicatives with a zero\n\nrecord RawApplicativeZero (F : Set f \u2192 Set g) : Set (suc f \u2294 g) where\n  field\n    rawApplicative : RawApplicative F\n    rawEmpty : RawEmpty F\n\n  open RawApplicative rawApplicative public\n  open RawEmpty rawEmpty public\n\n  guard : Bool \u2192 F \u22a4\n  guard true = pure _\n  guard false = empty\n\n------------------------------------------------------------------------\n-- The type of raw alternative applicatives\n\nrecord RawAlternative (F : Set f \u2192 Set g) : Set (suc f \u2294 g) where\n  field\n    rawApplicativeZero : RawApplicativeZero F\n    rawChoice : RawChoice F\n\n  open RawApplicativeZero rawApplicativeZero public\n  open RawChoice rawChoice public\n\n------------------------------------------------------------------------\n-- The type of applicative morphisms\n\nrecord Morphism {F\u2081 F\u2082 : Set f \u2192 Set g}\n                (A\u2081 : RawApplicative F\u2081)\n                (A\u2082 : RawApplicative F\u2082) : Set (suc f \u2294 g) where\n  module A\u2081 = RawApplicative A\u2081\n  module A\u2082 = RawApplicative A\u2082\n  field\n    functorMorphism : Fun.Morphism A\u2081.rawFunctor A\u2082.rawFunctor\n\n  open Fun.Morphism functorMorphism public\n\n  field\n    op-pure : (x : A) \u2192 op (A\u2081.pure x) \u2261 A\u2082.pure x\n    op-&lt;*&gt;  : (f : F\u2081 (A \u2192 B)) (x : F\u2081 A) \u2192\n              op (f A\u2081.\u229b x) \u2261 (op f A\u2082.\u229b op x)\n\n  -- backwards compatibility: unicode variants\n  op-\u229b = op-&lt;*&gt;\n</pre>"},{"location":"md/Effect/Choice/","title":"Effect.Choice","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Type constructors giving rise to a semigroup at every type\n-- e.g. (List, _++_)\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Effect.Choice where\n\nopen import Level\n\nprivate\n  variable\n    \u2113 \u2113\u2032 : Level\n    A  : Set \u2113\n\nrecord RawChoice (F : Set \u2113 \u2192 Set \u2113\u2032) : Set (suc \u2113 \u2294 \u2113\u2032) where\n  infixr 3 _&lt;|&gt;_ _\u2223_\n  field\n    _&lt;|&gt;_ : F A \u2192 F A \u2192 F A\n\n  -- backwards compatibility: unicode variants\n  _\u2223_ : F A \u2192 F A \u2192 F A\n  _\u2223_ = _&lt;|&gt;_\n</pre>"},{"location":"md/Effect/Empty/","title":"Effect.Empty","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Empty values (e.g. [] for List, nothing for Maybe)\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Effect.Empty where\n\nopen import Level\n\nprivate\n  variable\n    \u2113 \u2113\u2032 : Level\n    A  : Set \u2113\n\nrecord RawEmpty (F : Set \u2113 \u2192 Set \u2113\u2032) : Set (suc \u2113 \u2294 \u2113\u2032) where\n  field\n    empty : F A\n\n  -- backwards compatibility: unicode variants\n  \u2205 : F A\n  \u2205 = empty\n</pre>"},{"location":"md/Effect/Functor/","title":"Effect.Functor","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Functors\n------------------------------------------------------------------------\n\n-- Note that currently the functor laws are not included here.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Effect.Functor where\n\nopen import Data.Unit.Polymorphic.Base using (\u22a4)\nopen import Function.Base using (const; flip)\nopen import Level\n\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_)\n\nprivate\n  variable\n    \u2113 \u2113\u2032 \u2113\u2033 : Level\n    A B X Y : Set \u2113\n\nrecord RawFunctor (F : Set \u2113 \u2192 Set \u2113\u2032) : Set (suc \u2113 \u2294 \u2113\u2032) where\n  infixl 4 _&lt;$&gt;_ _&lt;$_\n  infixl 1 _&lt;&amp;&gt;_\n  field\n    _&lt;$&gt;_ : (A \u2192 B) \u2192 F A \u2192 F B\n\n  _&lt;$_ : A \u2192 F B \u2192 F A\n  x &lt;$ y = const x &lt;$&gt; y\n\n  _&lt;&amp;&gt;_ : F A \u2192 (A \u2192 B) \u2192 F B\n  _&lt;&amp;&gt;_ = flip _&lt;$&gt;_\n\n  ignore : F A \u2192 F \u22a4\n  ignore = _ &lt;$_\n\n-- A functor morphism from F\u2081 to F\u2082 is an operation op such that\n-- op (F\u2081 f x) \u2261 F\u2082 f (op x)\n\nrecord Morphism {F\u2081 : Set \u2113 \u2192 Set \u2113\u2032} {F\u2082 : Set \u2113 \u2192 Set \u2113\u2033}\n                (fun\u2081 : RawFunctor F\u2081)\n                (fun\u2082 : RawFunctor F\u2082) : Set (suc \u2113 \u2294 \u2113\u2032 \u2294 \u2113\u2033) where\n  open RawFunctor\n  field\n    op     : F\u2081 X \u2192 F\u2082 X\n    op-&lt;$&gt; : (f : X \u2192 Y) (x : F\u2081 X) \u2192\n             op (fun\u2081 ._&lt;$&gt;_ f x) \u2261 fun\u2082 ._&lt;$&gt;_ f (op x)\n</pre>"},{"location":"md/Effect/Monad/","title":"Effect.Monad","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Monads\n------------------------------------------------------------------------\n\n-- Note that currently the monad laws are not included here.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Effect.Monad where\n\nopen import Data.Bool.Base using (Bool; true; false; not)\nopen import Data.Unit.Polymorphic.Base using (\u22a4)\n\nopen import Effect.Choice\nopen import Effect.Empty\nopen import Effect.Applicative\nopen import Function.Base using (id; flip; _$\u2032_; _\u2218\u2032_)\nopen import Level using (Level; suc; _\u2294_)\n\nprivate\n  variable\n    f g g\u2081 g\u2082 : Level\n    A B C : Set f\n\n------------------------------------------------------------------------\n-- The type of raw monads\n\nrecord RawMonad (F : Set f \u2192 Set g) : Set (suc f \u2294 g) where\n  infixl 1 _&gt;&gt;=_ _&gt;&gt;_ _&gt;=&gt;_\n  infixr 1 _=&lt;&lt;_ _&lt;=&lt;_\n  field\n    rawApplicative : RawApplicative F\n    _&gt;&gt;=_ : F A \u2192 (A \u2192 F B) \u2192 F B\n\n  open RawApplicative rawApplicative public\n\n  _&gt;&gt;_ : F A \u2192 F B \u2192 F B\n  _&gt;&gt;_ = _*&gt;_\n\n  _=&lt;&lt;_ : (A \u2192 F B) \u2192 F A \u2192 F B\n  _=&lt;&lt;_ = flip _&gt;&gt;=_\n\n  Kleisli : Set f \u2192 Set f \u2192 Set (f \u2294 g)\n  Kleisli A B = A \u2192 F B\n\n  _&gt;=&gt;_ : Kleisli A B \u2192 Kleisli B C \u2192 Kleisli A C\n  (f &gt;=&gt; g) a = f a &gt;&gt;= g\n\n  _&lt;=&lt;_ : Kleisli B C \u2192 Kleisli A B \u2192 Kleisli A C\n  _&lt;=&lt;_ = flip _&gt;=&gt;_\n\n  when : Bool \u2192 F \u22a4 \u2192 F \u22a4\n  when true m = m\n  when false m = pure _\n\n  unless : Bool \u2192 F \u22a4 \u2192 F \u22a4\n  unless = when \u2218\u2032 not\n\n-- When level g=f, a join/\u03bc operator is definable\n\nmodule Join {F : Set f \u2192 Set f} (M : RawMonad F) where\n  open RawMonad M\n\n  join : F (F A) \u2192 F A\n  join = _&gt;&gt;= id\n\n-- Smart constructor\n\nmodule _ where\n\n  open RawMonad\n  open RawApplicative\n\n  mkRawMonad :\n    (F : Set f \u2192 Set g) \u2192\n    (pure : \u2200 {A} \u2192 A \u2192 F A) \u2192\n    (bind : \u2200 {A B} \u2192 F A \u2192 (A \u2192 F B) \u2192 F B) \u2192\n    RawMonad F\n  mkRawMonad F pure _&gt;&gt;=_ .rawApplicative =\n    mkRawApplicative _ pure $\u2032 \u03bb mf mx \u2192 do\n      f \u2190 mf\n      x \u2190 mx\n      pure (f x)\n  mkRawMonad F pure _&gt;&gt;=_ ._&gt;&gt;=_ = _&gt;&gt;=_\n\n------------------------------------------------------------------------\n-- The type of raw monads with a zero\n\nrecord RawMonadZero (F : Set f \u2192 Set g) : Set (suc f \u2294 g) where\n  field\n    rawMonad : RawMonad F\n    rawEmpty : RawEmpty F\n\n  open RawMonad rawMonad public\n  open RawEmpty rawEmpty public\n\n  rawApplicativeZero : RawApplicativeZero F\n  rawApplicativeZero = record\n    { rawApplicative = rawApplicative\n    ; rawEmpty = rawEmpty\n    }\n\n------------------------------------------------------------------------\n-- The type of raw monadplus\n\nrecord RawMonadPlus (F : Set f \u2192 Set g) : Set (suc f \u2294 g) where\n  field\n    rawMonadZero : RawMonadZero F\n    rawChoice    : RawChoice F\n\n  open RawMonadZero rawMonadZero public\n  open RawChoice rawChoice public\n\n  rawAlternative : RawAlternative F\n  rawAlternative = record\n    { rawApplicativeZero = rawApplicativeZero\n    ; rawChoice = rawChoice\n    }\n\n------------------------------------------------------------------------\n-- The type of raw monad transformer\n\n-- F has been RawMonadT'd as TF\nrecord RawMonadTd (F : Set f \u2192 Set g\u2081) (TF : Set f \u2192 Set g\u2082) : Set (suc f \u2294 g\u2081 \u2294 g\u2082) where\n  field\n    lift : F A \u2192 TF A\n    rawMonad : RawMonad TF\n\n  open RawMonad rawMonad public\n\nRawMonadT : (T : (Set f \u2192 Set g\u2081) \u2192 (Set f \u2192 Set g\u2082)) \u2192 Set (suc f \u2294 suc g\u2081 \u2294 g\u2082)\nRawMonadT T = \u2200 {M} \u2192 RawMonad M \u2192 RawMonadTd M (T M)\n</pre>"},{"location":"md/Function/","title":"Function","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Functions\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function where\n\nopen import Function.Core public\nopen import Function.Base public\nopen import Function.Strict public\nopen import Function.Definitions public\nopen import Function.Structures public\nopen import Function.Structures.Biased public\nopen import Function.Bundles public\n</pre>"},{"location":"md/Function/Base/","title":"Function.Base","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Simple combinators working solely on and with functions\n------------------------------------------------------------------------\n\n-- The contents of this module is also accessible via the `Function`\n-- module. See `Function.Strict` for strict versions of these\n-- combinators.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function.Base where\n\nopen import Level using (Level)\n\nprivate\n  variable\n    a b c d e : Level\n    A : Set a\n    B : Set b\n    C : Set c\n    D : Set d\n    E : Set e\n\n------------------------------------------------------------------------\n-- Some simple functions\n\nid : A \u2192 A\nid x = x\n\nconst : A \u2192 B \u2192 A\nconst x = \u03bb _ \u2192 x\n\nconst\u1d63 : A \u2192 B \u2192 B\nconst\u1d63 _ = id\n\n------------------------------------------------------------------------\n-- Operations on dependent functions\n\n-- These are functions whose output has a type that depends on the\n-- value of the input to the function.\n\ninfixr 9 _\u2218_ _\u2218\u2082_\ninfixl 8 _\u02e2_\ninfixl 0 _|&gt;_\ninfix  0 case_return_of_\ninfixr -1 _$_\n\n-- Composition\n\n_\u2218_ : \u2200 {A : Set a} {B : A \u2192 Set b} {C : {x : A} \u2192 B x \u2192 Set c} \u2192\n      (\u2200 {x} (y : B x) \u2192 C y) \u2192 (g : (x : A) \u2192 B x) \u2192\n      ((x : A) \u2192 C (g x))\nf \u2218 g = \u03bb x \u2192 f (g x)\n{-# INLINE _\u2218_ #-}\n\n_\u2218\u2082_ : \u2200 {A\u2081 : Set a} {A\u2082 : A\u2081 \u2192 Set d}\n         {B : (x : A\u2081) \u2192 A\u2082 x \u2192 Set b}\n         {C : {x : A\u2081} \u2192 {y : A\u2082 x} \u2192 B x y \u2192 Set c} \u2192\n       ({x : A\u2081} \u2192 {y : A\u2082 x} \u2192 (z : B x y) \u2192 C z) \u2192\n       (g : (x : A\u2081) \u2192 (y : A\u2082 x) \u2192 B x y) \u2192\n       ((x : A\u2081) \u2192 (y : A\u2082 x) \u2192 C (g x y))\nf \u2218\u2082 g = \u03bb x y \u2192 f (g x y)\n\n-- Flipping order of arguments\n\nflip : \u2200 {A : Set a} {B : Set b} {C : A \u2192 B \u2192 Set c} \u2192\n       ((x : A) (y : B) \u2192 C x y) \u2192 ((y : B) (x : A) \u2192 C x y)\nflip f = \u03bb y x \u2192 f x y\n{-# INLINE flip #-}\n\n-- Application - note that _$_ is right associative, as in Haskell.\n-- If you want a left associative infix application operator, use\n-- RawFunctor._&lt;$&gt;_ from Effect.Functor.\n\n_$_ : \u2200 {A : Set a} {B : A \u2192 Set b} \u2192\n      ((x : A) \u2192 B x) \u2192 ((x : A) \u2192 B x)\nf $ x = f x\n{-# INLINE _$_ #-}\n\n-- Flipped application (aka pipe-forward)\n\n_|&gt;_ : \u2200 {A : Set a} {B : A \u2192 Set b} \u2192\n       (a : A) \u2192 (\u2200 a \u2192 B a) \u2192 B a\n_|&gt;_ = flip _$_\n{-# INLINE _|&gt;_ #-}\n\n-- The S combinator - written infix as in Conor McBride's paper\n-- \"Outrageous but Meaningful Coincidences: Dependent type-safe syntax\n-- and evaluation\".\n\n_\u02e2_ : \u2200 {A : Set a} {B : A \u2192 Set b} {C : (x : A) \u2192 B x \u2192 Set c} \u2192\n      ((x : A) (y : B x) \u2192 C x y) \u2192\n      (g : (x : A) \u2192 B x) \u2192\n      ((x : A) \u2192 C x (g x))\nf \u02e2 g = \u03bb x \u2192 f x (g x)\n{-# INLINE _\u02e2_ #-}\n\n-- Converting between implicit and explicit function spaces.\n\n_$- : \u2200 {A : Set a} {B : A \u2192 Set b} \u2192 ((x : A) \u2192 B x) \u2192 ({x : A} \u2192 B x)\nf $- = f _\n{-# INLINE _$- #-}\n\n\u03bb- : \u2200 {A : Set a} {B : A \u2192 Set b} \u2192 ({x : A} \u2192 B x) \u2192 ((x : A) \u2192 B x)\n\u03bb- f = \u03bb x \u2192 f\n{-# INLINE \u03bb- #-}\n\n-- Case expressions (to be used with pattern-matching lambdas, see\n-- README.Case).\n\ncase_returning_of_ : \u2200 {A : Set a} (x : A) (B : A \u2192 Set b) \u2192\n                  ((x : A) \u2192 B x) \u2192 B x\ncase x returning B of f = f x\n{-# INLINE case_returning_of_ #-}\n\n------------------------------------------------------------------------\n-- Non-dependent versions of dependent operations\n\n-- Any of the above operations for dependent functions will also work\n-- for non-dependent functions but sometimes Agda has difficulty\n-- inferring the non-dependency. Primed (\u2032 = \\prime) versions of the\n-- operations are therefore provided below that sometimes have better\n-- inference properties.\n\ninfixr 9 _\u2218\u2032_ _\u2218\u2082\u2032_\ninfixl 0 _|&gt;\u2032_\ninfix  0 case_of_\ninfixr -1 _$\u2032_\n\n-- Composition\n\n_\u2218\u2032_ : (B \u2192 C) \u2192 (A \u2192 B) \u2192 (A \u2192 C)\nf \u2218\u2032 g = _\u2218_ f g\n\n_\u2218\u2082\u2032_ : (C \u2192 D) \u2192 (A \u2192 B \u2192 C) \u2192 (A \u2192 B \u2192 D)\nf \u2218\u2082\u2032 g = _\u2218\u2082_ f g\n\n-- Flipping order of arguments\n\nflip\u2032 : (A \u2192 B \u2192 C) \u2192 (B \u2192 A \u2192 C)\nflip\u2032 = flip\n\n-- Application\n\n_$\u2032_ : (A \u2192 B) \u2192 (A \u2192 B)\n_$\u2032_ = _$_\n\n-- Flipped application (aka pipe-forward)\n\n_|&gt;\u2032_ : A \u2192 (A \u2192 B) \u2192 B\n_|&gt;\u2032_ = _|&gt;_\n\n-- Case expressions (to be used with pattern-matching lambdas, see\n-- README.Case).\n\ncase_of_ : A \u2192 (A \u2192 B) \u2192 B\ncase x of f = case x returning _ of f\n{-# INLINE case_of_ #-}\n\n------------------------------------------------------------------------\n-- Operations that are only defined for non-dependent functions\n\ninfixl 1 _\u27e8_\u27e9_\ninfixl 0 _\u220b_\n\n-- Binary application\n\n_\u27e8_\u27e9_ : A \u2192 (A \u2192 B \u2192 C) \u2192 B \u2192 C\nx \u27e8 f \u27e9 y = f x y\n\n-- In Agda you cannot annotate every subexpression with a type\n-- signature. This function can be used instead.\n\n_\u220b_ : (A : Set a) \u2192 A \u2192 A\nA \u220b x = x\n\n-- Conversely it is sometimes useful to be able to extract the\n-- type of a given expression.\n\ntypeOf : {A : Set a} \u2192 A \u2192 Set a\ntypeOf {A = A} _ = A\n\n-- Construct an element of the given type by instance search.\n\nit : {A : Set a} \u2192 {{A}} \u2192 A\nit {{x}} = x\n\n------------------------------------------------------------------------\n-- Composition of a binary function with other functions\n\ninfixr 0 _-\u27ea_\u27eb-_ _-\u27e8_\u27eb-_\ninfixl 0 _-\u27ea_\u27e9-_\ninfixr 1 _-\u27e8_\u27e9-_ \u2223_\u27eb-_ \u2223_\u27e9-_\ninfixl 1 _on_ _on\u2082_ _-\u27ea_\u2223 _-\u27e8_\u2223\n\n-- Two binary functions\n\n_-\u27ea_\u27eb-_ : (A \u2192 B \u2192 C) \u2192 (C \u2192 D \u2192 E) \u2192 (A \u2192 B \u2192 D) \u2192 (A \u2192 B \u2192 E)\nf -\u27ea _*_ \u27eb- g = \u03bb x y \u2192 f x y * g x y\n\n-- A single binary function on the left\n\n_-\u27ea_\u2223 : (A \u2192 B \u2192 C) \u2192 (C \u2192 B \u2192 D) \u2192 (A \u2192 B \u2192 D)\nf -\u27ea _*_ \u2223 = f -\u27ea _*_ \u27eb- const\u1d63\n\n-- A single binary function on the right\n\n\u2223_\u27eb-_ : (A \u2192 C \u2192 D) \u2192 (A \u2192 B \u2192 C) \u2192 (A \u2192 B \u2192 D)\n\u2223 _*_ \u27eb- g = const -\u27ea _*_ \u27eb- g\n\n-- A single unary function on the left\n\n_-\u27e8_\u2223 : (A \u2192 C) \u2192 (C \u2192 B \u2192 D) \u2192 (A \u2192 B \u2192 D)\nf -\u27e8 _*_ \u2223 = f \u2218\u2082 const -\u27ea _*_ \u2223\n\n-- A single unary function on the right\n\n\u2223_\u27e9-_ : (A \u2192 C \u2192 D) \u2192 (B \u2192 C) \u2192 (A \u2192 B \u2192 D)\n\u2223 _*_ \u27e9- g = \u2223 _*_ \u27eb- g \u2218\u2082 const\u1d63\n\n-- A binary function and a unary function\n\n_-\u27ea_\u27e9-_ : (A \u2192 B \u2192 C) \u2192 (C \u2192 D \u2192 E) \u2192 (B \u2192 D) \u2192 (A \u2192 B \u2192 E)\nf -\u27ea _*_ \u27e9- g = f -\u27ea _*_ \u27eb- \u2223 const\u1d63 \u27e9- g\n\n-- A unary function and a binary function\n\n_-\u27e8_\u27eb-_ : (A \u2192 C) \u2192 (C \u2192 D \u2192 E) \u2192 (A \u2192 B \u2192 D) \u2192 (A \u2192 B \u2192 E)\nf -\u27e8 _*_ \u27eb- g = f -\u27e8 const \u2223 -\u27ea _*_ \u27eb- g\n\n-- Two unary functions\n\n_-\u27e8_\u27e9-_ : (A \u2192 C) \u2192 (C \u2192 D \u2192 E) \u2192 (B \u2192 D) \u2192 (A \u2192 B \u2192 E)\nf -\u27e8 _*_ \u27e9- g = f -\u27e8 const \u2223 -\u27ea _*_ \u27eb- \u2223 const\u1d63 \u27e9- g\n\n-- A single binary function on both sides\n\n_on\u2082_ : (C \u2192 C \u2192 D) \u2192 (A \u2192 B \u2192 C) \u2192 (A \u2192 B \u2192 D)\n_*_ on\u2082 f = f -\u27ea _*_ \u27eb- f\n\n-- A single unary function on both sides\n\n_on_ : (B \u2192 B \u2192 C) \u2192 (A \u2192 B) \u2192 (A \u2192 A \u2192 C)\n_*_ on f = f -\u27e8 _*_ \u27e9- f\n\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 1.4\n\n_-[_]-_ = _-\u27ea_\u27eb-_\n{-# WARNING_ON_USAGE _-[_]-_\n\"Warning: Function._-[_]-_ was deprecated in v1.4.\nPlease use _-\u27ea_\u27eb-_ instead.\"\n#-}\n\n-- Version 2.0\n\ncase_return_of_ = case_returning_of_\n{-# WARNING_ON_USAGE case_return_of_\n\"case_return_of_ was deprecated in v2.0.\nPlease use case_returning_of_ instead.\"\n#-}\n\n</pre>"},{"location":"md/Function/Bundles/","title":"Function.Bundles","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Bundles for types of functions\n------------------------------------------------------------------------\n\n-- The contents of this file should usually be accessed from `Function`.\n\n-- Note that these bundles differ from those found elsewhere in other\n-- library hierarchies as they take Setoids as parameters. This is\n-- because a function is of no use without knowing what its domain and\n-- codomain is, as well which equalities are being considered over them.\n-- One consequence of this is that they are not built from the\n-- definitions found in `Function.Structures` as is usually the case in\n-- other library hierarchies, as this would duplicate the equality\n-- axioms.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function.Bundles where\n\nopen import Function.Base using (_\u2218_)\nopen import Function.Definitions\nimport Function.Structures as FunctionStructures\nopen import Level using (Level; _\u2294_; suc)\nopen import Data.Product.Base using (_,_; proj\u2081; proj\u2082)\nopen import Relation.Binary.Bundles using (Setoid)\nopen import Relation.Binary.Core using (_Preserves_\u27f6_)\nopen import Relation.Binary.PropositionalEquality.Core as \u2261\n  using (_\u2261_)\nimport Relation.Binary.PropositionalEquality.Properties as \u2261\nopen import Function.Consequences.Propositional\nopen Setoid using (isEquivalence)\n\nprivate\n  variable\n    a b \u2113\u2081 \u2113\u2082 : Level\n\n------------------------------------------------------------------------\n-- Setoid bundles\n------------------------------------------------------------------------\n\nmodule _ (From : Setoid a \u2113\u2081) (To : Setoid b \u2113\u2082) where\n\n  open Setoid From using () renaming (Carrier to A; _\u2248_ to _\u2248\u2081_)\n  open Setoid To   using () renaming (Carrier to B; _\u2248_ to _\u2248\u2082_)\n  open FunctionStructures _\u2248\u2081_ _\u2248\u2082_\n\n------------------------------------------------------------------------\n-- Bundles with one element\n\n  -- Called `Func` rather than `Function` in order to avoid clashing\n  -- with the top-level module.\n  record Func : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      to   : A \u2192 B\n      cong : Congruent _\u2248\u2081_ _\u2248\u2082_ to\n\n    isCongruent : IsCongruent to\n    isCongruent = record\n      { cong           = cong\n      ; isEquivalence\u2081 = isEquivalence From\n      ; isEquivalence\u2082 = isEquivalence To\n      }\n\n    open IsCongruent isCongruent public\n      using (module Eq\u2081; module Eq\u2082)\n\n\n  record Injection : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      to          : A \u2192 B\n      cong        : Congruent _\u2248\u2081_ _\u2248\u2082_ to\n      injective   : Injective _\u2248\u2081_ _\u2248\u2082_ to\n\n    function : Func\n    function = record\n      { to   = to\n      ; cong = cong\n      }\n\n    open Func function public\n      hiding (to; cong)\n\n    isInjection : IsInjection to\n    isInjection = record\n      { isCongruent = isCongruent\n      ; injective   = injective\n      }\n\n\n  record Surjection : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      to         : A \u2192 B\n      cong       : Congruent _\u2248\u2081_ _\u2248\u2082_ to\n      surjective : Surjective _\u2248\u2081_ _\u2248\u2082_ to\n\n    function : Func\n    function = record\n      { to   = to\n      ; cong = cong\n      }\n\n    open Func function public\n      hiding (to; cong)\n\n    isSurjection : IsSurjection to\n    isSurjection = record\n      { isCongruent = isCongruent\n      ; surjective  = surjective\n      }\n\n    open IsSurjection isSurjection public\n      using\n      ( strictlySurjective\n      )\n\n    to\u207b : B \u2192 A\n    to\u207b = proj\u2081 \u2218 surjective\n\n    to\u2218to\u207b : \u2200 x \u2192 to (to\u207b x) \u2248\u2082 x\n    to\u2218to\u207b = proj\u2082 \u2218 strictlySurjective\n\n\n  record Bijection : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      to        : A \u2192 B\n      cong      : Congruent _\u2248\u2081_ _\u2248\u2082_ to\n      bijective : Bijective _\u2248\u2081_ _\u2248\u2082_ to\n\n    injective : Injective _\u2248\u2081_ _\u2248\u2082_ to\n    injective = proj\u2081 bijective\n\n    surjective : Surjective _\u2248\u2081_ _\u2248\u2082_ to\n    surjective = proj\u2082 bijective\n\n    injection : Injection\n    injection = record\n      { cong      = cong\n      ; injective = injective\n      }\n\n    surjection : Surjection\n    surjection = record\n      { cong       = cong\n      ; surjective = surjective\n      }\n\n    open Injection  injection  public using (isInjection)\n    open Surjection surjection public using (isSurjection; to\u207b;  strictlySurjective)\n\n    isBijection : IsBijection to\n    isBijection = record\n      { isInjection = isInjection\n      ; surjective  = surjective\n      }\n\n    open IsBijection isBijection public using (module Eq\u2081; module Eq\u2082)\n\n\n------------------------------------------------------------------------\n-- Bundles with two elements\n\nmodule _ (From : Setoid a \u2113\u2081) (To : Setoid b \u2113\u2082) where\n\n  open Setoid From using () renaming (Carrier to A; _\u2248_ to _\u2248\u2081_)\n  open Setoid To   using () renaming (Carrier to B; _\u2248_ to _\u2248\u2082_)\n  open FunctionStructures _\u2248\u2081_ _\u2248\u2082_\n\n  record Equivalence : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      to        : A \u2192 B\n      from      : B \u2192 A\n      to-cong   : Congruent _\u2248\u2081_ _\u2248\u2082_ to\n      from-cong : Congruent _\u2248\u2082_ _\u2248\u2081_ from\n\n    toFunction : Func From To\n    toFunction = record\n      { to = to\n      ; cong = to-cong\n      }\n\n    open Func toFunction public\n      using (module Eq\u2081; module Eq\u2082)\n      renaming (isCongruent to to-isCongruent)\n\n    fromFunction : Func To From\n    fromFunction = record\n      { to = from\n      ; cong = from-cong\n      }\n\n    open Func fromFunction public\n      using ()\n      renaming (isCongruent to from-isCongruent)\n\n\n  record LeftInverse : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      to        : A \u2192 B\n      from      : B \u2192 A\n      to-cong   : Congruent _\u2248\u2081_ _\u2248\u2082_ to\n      from-cong : Congruent _\u2248\u2082_ _\u2248\u2081_ from\n      inverse\u02e1  : Inverse\u02e1 _\u2248\u2081_ _\u2248\u2082_ to from\n\n    isCongruent : IsCongruent to\n    isCongruent = record\n      { cong           = to-cong\n      ; isEquivalence\u2081 = isEquivalence From\n      ; isEquivalence\u2082 = isEquivalence To\n      }\n\n    isLeftInverse : IsLeftInverse to from\n    isLeftInverse = record\n      { isCongruent = isCongruent\n      ; from-cong   = from-cong\n      ; inverse\u02e1    = inverse\u02e1\n      }\n\n    open IsLeftInverse isLeftInverse public\n      using (module Eq\u2081; module Eq\u2082; strictlyInverse\u02e1; isSurjection)\n\n    equivalence : Equivalence\n    equivalence = record\n      { to-cong   = to-cong\n      ; from-cong = from-cong\n      }\n\n    isSplitSurjection : IsSplitSurjection to\n    isSplitSurjection = record\n      { from = from\n      ; isLeftInverse = isLeftInverse\n      }\n\n    surjection : Surjection From To\n    surjection = record\n      { to = to\n      ; cong = to-cong\n      ; surjective = \u03bb y \u2192 from y , inverse\u02e1\n      }\n\n\n\n  record RightInverse : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      to        : A \u2192 B\n      from      : B \u2192 A\n      to-cong   : Congruent _\u2248\u2081_ _\u2248\u2082_ to\n      from-cong : from Preserves _\u2248\u2082_ \u27f6 _\u2248\u2081_\n      inverse\u02b3  : Inverse\u02b3 _\u2248\u2081_ _\u2248\u2082_ to from\n\n    isCongruent : IsCongruent to\n    isCongruent = record\n      { cong           = to-cong\n      ; isEquivalence\u2081 = isEquivalence From\n      ; isEquivalence\u2082 = isEquivalence To\n      }\n\n    isRightInverse : IsRightInverse to from\n    isRightInverse = record\n      { isCongruent = isCongruent\n      ; from-cong   = from-cong\n      ; inverse\u02b3    = inverse\u02b3\n      }\n\n    open IsRightInverse isRightInverse public\n      using (module Eq\u2081; module Eq\u2082; strictlyInverse\u02b3)\n\n    equivalence : Equivalence\n    equivalence = record\n      { to-cong   = to-cong\n      ; from-cong = from-cong\n      }\n\n\n  record Inverse : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      to        : A \u2192 B\n      from      : B \u2192 A\n      to-cong   : Congruent _\u2248\u2081_ _\u2248\u2082_ to\n      from-cong : Congruent _\u2248\u2082_ _\u2248\u2081_ from\n      inverse   : Inverse\u1d47 _\u2248\u2081_ _\u2248\u2082_ to from\n\n    inverse\u02e1 : Inverse\u02e1 _\u2248\u2081_ _\u2248\u2082_ to from\n    inverse\u02e1 = proj\u2081 inverse\n\n    inverse\u02b3 : Inverse\u02b3 _\u2248\u2081_ _\u2248\u2082_ to from\n    inverse\u02b3 = proj\u2082 inverse\n\n    leftInverse : LeftInverse\n    leftInverse = record\n      { to-cong   = to-cong\n      ; from-cong = from-cong\n      ; inverse\u02e1  = inverse\u02e1\n      }\n\n    rightInverse : RightInverse\n    rightInverse = record\n      { to-cong   = to-cong\n      ; from-cong = from-cong\n      ; inverse\u02b3  = inverse\u02b3\n      }\n\n    open LeftInverse leftInverse   public using (isLeftInverse; strictlyInverse\u02e1)\n    open RightInverse rightInverse public using (isRightInverse; strictlyInverse\u02b3)\n\n    isInverse : IsInverse to from\n    isInverse = record\n      { isLeftInverse = isLeftInverse\n      ; inverse\u02b3      = inverse\u02b3\n      }\n\n    open IsInverse isInverse public using (module Eq\u2081; module Eq\u2082)\n\n\n------------------------------------------------------------------------\n-- Bundles with three elements\n\n  record BiEquivalence : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      to         : A \u2192 B\n      from\u2081      : B \u2192 A\n      from\u2082      : B \u2192 A\n      to-cong    : Congruent _\u2248\u2081_ _\u2248\u2082_ to\n      from\u2081-cong : Congruent _\u2248\u2082_ _\u2248\u2081_ from\u2081\n      from\u2082-cong : Congruent _\u2248\u2082_ _\u2248\u2081_ from\u2082\n\n\n  record BiInverse : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n    field\n      to          : A \u2192 B\n      from\u2081       : B \u2192 A\n      from\u2082       : B \u2192 A\n      to-cong     : Congruent _\u2248\u2081_ _\u2248\u2082_ to\n      from\u2081-cong  : Congruent _\u2248\u2082_ _\u2248\u2081_ from\u2081\n      from\u2082-cong  : Congruent _\u2248\u2082_ _\u2248\u2081_ from\u2082\n      inverse\u02e1  : Inverse\u02e1 _\u2248\u2081_ _\u2248\u2082_ to from\u2081\n      inverse\u02b3  : Inverse\u02b3 _\u2248\u2081_ _\u2248\u2082_ to from\u2082\n\n    to-isCongruent : IsCongruent to\n    to-isCongruent = record\n      { cong           = to-cong\n      ; isEquivalence\u2081 = isEquivalence From\n      ; isEquivalence\u2082 = isEquivalence To\n      }\n\n    isBiInverse : IsBiInverse to from\u2081 from\u2082\n    isBiInverse = record\n      { to-isCongruent = to-isCongruent\n      ; from\u2081-cong     = from\u2081-cong\n      ; from\u2082-cong     = from\u2082-cong\n      ; inverse\u02e1       = inverse\u02e1\n      ; inverse\u02b3       = inverse\u02b3\n      }\n\n    biEquivalence : BiEquivalence\n    biEquivalence = record\n      { to-cong    = to-cong\n      ; from\u2081-cong = from\u2081-cong\n      ; from\u2082-cong = from\u2082-cong\n      }\n\n------------------------------------------------------------------------\n-- Other\n\n  -- A left inverse is also known as a \u201csplit surjection\u201d.\n  --\n  -- As the name implies, a split surjection is a special kind of\n  -- surjection where the witness generated in the domain in the\n  -- function for elements `x\u2081` and `x\u2082` are equal if `x\u2081 \u2248 x\u2082` .\n  --\n  -- The difference is the `from-cong` law --- generally, the section\n  -- (called `Surjection.to\u207b` or `SplitSurjection.from`) of a surjection\n  -- need not respect equality, whereas it must in a split surjection.\n  --\n  -- The two notions coincide when the equivalence relation on `B` is\n  -- propositional equality (because all functions respect propositional\n  -- equality).\n  --\n  -- For further background on (split) surjections, one may consult any\n  -- general mathematical references which work without the principle\n  -- of choice. For example:\n  --\n  --   https://ncatlab.org/nlab/show/split+epimorphism.\n  --\n  -- The connection to set-theoretic notions with the same names is\n  -- justified by the setoid type theory/homotopy type theory\n  -- observation/definition that (\u2203x : A. P) = \u2225 \u03a3x : A. P \u2225 --- i.e.,\n  -- we can read set-theoretic \u2203 as squashed/propositionally truncated \u03a3.\n  --\n  -- We see working with setoids as working in the MLTT model of a setoid\n  -- type theory, in which \u2225 X \u2225 is interpreted as the setoid with carrier\n  -- set X and the equivalence relation that relates all elements.\n  -- All maps into \u2225 X \u2225 respect equality, so in the idiomatic definitions\n  -- here, we drop the corresponding trivial `cong` field completely.\n\n  SplitSurjection : Set _\n  SplitSurjection = LeftInverse\n\n  module SplitSurjection (splitSurjection : SplitSurjection) =\n    LeftInverse splitSurjection\n\n------------------------------------------------------------------------\n-- Infix abbreviations for oft-used items\n------------------------------------------------------------------------\n\n-- Same naming convention as used for propositional equality below, with\n-- appended \u209b (for 'S'etoid).\n\ninfixr 0 _\u27f6\u209b_\n_\u27f6\u209b_ : Setoid a \u2113\u2081 \u2192 Setoid b \u2113\u2082 \u2192 Set _\n_\u27f6\u209b_ = Func\n\n------------------------------------------------------------------------\n-- Bundles specialised for propositional equality\n------------------------------------------------------------------------\n\ninfix 3 _\u27f6_ _\u21a3_ _\u21a0_ _\u2916_ _\u21d4_ _\u21a9_ _\u21aa_ _\u21a9\u21aa_ _\u2194_\n_\u27f6_ : Set a \u2192 Set b \u2192 Set _\nA \u27f6 B = Func (\u2261.setoid A) (\u2261.setoid B)\n\n_\u21a3_ : Set a \u2192 Set b \u2192 Set _\nA \u21a3 B = Injection (\u2261.setoid A) (\u2261.setoid B)\n\n_\u21a0_ : Set a \u2192 Set b \u2192 Set _\nA \u21a0 B = Surjection (\u2261.setoid A) (\u2261.setoid B)\n\n_\u2916_ : Set a \u2192 Set b \u2192 Set _\nA \u2916 B = Bijection (\u2261.setoid A) (\u2261.setoid B)\n\n_\u21d4_ : Set a \u2192 Set b \u2192 Set _\nA \u21d4 B = Equivalence (\u2261.setoid A) (\u2261.setoid B)\n\n_\u21a9_ : Set a \u2192 Set b \u2192 Set _\nA \u21a9 B = LeftInverse (\u2261.setoid A) (\u2261.setoid B)\n\n_\u21aa_ : Set a \u2192 Set b \u2192 Set _\nA \u21aa B = RightInverse (\u2261.setoid A) (\u2261.setoid B)\n\n_\u21a9\u21aa_ : Set a \u2192 Set b \u2192 Set _\nA \u21a9\u21aa B = BiInverse (\u2261.setoid A) (\u2261.setoid B)\n\n_\u2194_ : Set a \u2192 Set b \u2192 Set _\nA \u2194 B = Inverse (\u2261.setoid A) (\u2261.setoid B)\n\n-- We now define some constructors for the above that\n-- automatically provide the required congruency proofs.\n\nmodule _ {A : Set a} {B : Set b} where\n\n  mk\u27f6 : (A \u2192 B) \u2192 A \u27f6 B\n  mk\u27f6 to = record\n    { to        = to\n    ; cong      = \u2261.cong to\n    }\n\n  mk\u21a3 : \u2200 {to : A \u2192 B} \u2192 Injective _\u2261_ _\u2261_ to \u2192 A \u21a3 B\n  mk\u21a3 {to} inj = record\n    { to         = to\n    ; cong      = \u2261.cong to\n    ; injective = inj\n    }\n\n  mk\u21a0 : \u2200 {to : A \u2192 B} \u2192 Surjective _\u2261_ _\u2261_ to \u2192 A \u21a0 B\n  mk\u21a0 {to} surj = record\n    { to         = to\n    ; cong       = \u2261.cong to\n    ; surjective = surj\n    }\n\n  mk\u2916 : \u2200 {to : A \u2192 B} \u2192 Bijective _\u2261_ _\u2261_ to \u2192 A \u2916 B\n  mk\u2916 {to} bij = record\n    { to        = to\n    ; cong      = \u2261.cong to\n    ; bijective = bij\n    }\n\n  mk\u21d4 : \u2200 (to : A \u2192 B) (from : B \u2192 A) \u2192 A \u21d4 B\n  mk\u21d4 to from = record\n    { to        = to\n    ; from      = from\n    ; to-cong   = \u2261.cong to\n    ; from-cong = \u2261.cong from\n    }\n\n  mk\u21a9 : \u2200 {to : A \u2192 B} {from : B \u2192 A} \u2192 Inverse\u02e1 _\u2261_ _\u2261_ to from \u2192 A \u21a9 B\n  mk\u21a9 {to} {from} inv\u02e1 = record\n    { to        = to\n    ; from      = from\n    ; to-cong   = \u2261.cong to\n    ; from-cong = \u2261.cong from\n    ; inverse\u02e1  = inv\u02e1\n    }\n\n  mk\u21aa : \u2200 {to : A \u2192 B} {from : B \u2192 A} \u2192 Inverse\u02b3 _\u2261_ _\u2261_ to from \u2192 A \u21aa B\n  mk\u21aa {to} {from} inv\u02b3 = record\n    { to        = to\n    ; from      = from\n    ; to-cong   = \u2261.cong to\n    ; from-cong = \u2261.cong from\n    ; inverse\u02b3  = inv\u02b3\n    }\n\n  mk\u21a9\u21aa : \u2200 {to : A \u2192 B} {from\u2081 : B \u2192 A} {from\u2082 : B \u2192 A} \u2192\n         Inverse\u02e1 _\u2261_ _\u2261_ to from\u2081 \u2192 Inverse\u02b3 _\u2261_ _\u2261_ to from\u2082 \u2192 A \u21a9\u21aa B\n  mk\u21a9\u21aa {to} {from\u2081} {from\u2082} inv\u02e1 inv\u02b3 = record\n    { to         = to\n    ; from\u2081      = from\u2081\n    ; from\u2082      = from\u2082\n    ; to-cong    = \u2261.cong to\n    ; from\u2081-cong = \u2261.cong from\u2081\n    ; from\u2082-cong = \u2261.cong from\u2082\n    ; inverse\u02e1   = inv\u02e1\n    ; inverse\u02b3   = inv\u02b3\n    }\n\n  mk\u2194 : \u2200 {to : A \u2192 B} {from : B \u2192 A} \u2192 Inverse\u1d47 _\u2261_ _\u2261_ to from \u2192 A \u2194 B\n  mk\u2194 {to} {from} inv = record\n    { to        = to\n    ; from      = from\n    ; to-cong   = \u2261.cong to\n    ; from-cong = \u2261.cong from\n    ; inverse   = inv\n    }\n\n\n  -- Strict variant of the above.\n  mk\u21a0\u209b : \u2200 {to : A \u2192 B} \u2192 StrictlySurjective _\u2261_ to \u2192 A \u21a0 B\n  mk\u21a0\u209b = mk\u21a0 \u2218 strictlySurjective\u21d2surjective\n\n  mk\u2194\u209b\u2032 : \u2200 (to : A \u2192 B) (from : B \u2192 A) \u2192\n          StrictlyInverse\u02e1 _\u2261_ to from \u2192\n          StrictlyInverse\u02b3 _\u2261_ to from \u2192\n          A \u2194 B\n  mk\u2194\u209b\u2032 to from inv\u02e1 inv\u02b3 = mk\u2194 {to} {from}\n    ( strictlyInverse\u02e1\u21d2inverse\u02e1 to inv\u02e1\n    , strictlyInverse\u02b3\u21d2inverse\u02b3 to inv\u02b3\n    )\n\n------------------------------------------------------------------------\n-- Other\n------------------------------------------------------------------------\n\n-- Alternative syntax for the application of functions\n\nmodule _ {From : Setoid a \u2113\u2081} {To : Setoid b \u2113\u2082} where\n  open Setoid\n\n  infixl 5 _\u27e8$\u27e9_\n  _\u27e8$\u27e9_ : Func From To \u2192 Carrier From \u2192 Carrier To\n  _\u27e8$\u27e9_ = Func.to\n</pre>"},{"location":"md/Function/Consequences/","title":"Function.Consequences","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Relationships between properties of functions. See\n-- `Function.Consequences.Propositional` for specialisations to\n-- propositional equality.\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function.Consequences where\n\nopen import Data.Product.Base as Product\nopen import Function.Definitions\nopen import Level using (Level)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.Bundles using (Setoid)\nopen import Relation.Binary.Definitions using (Reflexive; Symmetric; Transitive)\nopen import Relation.Nullary.Negation.Core using (\u00ac_; contraposition)\n\nprivate\n  variable\n    a b \u2113\u2081 \u2113\u2082 : Level\n    A B : Set a\n    \u2248\u2081 \u2248\u2082 : Rel A \u2113\u2081\n    f f\u207b\u00b9 : A \u2192 B\n\n------------------------------------------------------------------------\n-- Injective\n\ncontraInjective : \u2200 (\u2248\u2082 : Rel B \u2113\u2082) \u2192 Injective \u2248\u2081 \u2248\u2082 f \u2192\n                  \u2200 {x y} \u2192 \u00ac (\u2248\u2081 x y) \u2192 \u00ac (\u2248\u2082 (f x) (f y))\ncontraInjective _ inj p = contraposition inj p\n\n------------------------------------------------------------------------\n-- Inverse\u02e1\n\ninverse\u02e1\u21d2surjective : \u2200 (\u2248\u2082 : Rel B \u2113\u2082) \u2192\n                      Inverse\u02e1 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9 \u2192\n                      Surjective \u2248\u2081 \u2248\u2082 f\ninverse\u02e1\u21d2surjective \u2248\u2082 inv\u02e1 y = (_ , inv\u02e1)\n\n------------------------------------------------------------------------\n-- Inverse\u02b3\n\ninverse\u02b3\u21d2injective : \u2200 (\u2248\u2082 : Rel B \u2113\u2082) f \u2192\n                     Reflexive \u2248\u2082 \u2192\n                     Symmetric \u2248\u2081 \u2192\n                     Transitive \u2248\u2081 \u2192\n                     Inverse\u02b3 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9 \u2192\n                     Injective \u2248\u2081 \u2248\u2082 f\ninverse\u02b3\u21d2injective \u2248\u2082 f refl sym trans inv\u02b3 {x} {y} fx\u2248fy =\n  trans (sym (inv\u02b3 refl)) (inv\u02b3 fx\u2248fy)\n\n------------------------------------------------------------------------\n-- Inverse\u1d47\n\ninverse\u1d47\u21d2bijective : \u2200 (\u2248\u2082 : Rel B \u2113\u2082) \u2192\n                     Reflexive \u2248\u2082 \u2192\n                     Symmetric \u2248\u2081 \u2192\n                     Transitive \u2248\u2081 \u2192\n                     Inverse\u1d47 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9 \u2192\n                     Bijective \u2248\u2081 \u2248\u2082 f\ninverse\u1d47\u21d2bijective {f = f} \u2248\u2082 refl sym trans (inv\u02e1 , inv\u02b3) =\n  (inverse\u02b3\u21d2injective \u2248\u2082 f refl sym trans inv\u02b3 , inverse\u02e1\u21d2surjective \u2248\u2082 inv\u02e1)\n\n------------------------------------------------------------------------\n-- StrictlySurjective\n\nsurjective\u21d2strictlySurjective : \u2200 (\u2248\u2082 : Rel B \u2113\u2082) \u2192\n                                 Reflexive \u2248\u2081 \u2192\n                                 Surjective \u2248\u2081 \u2248\u2082 f \u2192\n                                 StrictlySurjective \u2248\u2082 f\nsurjective\u21d2strictlySurjective _ refl surj x =\n  Product.map\u2082 (\u03bb v \u2192 v refl) (surj x)\n\nstrictlySurjective\u21d2surjective : Transitive \u2248\u2082 \u2192\n                                 Congruent \u2248\u2081 \u2248\u2082 f \u2192\n                                 StrictlySurjective \u2248\u2082 f \u2192\n                                 Surjective \u2248\u2081 \u2248\u2082 f\nstrictlySurjective\u21d2surjective trans cong surj x =\n  Product.map\u2082 (\u03bb fy\u2248x z\u2248y \u2192 trans (cong z\u2248y) fy\u2248x) (surj x)\n\n------------------------------------------------------------------------\n-- StrictlyInverse\u02e1\n\ninverse\u02e1\u21d2strictlyInverse\u02e1 : \u2200 (\u2248\u2081 : Rel A \u2113\u2081) (\u2248\u2082 : Rel B \u2113\u2082) \u2192\n                            Reflexive \u2248\u2081 \u2192\n                            Inverse\u02e1 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9 \u2192\n                            StrictlyInverse\u02e1 \u2248\u2082 f f\u207b\u00b9\ninverse\u02e1\u21d2strictlyInverse\u02e1 _ _ refl sinv x = sinv refl\n\nstrictlyInverse\u02e1\u21d2inverse\u02e1 : Transitive \u2248\u2082 \u2192\n                            Congruent \u2248\u2081 \u2248\u2082 f \u2192\n                            StrictlyInverse\u02e1 \u2248\u2082 f f\u207b\u00b9 \u2192\n                            Inverse\u02e1 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9\nstrictlyInverse\u02e1\u21d2inverse\u02e1 trans cong sinv {x} y\u2248f\u207b\u00b9x =\n  trans (cong y\u2248f\u207b\u00b9x) (sinv x)\n\n------------------------------------------------------------------------\n-- StrictlyInverse\u02b3\n\ninverse\u02b3\u21d2strictlyInverse\u02b3 : \u2200 (\u2248\u2081 : Rel A \u2113\u2081) (\u2248\u2082 : Rel B \u2113\u2082) \u2192\n                            Reflexive \u2248\u2082 \u2192\n                            Inverse\u02b3 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9 \u2192\n                            StrictlyInverse\u02b3 \u2248\u2081 f f\u207b\u00b9\ninverse\u02b3\u21d2strictlyInverse\u02b3 _ _ refl sinv x = sinv refl\n\nstrictlyInverse\u02b3\u21d2inverse\u02b3 : Transitive \u2248\u2081 \u2192\n                            Congruent \u2248\u2082 \u2248\u2081 f\u207b\u00b9 \u2192\n                            StrictlyInverse\u02b3 \u2248\u2081 f f\u207b\u00b9 \u2192\n                            Inverse\u02b3 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9\nstrictlyInverse\u02b3\u21d2inverse\u02b3 trans cong sinv {x} y\u2248f\u207b\u00b9x =\n  trans (cong y\u2248f\u207b\u00b9x) (sinv x)\n</pre>"},{"location":"md/Function/Consequences/Propositional/","title":"Function.Consequences.Propositional","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Relationships between properties of functions where the equality\n-- over both the domain and codomain is assumed to be _\u2261_\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function.Consequences.Propositional\n  {a b} {A : Set a} {B : Set b}\n  where\n\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_; _\u2262_; cong)\nopen import Relation.Binary.PropositionalEquality.Properties\n  using (setoid)\nopen import Function.Definitions\nopen import Relation.Nullary.Negation.Core using (contraposition)\n\nimport Function.Consequences.Setoid (setoid A) (setoid B) as Setoid\n\n------------------------------------------------------------------------\n-- Re-export setoid properties\n\nopen Setoid public\n  hiding\n  ( strictlySurjective\u21d2surjective\n  ; strictlyInverse\u02e1\u21d2inverse\u02e1\n  ; strictlyInverse\u02b3\u21d2inverse\u02b3\n  )\n\n------------------------------------------------------------------------\n-- Properties that rely on congruence\n\nprivate\n  variable\n    f : A \u2192 B\n    f\u207b\u00b9 : B \u2192 A\n\nstrictlySurjective\u21d2surjective : StrictlySurjective _\u2261_ f \u2192\n                                 Surjective _\u2261_ _\u2261_ f\nstrictlySurjective\u21d2surjective =\n Setoid.strictlySurjective\u21d2surjective (cong _)\n\nstrictlyInverse\u02e1\u21d2inverse\u02e1 : \u2200 f \u2192 StrictlyInverse\u02e1 _\u2261_ f f\u207b\u00b9 \u2192\n                            Inverse\u02e1 _\u2261_ _\u2261_ f f\u207b\u00b9\nstrictlyInverse\u02e1\u21d2inverse\u02e1 f =\n  Setoid.strictlyInverse\u02e1\u21d2inverse\u02e1 (cong _)\n\nstrictlyInverse\u02b3\u21d2inverse\u02b3 : \u2200 f \u2192 StrictlyInverse\u02b3 _\u2261_ f f\u207b\u00b9 \u2192\n                            Inverse\u02b3 _\u2261_ _\u2261_ f f\u207b\u00b9\nstrictlyInverse\u02b3\u21d2inverse\u02b3 f =\n  Setoid.strictlyInverse\u02b3\u21d2inverse\u02b3 (cong _)\n</pre>"},{"location":"md/Function/Consequences/Setoid/","title":"Function.Consequences.Setoid","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Relationships between properties of functions where the equality\n-- over both the domain and codomain are assumed to be setoids.\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Bundles using (Setoid)\n\nmodule Function.Consequences.Setoid\n  {a b \u2113\u2081 \u2113\u2082}\n  (S : Setoid a \u2113\u2081)\n  (T : Setoid b \u2113\u2082)\n  where\n\nopen import Function.Definitions\nopen import Relation.Nullary.Negation.Core\n\nimport Function.Consequences as C\n\nprivate\n  open module S = Setoid S using () renaming (Carrier to A; _\u2248_ to \u2248\u2081)\n  open module T = Setoid T using () renaming (Carrier to B; _\u2248_ to \u2248\u2082)\n\n  variable\n    f : A \u2192 B\n    f\u207b\u00b9 : B \u2192 A\n\n------------------------------------------------------------------------\n-- Injective\n\ncontraInjective : Injective \u2248\u2081 \u2248\u2082 f \u2192\n                  \u2200 {x y} \u2192 \u00ac (\u2248\u2081 x y) \u2192 \u00ac (\u2248\u2082 (f x) (f y))\ncontraInjective = C.contraInjective \u2248\u2082\n\n------------------------------------------------------------------------\n-- Inverse\u02e1\n\ninverse\u02e1\u21d2surjective : Inverse\u02e1 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9 \u2192 Surjective \u2248\u2081 \u2248\u2082 f\ninverse\u02e1\u21d2surjective = C.inverse\u02e1\u21d2surjective \u2248\u2082\n\n------------------------------------------------------------------------\n-- Inverse\u02b3\n\ninverse\u02b3\u21d2injective : \u2200 f \u2192 Inverse\u02b3 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9 \u2192 Injective \u2248\u2081 \u2248\u2082 f\ninverse\u02b3\u21d2injective f = C.inverse\u02b3\u21d2injective \u2248\u2082 f T.refl S.sym S.trans\n\n------------------------------------------------------------------------\n-- Inverse\u1d47\n\ninverse\u1d47\u21d2bijective : Inverse\u1d47 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9 \u2192 Bijective \u2248\u2081 \u2248\u2082 f\ninverse\u1d47\u21d2bijective = C.inverse\u1d47\u21d2bijective \u2248\u2082 T.refl S.sym S.trans\n\n------------------------------------------------------------------------\n-- StrictlySurjective\n\nsurjective\u21d2strictlySurjective : Surjective \u2248\u2081 \u2248\u2082 f \u2192\n                                 StrictlySurjective \u2248\u2082 f\nsurjective\u21d2strictlySurjective =\n  C.surjective\u21d2strictlySurjective \u2248\u2082 S.refl\n\nstrictlySurjective\u21d2surjective : Congruent \u2248\u2081 \u2248\u2082 f \u2192\n                                 StrictlySurjective \u2248\u2082 f \u2192\n                                 Surjective \u2248\u2081 \u2248\u2082 f\nstrictlySurjective\u21d2surjective =\n  C.strictlySurjective\u21d2surjective T.trans\n\n------------------------------------------------------------------------\n-- StrictlyInverse\u02e1\n\ninverse\u02e1\u21d2strictlyInverse\u02e1 : Inverse\u02e1 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9 \u2192\n                            StrictlyInverse\u02e1 \u2248\u2082 f f\u207b\u00b9\ninverse\u02e1\u21d2strictlyInverse\u02e1 = C.inverse\u02e1\u21d2strictlyInverse\u02e1 \u2248\u2081 \u2248\u2082 S.refl\n\nstrictlyInverse\u02e1\u21d2inverse\u02e1 : Congruent \u2248\u2081 \u2248\u2082 f \u2192\n                            StrictlyInverse\u02e1 \u2248\u2082 f f\u207b\u00b9 \u2192\n                            Inverse\u02e1 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9\nstrictlyInverse\u02e1\u21d2inverse\u02e1 = C.strictlyInverse\u02e1\u21d2inverse\u02e1 T.trans\n\n------------------------------------------------------------------------\n-- StrictlyInverse\u02b3\n\ninverse\u02b3\u21d2strictlyInverse\u02b3 : Inverse\u02b3 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9 \u2192\n                            StrictlyInverse\u02b3 \u2248\u2081 f f\u207b\u00b9\ninverse\u02b3\u21d2strictlyInverse\u02b3 = C.inverse\u02b3\u21d2strictlyInverse\u02b3 \u2248\u2081 \u2248\u2082 T.refl\n\nstrictlyInverse\u02b3\u21d2inverse\u02b3 : Congruent \u2248\u2082 \u2248\u2081 f\u207b\u00b9 \u2192\n                            StrictlyInverse\u02b3 \u2248\u2081 f f\u207b\u00b9 \u2192\n                            Inverse\u02b3 \u2248\u2081 \u2248\u2082 f f\u207b\u00b9\nstrictlyInverse\u02b3\u21d2inverse\u02b3 = C.strictlyInverse\u02b3\u21d2inverse\u02b3 S.trans\n</pre>"},{"location":"md/Function/Core/","title":"Function.Core","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Core definitions for Functions\n------------------------------------------------------------------------\n\n-- The contents of this file should always be accessed from `Function`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function.Core where\n\nopen import Level using (_\u2294_)\n\n------------------------------------------------------------------------\n-- Types\n\nFun\u2081 : \u2200 {a} \u2192 Set a \u2192 Set a\nFun\u2081 A = A \u2192 A\n\nFun\u2082 : \u2200 {a} \u2192 Set a \u2192 Set a\nFun\u2082 A = A \u2192 A \u2192 A\n\n------------------------------------------------------------------------\n-- Morphism\n\nMorphism : \u2200 {a} \u2192 \u2200 {b} \u2192 Set a \u2192 Set b \u2192 Set (a \u2294 b)\nMorphism A B = A \u2192 B\n</pre>"},{"location":"md/Function/Definitions/","title":"Function.Definitions","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Definitions for types of functions.\n------------------------------------------------------------------------\n\n-- The contents of this file should usually be accessed from `Function`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function.Definitions where\n\nopen import Data.Product.Base using (\u2203; _\u00d7_)\nopen import Level using (Level)\nopen import Relation.Binary.Core using (Rel)\n\nprivate\n  variable\n    a \u2113\u2081 \u2113\u2082 : Level\n    A B : Set a\n\n------------------------------------------------------------------------\n-- Basic definitions\n\nmodule _\n  (_\u2248\u2081_ : Rel A \u2113\u2081) -- Equality over the domain\n  (_\u2248\u2082_ : Rel B \u2113\u2082) -- Equality over the codomain\n  where\n\n  Congruent : (A \u2192 B) \u2192 Set _\n  Congruent f = \u2200 {x y} \u2192 x \u2248\u2081 y \u2192 f x \u2248\u2082 f y\n\n  Injective : (A \u2192 B) \u2192 Set _\n  Injective f = \u2200 {x y} \u2192 f x \u2248\u2082 f y \u2192 x \u2248\u2081 y\n\n  Surjective : (A \u2192 B) \u2192 Set _\n  Surjective f = \u2200 y \u2192 \u2203 \u03bb x \u2192 \u2200 {z} \u2192 z \u2248\u2081 x \u2192 f z \u2248\u2082 y\n\n  Bijective : (A \u2192 B) \u2192 Set _\n  Bijective f = Injective f \u00d7 Surjective f\n\n  Inverse\u02e1 : (A \u2192 B) \u2192 (B \u2192 A) \u2192 Set _\n  Inverse\u02e1 f g = \u2200 {x y} \u2192 y \u2248\u2081 g x \u2192 f y \u2248\u2082 x\n\n  Inverse\u02b3 : (A \u2192 B) \u2192 (B \u2192 A) \u2192 Set _\n  Inverse\u02b3 f g = \u2200 {x y} \u2192 y \u2248\u2082 f x \u2192 g y \u2248\u2081 x\n\n  Inverse\u1d47 : (A \u2192 B) \u2192 (B \u2192 A) \u2192 Set _\n  Inverse\u1d47 f g = Inverse\u02e1 f g \u00d7 Inverse\u02b3 f g\n\n------------------------------------------------------------------------\n-- Strict definitions\n\n-- These are often easier to use once but much harder to compose and\n-- reason about.\n\nStrictlySurjective : Rel B \u2113\u2082 \u2192 (A \u2192 B) \u2192 Set _\nStrictlySurjective _\u2248\u2082_ f = \u2200 y \u2192 \u2203 \u03bb x \u2192 f x \u2248\u2082 y\n\nStrictlyInverse\u02e1 : Rel B \u2113\u2082 \u2192 (A \u2192 B) \u2192 (B \u2192 A) \u2192 Set _\nStrictlyInverse\u02e1 _\u2248\u2082_ f g = \u2200 y \u2192 f (g y) \u2248\u2082 y\n\nStrictlyInverse\u02b3 : Rel A \u2113\u2081 \u2192 (A \u2192 B) \u2192 (B \u2192 A) \u2192 Set _\nStrictlyInverse\u02b3 _\u2248\u2081_ f g = \u2200 x \u2192 g (f x) \u2248\u2081 x\n</pre>"},{"location":"md/Function/Strict/","title":"Function.Strict","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Strict combinators (i.e. that use call-by-value)\n------------------------------------------------------------------------\n\n-- The contents of this module is also accessible via the `Function`\n-- module.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Function.Strict where\n\nopen import Agda.Builtin.Equality using (_\u2261_)\nopen import Function.Base using (flip)\nopen import Level using (Level)\n\nprivate\n  variable\n    a b : Level\n    A B : Set a\n\ninfixl 0 _!|&gt;_ _!|&gt;\u2032_\ninfixr -1 _$!_ _$!\u2032_\n\n------------------------------------------------------------------------\n-- Dependent combinators\n\n-- These are functions whose output has a type that depends on the\n-- value of the input to the function.\n\nopen import Agda.Builtin.Strict public\n  renaming\n  ( primForce      to force\n  ; primForceLemma to force-\u2261\n  )\n\n-- Application\n_$!_ : \u2200 {A : Set a} {B : A \u2192 Set b} \u2192\n       ((x : A) \u2192 B x) \u2192 ((x : A) \u2192 B x)\nf $! x = force x f\n\n-- Flipped application\n_!|&gt;_ : \u2200 {A : Set a} {B : A \u2192 Set b} \u2192\n       (a : A) \u2192 (\u2200 a \u2192 B a) \u2192 B a\n_!|&gt;_ = flip _$!_\n\n------------------------------------------------------------------------\n-- Non-dependent combinators\n\n-- Any of the above operations for dependent functions will also work\n-- for non-dependent functions but sometimes Agda has difficulty\n-- inferring the non-dependency. Primed (\u2032 = \\prime) versions of the\n-- operations are therefore provided below that sometimes have better\n-- inference properties.\n\nseq : A \u2192 B \u2192 B\nseq a b = force a (\u03bb _ \u2192 b)\n\nseq-\u2261 : (a : A) (b : B) \u2192 seq a b \u2261 b\nseq-\u2261 a b = force-\u2261 a (\u03bb _ \u2192 b)\n\nforce\u2032 : A \u2192 (A \u2192 B) \u2192 B\nforce\u2032 = force\n\nforce\u2032-\u2261 : (a : A) (f : A \u2192 B) \u2192 force\u2032 a f \u2261 f a\nforce\u2032-\u2261 = force-\u2261\n\n-- Application\n_$!\u2032_ : (A \u2192 B) \u2192 (A \u2192 B)\n_$!\u2032_ = _$!_\n\n-- Flipped application\n_!|&gt;\u2032_ : A \u2192 (A \u2192 B) \u2192 B\n_!|&gt;\u2032_ = _!|&gt;_\n</pre>"},{"location":"md/Function/Structures/","title":"Function.Structures","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Structures for types of functions\n------------------------------------------------------------------------\n\n-- The contents of this file should usually be accessed from `Function`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.Bundles using (Setoid)\nopen import Relation.Binary.Structures using (IsEquivalence)\n\nmodule Function.Structures {a b \u2113\u2081 \u2113\u2082}\n  {A : Set a} (_\u2248\u2081_ : Rel A \u2113\u2081) -- Equality over the domain\n  {B : Set b} (_\u2248\u2082_ : Rel B \u2113\u2082) -- Equality over the codomain\n  where\n\nopen import Data.Product.Base as Product using (\u2203; _\u00d7_; _,_)\nopen import Function.Base\nopen import Function.Definitions\nopen import Level using (_\u2294_)\n\n------------------------------------------------------------------------\n-- One element structures\n------------------------------------------------------------------------\n\nrecord IsCongruent (to : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    cong           : Congruent _\u2248\u2081_ _\u2248\u2082_ to\n    isEquivalence\u2081 : IsEquivalence _\u2248\u2081_\n    isEquivalence\u2082 : IsEquivalence _\u2248\u2082_\n\n  module Eq\u2081 where\n\n    setoid : Setoid a \u2113\u2081\n    setoid = record\n      { isEquivalence = isEquivalence\u2081\n      }\n\n    open Setoid setoid public\n\n  module Eq\u2082 where\n\n    setoid : Setoid b \u2113\u2082\n    setoid = record\n      { isEquivalence = isEquivalence\u2082\n      }\n\n    open Setoid setoid public\n\n\nrecord IsInjection (to : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isCongruent : IsCongruent to\n    injective   : Injective _\u2248\u2081_ _\u2248\u2082_ to\n\n  open IsCongruent isCongruent public\n\n\nrecord IsSurjection (f : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isCongruent : IsCongruent f\n    surjective  : Surjective _\u2248\u2081_ _\u2248\u2082_ f\n\n  open IsCongruent isCongruent public\n\n  strictlySurjective : StrictlySurjective _\u2248\u2082_ f\n  strictlySurjective x = Product.map\u2082 (\u03bb v \u2192 v Eq\u2081.refl) (surjective x)\n\n\nrecord IsBijection (f : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isInjection : IsInjection f\n    surjective  : Surjective _\u2248\u2081_ _\u2248\u2082_ f\n\n  open IsInjection isInjection public\n\n  bijective : Bijective _\u2248\u2081_ _\u2248\u2082_ f\n  bijective = injective , surjective\n\n  isSurjection : IsSurjection f\n  isSurjection = record\n    { isCongruent = isCongruent\n    ; surjective  = surjective\n    }\n\n  open IsSurjection isSurjection public\n    using (strictlySurjective)\n\n\n------------------------------------------------------------------------\n-- Two element structures\n------------------------------------------------------------------------\n\nrecord IsLeftInverse (to : A \u2192 B) (from : B \u2192 A) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isCongruent  : IsCongruent to\n    from-cong    : Congruent _\u2248\u2082_ _\u2248\u2081_ from\n    inverse\u02e1     : Inverse\u02e1 _\u2248\u2081_ _\u2248\u2082_ to from\n\n  open IsCongruent isCongruent public\n    renaming (cong to to-cong)\n\n  strictlyInverse\u02e1 : StrictlyInverse\u02e1 _\u2248\u2082_ to from\n  strictlyInverse\u02e1 x = inverse\u02e1 Eq\u2081.refl\n\n  isSurjection : IsSurjection to\n  isSurjection = record\n    { isCongruent = isCongruent\n    ; surjective = \u03bb y \u2192 from y , inverse\u02e1\n    }\n\n\nrecord IsRightInverse (to : A \u2192 B) (from : B \u2192 A) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isCongruent : IsCongruent to\n    from-cong   : Congruent _\u2248\u2082_ _\u2248\u2081_ from\n    inverse\u02b3    : Inverse\u02b3 _\u2248\u2081_ _\u2248\u2082_ to from\n\n  open IsCongruent isCongruent public\n    renaming (cong to to-cong)\n\n  strictlyInverse\u02b3 : StrictlyInverse\u02b3 _\u2248\u2081_ to from\n  strictlyInverse\u02b3 x = inverse\u02b3 Eq\u2082.refl\n\n\nrecord IsInverse (to : A \u2192 B) (from : B \u2192 A) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isLeftInverse : IsLeftInverse to from\n    inverse\u02b3      : Inverse\u02b3 _\u2248\u2081_ _\u2248\u2082_ to from\n\n  open IsLeftInverse isLeftInverse public\n\n  isRightInverse : IsRightInverse to from\n  isRightInverse = record\n    { isCongruent = isCongruent\n    ; from-cong   = from-cong\n    ; inverse\u02b3    = inverse\u02b3\n    }\n\n  open IsRightInverse isRightInverse public\n    using (strictlyInverse\u02b3)\n\n  inverse : Inverse\u1d47 _\u2248\u2081_ _\u2248\u2082_ to from\n  inverse = inverse\u02e1 , inverse\u02b3\n\n\n------------------------------------------------------------------------\n-- Three element structures\n------------------------------------------------------------------------\n\nrecord IsBiEquivalence\n  (to : A \u2192 B) (from\u2081 : B \u2192 A) (from\u2082 : B \u2192 A) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    to-isCongruent : IsCongruent to\n    from\u2081-cong    : Congruent _\u2248\u2082_ _\u2248\u2081_ from\u2081\n    from\u2082-cong    : Congruent _\u2248\u2082_ _\u2248\u2081_ from\u2082\n\n  open IsCongruent to-isCongruent public\n    renaming (cong to to-cong\u2081)\n\n\nrecord IsBiInverse\n  (to : A \u2192 B) (from\u2081 : B \u2192 A) (from\u2082 : B \u2192 A) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    to-isCongruent : IsCongruent to\n    from\u2081-cong     : Congruent _\u2248\u2082_ _\u2248\u2081_ from\u2081\n    from\u2082-cong     : Congruent _\u2248\u2082_ _\u2248\u2081_ from\u2082\n    inverse\u02e1       : Inverse\u02e1 _\u2248\u2081_ _\u2248\u2082_ to from\u2081\n    inverse\u02b3       : Inverse\u02b3 _\u2248\u2081_ _\u2248\u2082_ to from\u2082\n\n  open IsCongruent to-isCongruent public\n    renaming (cong to to-cong)\n\n\n------------------------------------------------------------------------\n-- Other\n------------------------------------------------------------------------\n\n-- See the comment on `SplitSurjection` in `Function.Bundles` for an\n-- explanation of (split) surjections.\nrecord IsSplitSurjection (f : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    from : B \u2192 A\n    isLeftInverse : IsLeftInverse f from\n\n  open IsLeftInverse isLeftInverse public\n</pre>"},{"location":"md/Function/Structures/Biased/","title":"Function.Structures.Biased","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Ways to give instances of certain structures where some fields can\n-- be given in terms of others.\n-- The contents of this file should usually be accessed from `Function`.\n------------------------------------------------------------------------\n\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.Bundles using (Setoid)\nopen import Relation.Binary.Structures using (IsEquivalence)\n\nmodule Function.Structures.Biased {a b \u2113\u2081 \u2113\u2082}\n  {A : Set a} (_\u2248\u2081_ : Rel A \u2113\u2081) -- Equality over the domain\n  {B : Set b} (_\u2248\u2082_ : Rel B \u2113\u2082) -- Equality over the codomain\n  where\n\nopen import Data.Product.Base as Product using (\u2203; _\u00d7_; _,_)\nopen import Function.Base\nopen import Function.Definitions\nopen import Function.Structures _\u2248\u2081_ _\u2248\u2082_\nopen import Function.Consequences.Setoid\nopen import Level using (_\u2294_)\n\n------------------------------------------------------------------------\n-- Surjection\n------------------------------------------------------------------------\n\nrecord IsStrictSurjection (f : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isCongruent : IsCongruent f\n    strictlySurjective : StrictlySurjective _\u2248\u2082_ f\n\n  open IsCongruent isCongruent public\n\n  isSurjection : IsSurjection f\n  isSurjection = record\n    { isCongruent = isCongruent\n    ; surjective = strictlySurjective\u21d2surjective\n        Eq\u2081.setoid Eq\u2082.setoid cong strictlySurjective\n    }\n\nopen IsStrictSurjection public\n  using () renaming (isSurjection to isStrictSurjection)\n\n------------------------------------------------------------------------\n-- Bijection\n------------------------------------------------------------------------\n\nrecord IsStrictBijection (f : A \u2192 B) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isInjection : IsInjection f\n    strictlySurjective  : StrictlySurjective _\u2248\u2082_ f\n\n  isBijection : IsBijection f\n  isBijection = record\n    { isInjection = isInjection\n    ; surjective = strictlySurjective\u21d2surjective\n        Eq\u2081.setoid Eq\u2082.setoid cong strictlySurjective\n    } where open IsInjection isInjection\n\nopen IsStrictBijection public\n  using () renaming (isBijection to isStrictBijection)\n\n------------------------------------------------------------------------\n-- Left inverse\n------------------------------------------------------------------------\n\nrecord IsStrictLeftInverse (to : A \u2192 B) (from : B \u2192 A) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isCongruent  : IsCongruent to\n    from-cong    : Congruent _\u2248\u2082_ _\u2248\u2081_ from\n    strictlyInverse\u02e1 : StrictlyInverse\u02e1 _\u2248\u2082_ to from\n\n  isLeftInverse : IsLeftInverse to from\n  isLeftInverse = record\n    { isCongruent = isCongruent\n    ; from-cong = from-cong\n    ; inverse\u02e1 = strictlyInverse\u02e1\u21d2inverse\u02e1\n        Eq\u2081.setoid Eq\u2082.setoid cong strictlyInverse\u02e1\n    } where open IsCongruent isCongruent\n\nopen IsStrictLeftInverse public\n  using () renaming (isLeftInverse to isStrictLeftInverse)\n\n------------------------------------------------------------------------\n-- Right inverse\n------------------------------------------------------------------------\n\nrecord IsStrictRightInverse (to : A \u2192 B) (from : B \u2192 A) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isCongruent : IsCongruent to\n    from-cong   : Congruent _\u2248\u2082_ _\u2248\u2081_ from\n    strictlyInverse\u02b3 : StrictlyInverse\u02b3 _\u2248\u2081_ to from\n\n  isRightInverse : IsRightInverse to from\n  isRightInverse = record\n    { isCongruent = isCongruent\n    ; from-cong = from-cong\n    ; inverse\u02b3 = strictlyInverse\u02b3\u21d2inverse\u02b3\n        Eq\u2081.setoid Eq\u2082.setoid from-cong strictlyInverse\u02b3\n    } where open IsCongruent isCongruent\n\nopen IsStrictRightInverse public\n  using () renaming (isRightInverse to isStrictRightInverse)\n\n------------------------------------------------------------------------\n-- Inverse\n------------------------------------------------------------------------\n\nrecord IsStrictInverse (to : A \u2192 B) (from : B \u2192 A) : Set (a \u2294 b \u2294 \u2113\u2081 \u2294 \u2113\u2082) where\n  field\n    isLeftInverse : IsLeftInverse to from\n    strictlyInverse\u02b3 : StrictlyInverse\u02b3 _\u2248\u2081_ to from\n\n  isInverse : IsInverse to from\n  isInverse = record\n    { isLeftInverse = isLeftInverse\n    ; inverse\u02b3      = strictlyInverse\u02b3\u21d2inverse\u02b3\n        Eq\u2081.setoid Eq\u2082.setoid from-cong strictlyInverse\u02b3\n    } where open IsLeftInverse isLeftInverse\n\nopen IsStrictInverse public\n  using () renaming (isInverse to isStrictInverse)\n</pre>"},{"location":"md/Level/","title":"Level","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Universe levels\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Level where\n\n-- Levels.\n\nopen import Agda.Primitive as Prim public\n  using    (Level; _\u2294_; Set\u03c9)\n  renaming (lzero to zero; lsuc to suc)\n\n-- Lifting.\n\nrecord Lift {a} \u2113 (A : Set a) : Set (a \u2294 \u2113) where\n  constructor lift\n  field lower : A\n\nopen Lift public\n\n-- Synonyms\n\n0\u2113 : Level\n0\u2113 = zero\n\nlevelOfType : \u2200 {a} \u2192 Set a \u2192 Level\nlevelOfType {a} _ = a\n\nlevelOfTerm : \u2200 {a} {A : Set a} \u2192 A \u2192 Level\nlevelOfTerm {a} _ = a\n</pre>"},{"location":"md/Library/","title":"Library","text":"<pre>\nmodule Library where\n</pre> <p>The Agda library modules imported (also transitively) by non-library modules are automatically included.</p>"},{"location":"md/Notation/","title":"Notation","text":"<pre>\nmodule Notation where\n\nopen import Data.Bool.Base    using (Bool; false; true) public\nopen import Data.Nat.Base     renaming (\u2115 to Nat) using (suc) public\nopen import Data.String.Base  using (String) public\nopen import Data.Unit.Base    using (\u22a4)\nopen import Function          using (id; _\u2218_) public\n\nDomain = Set -- unsound!\n\nvariable\n  A B C  : Set\n  D E F  : Domain\n  n      : Nat\n\n------------------------------------------------------------------------\n-- Domains\n\npostulate\n  \u22a5 : D              -- bottom element\n  fix : (D \u2192 D) \u2192 D  -- fixed point of endofunction\n\n------------------------------------------------------------------------\n-- Flat domains\n\npostulate\n  _+\u22a5    : Set \u2192 Domain          -- lifted set\n  \u03b7      : A \u2192 A +\u22a5              -- inclusion\n  _\u266f     : (A \u2192 D) \u2192 (A +\u22a5 \u2192 D)  -- Kleisli extension\n\nBool\u22a5    = Bool +\u22a5               -- truth value domain\nNat\u22a5     = Nat +\u22a5                -- natural number domain\nString\u22a5  = String +\u22a5             -- meta-string domain\n\npostulate\n  _==\u22a5_  : Nat\u22a5 \u2192 Nat \u2192 Bool\u22a5    -- strict numerical equality\n  _\u27f6_,_  : Bool\u22a5 \u2192 D \u2192 D \u2192 D     -- McCarthy conditional\n\n------------------------------------------------------------------------\n-- Sum domains\n\npostulate\n  _+_    : Domain \u2192 Domain \u2192 Domain         -- separated sum\n  inj\u2081   : D \u2192 D + E                        -- injection\n  inj\u2082   : E \u2192 D + E                        -- injection\n  [_,_]  : (D \u2192 F) \u2192 (E \u2192 F) \u2192 (D + E \u2192 F)  -- case analysis\n\n------------------------------------------------------------------------\n-- Product domains\n\npostulate\n  _\u00d7_  : Domain \u2192 Domain \u2192 Domain  -- cartesian product\n  _,_  : D \u2192 E \u2192 D \u00d7 E             -- pairing\n  _\u21931  : D \u00d7 E \u2192 D                 -- projection\n  _\u21932  : D \u00d7 E \u2192 E                 -- projection\n\n------------------------------------------------------------------------\n-- Tuple domains\n\n_^_ : Domain \u2192 Nat \u2192 Domain   -- D ^ n               n-tuples\nD ^ 0            = \u22a4\nD ^ 1            = D\nD ^ suc (suc n)  = D \u00d7 (D ^ suc n)\n\n------------------------------------------------------------------------\n-- Finite sequence domains\n\npostulate\n  _\u22c6     : Domain \u2192 Domain    -- D \u22c6 domain of finite sequences \n  \u27e8\u27e9     : D \u22c6                -- empty sequence\n  \u27e8_\u27e9    : (D ^ suc n) \u2192 D \u22c6  -- \u27e8 d\u2081 , ... , d\u2099\u208a\u2081 \u27e9 non-empty sequence\n  #      : D \u22c6 \u2192 Nat\u22a5         -- # d\u22c6                sequence length\n  _\u00a7_    : D \u22c6 \u2192 D \u22c6 \u2192 D \u22c6    -- d\u22c6 \u00a7 d\u22c6             concatenation\n  _\u2193_    : D \u22c6 \u2192 Nat \u2192 D      -- d\u22c6 \u2193 n              nth component\n  _\u2020_    : D \u22c6 \u2192 Nat \u2192 D \u22c6    -- d\u22c6 \u2020 n              nth tail\n\n------------------------------------------------------------------------\n-- Grouping precedence\n\ninfixr 1   _+_\ninfixr 2   _\u00d7_\ninfixr 4   _,_\ninfix  8   _^_\ninfixr 20  _\u27f6_,_\n\n\u27e6_\u27e7 = id\n</pre>"},{"location":"md/Relation/Binary/Bundles/","title":"Relation.Binary.Bundles","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Bundles for homogeneous binary relations\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via `Relation.Binary`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Bundles where\n\nopen import Function.Base using (flip)\nopen import Level using (Level; suc; _\u2294_)\nopen import Relation.Nullary.Negation.Core using (\u00ac_)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Binary.Bundles.Raw\nopen import Relation.Binary.Structures -- most of it\n\n------------------------------------------------------------------------\n-- Setoids\n------------------------------------------------------------------------\n\nrecord PartialSetoid a \u2113 : Set (suc (a \u2294 \u2113)) where\n  infix 4 _\u2248_\n  field\n    Carrier              : Set a\n    _\u2248_                  : Rel Carrier \u2113\n    isPartialEquivalence : IsPartialEquivalence _\u2248_\n\n  open IsPartialEquivalence isPartialEquivalence public\n\n  rawSetoid : RawSetoid _ _\n  rawSetoid = record { _\u2248_ = _\u2248_ }\n\n  open RawSetoid rawSetoid public\n    hiding (Carrier; _\u2248_ )\n\n\nrecord Setoid c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix 4 _\u2248_\n  field\n    Carrier       : Set c\n    _\u2248_           : Rel Carrier \u2113\n    isEquivalence : IsEquivalence _\u2248_\n\n  open IsEquivalence isEquivalence public\n    using (refl; reflexive; isPartialEquivalence)\n\n  partialSetoid : PartialSetoid c \u2113\n  partialSetoid = record\n    { isPartialEquivalence = isPartialEquivalence\n    }\n\n  open PartialSetoid partialSetoid public\n    hiding (Carrier; _\u2248_; isPartialEquivalence)\n\n\nrecord DecSetoid c \u2113 : Set (suc (c \u2294 \u2113)) where\n  infix 4 _\u2248_\n  field\n    Carrier          : Set c\n    _\u2248_              : Rel Carrier \u2113\n    isDecEquivalence : IsDecEquivalence _\u2248_\n\n  open IsDecEquivalence isDecEquivalence public\n    using (_\u225f_; isEquivalence)\n\n  setoid : Setoid c \u2113\n  setoid = record\n    { isEquivalence = isEquivalence\n    }\n\n  open Setoid setoid public\n    hiding (Carrier; _\u2248_; isEquivalence)\n\n------------------------------------------------------------------------\n-- Preorders\n------------------------------------------------------------------------\n\nrecord Preorder c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _\u2272_\n  field\n    Carrier    : Set c\n    _\u2248_        : Rel Carrier \u2113\u2081  -- The underlying equality.\n    _\u2272_        : Rel Carrier \u2113\u2082  -- The relation.\n    isPreorder : IsPreorder _\u2248_ _\u2272_\n\n  open IsPreorder isPreorder public\n    hiding (module Eq)\n\n  module Eq where\n    setoid : Setoid c \u2113\u2081\n    setoid = record\n      { isEquivalence = isEquivalence\n      }\n\n    open Setoid setoid public\n\n  rawRelation : RawRelation _ _ _\n  rawRelation = record { _\u2248_ = _\u2248_ ; _\u223c_ = _\u2272_ }\n\n  open RawRelation rawRelation public\n    renaming (_\u2241_ to _\u22e6_; _\u223c\u1d52_ to _\u2273_; _\u2241\u1d52_ to _\u22e7_)\n    hiding (Carrier; _\u2248_)\n  -- Deprecated.\n  {-# WARNING_ON_USAGE _\u223c_\n  \"Warning: _\u223c_ was deprecated in v2.0.\n  Please use _\u2272_ instead. \"\n  #-}\n\n\nrecord TotalPreorder c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _\u2272_\n  field\n    Carrier         : Set c\n    _\u2248_             : Rel Carrier \u2113\u2081  -- The underlying equality.\n    _\u2272_             : Rel Carrier \u2113\u2082  -- The relation.\n    isTotalPreorder : IsTotalPreorder _\u2248_ _\u2272_\n\n  open IsTotalPreorder isTotalPreorder public\n    using (total; isPreorder)\n\n  preorder : Preorder c \u2113\u2081 \u2113\u2082\n  preorder = record\n    { isPreorder = isPreorder\n    }\n\n  open Preorder preorder public\n    hiding (Carrier; _\u2248_; _\u2272_; isPreorder)\n\n\nrecord DecPreorder c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  field\n    Carrier         : Set c\n    _\u2248_             : Rel Carrier \u2113\u2081  -- The underlying equality.\n    _\u2272_             : Rel Carrier \u2113\u2082  -- The relation.\n    isDecPreorder   : IsDecPreorder _\u2248_ _\u2272_\n\n  private module DPO = IsDecPreorder isDecPreorder\n\n  open DPO public\n    using (_\u225f_; _\u2272?_; isPreorder)\n\n  preorder : Preorder c \u2113\u2081 \u2113\u2082\n  preorder = record\n    { isPreorder = isPreorder\n    }\n\n  open Preorder preorder public\n    hiding (Carrier; _\u2248_; _\u2272_; isPreorder; module Eq)\n\n  module Eq where\n    decSetoid : DecSetoid c \u2113\u2081\n    decSetoid = record\n      { isDecEquivalence = DPO.Eq.isDecEquivalence\n      }\n\n    open DecSetoid decSetoid public\n\n\n------------------------------------------------------------------------\n-- Partial orders\n------------------------------------------------------------------------\n\nrecord Poset c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _\u2264_\n  field\n    Carrier        : Set c\n    _\u2248_            : Rel Carrier \u2113\u2081\n    _\u2264_            : Rel Carrier \u2113\u2082\n    isPartialOrder : IsPartialOrder _\u2248_ _\u2264_\n\n  open IsPartialOrder isPartialOrder public\n    using (antisym; isPreorder)\n\n  preorder : Preorder c \u2113\u2081 \u2113\u2082\n  preorder = record\n    { isPreorder = isPreorder\n    }\n\n  open Preorder preorder public\n    hiding (Carrier; _\u2248_; _\u2272_; isPreorder; _\u22e6_; _\u2273_; _\u22e7_)\n    renaming\n    ( \u2272-resp\u02e1-\u2248 to \u2264-resp\u02e1-\u2248\n    ; \u2272-resp\u02b3-\u2248 to \u2264-resp\u02b3-\u2248\n    ; \u2272-resp-\u2248  to \u2264-resp-\u2248\n    )\n\n  open RawRelation rawRelation public\n    renaming (_\u2241_ to _\u2270_; _\u223c\u1d52_ to _\u2265_; _\u2241\u1d52_ to _\u2271_)\n    hiding (Carrier; _\u2248_ ; _\u223c_; _\u2249_; rawSetoid)\n\n\nrecord DecPoset c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _\u2264_\n  field\n    Carrier           : Set c\n    _\u2248_               : Rel Carrier \u2113\u2081\n    _\u2264_               : Rel Carrier \u2113\u2082\n    isDecPartialOrder : IsDecPartialOrder _\u2248_ _\u2264_\n\n  private module DPO = IsDecPartialOrder isDecPartialOrder\n\n  open DPO public\n    using (_\u225f_; _\u2264?_; isPartialOrder; isDecPreorder)\n\n  poset : Poset c \u2113\u2081 \u2113\u2082\n  poset = record\n    { isPartialOrder = isPartialOrder\n    }\n\n  open Poset poset public\n    hiding (Carrier; _\u2248_; _\u2264_; isPartialOrder; module Eq)\n\n  decPreorder : DecPreorder c \u2113\u2081 \u2113\u2082\n  decPreorder = record { isDecPreorder = isDecPreorder }\n\n  open DecPreorder decPreorder public\n    using (module Eq)\n\n\nrecord StrictPartialOrder c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _&lt;_\n  field\n    Carrier              : Set c\n    _\u2248_                  : Rel Carrier \u2113\u2081\n    _&lt;_                  : Rel Carrier \u2113\u2082\n    isStrictPartialOrder : IsStrictPartialOrder _\u2248_ _&lt;_\n\n  open IsStrictPartialOrder isStrictPartialOrder public\n    hiding (module Eq)\n\n  module Eq where\n    setoid : Setoid c \u2113\u2081\n    setoid = record\n      { isEquivalence = isEquivalence\n      }\n\n    open Setoid setoid public\n\n  rawRelation : RawRelation _ _ _\n  rawRelation = record { _\u2248_ = _\u2248_ ; _\u223c_ = _&lt;_ }\n\n  open RawRelation rawRelation public\n    renaming (_\u2241_ to _\u226e_; _\u223c\u1d52_ to _&gt;_; _\u2241\u1d52_ to _\u226f_)\n    hiding (Carrier; _\u2248_ ; _\u223c_)\n\n\nrecord DecStrictPartialOrder c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _&lt;_\n  field\n    Carrier                 : Set c\n    _\u2248_                     : Rel Carrier \u2113\u2081\n    _&lt;_                     : Rel Carrier \u2113\u2082\n    isDecStrictPartialOrder : IsDecStrictPartialOrder _\u2248_ _&lt;_\n\n  private module DSPO = IsDecStrictPartialOrder isDecStrictPartialOrder\n\n  open DSPO public\n    using (_&lt;?_; _\u225f_; isStrictPartialOrder)\n\n  strictPartialOrder : StrictPartialOrder c \u2113\u2081 \u2113\u2082\n  strictPartialOrder = record\n    { isStrictPartialOrder = isStrictPartialOrder\n    }\n\n  open StrictPartialOrder strictPartialOrder public\n    hiding (Carrier; _\u2248_; _&lt;_; isStrictPartialOrder; module Eq)\n\n  module Eq where\n\n    decSetoid : DecSetoid c \u2113\u2081\n    decSetoid = record\n      { isDecEquivalence = DSPO.Eq.isDecEquivalence\n      }\n\n    open DecSetoid decSetoid public\n\n\n------------------------------------------------------------------------\n-- Total orders\n------------------------------------------------------------------------\n\nrecord TotalOrder c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _\u2264_\n  field\n    Carrier      : Set c\n    _\u2248_          : Rel Carrier \u2113\u2081\n    _\u2264_          : Rel Carrier \u2113\u2082\n    isTotalOrder : IsTotalOrder _\u2248_ _\u2264_\n\n  open IsTotalOrder isTotalOrder public\n    using (total; isPartialOrder; isTotalPreorder)\n\n  poset : Poset c \u2113\u2081 \u2113\u2082\n  poset = record\n    { isPartialOrder = isPartialOrder\n    }\n\n  open Poset poset public\n    hiding (Carrier; _\u2248_; _\u2264_; isPartialOrder)\n\n  totalPreorder : TotalPreorder c \u2113\u2081 \u2113\u2082\n  totalPreorder = record\n    { isTotalPreorder = isTotalPreorder\n    }\n\n\nrecord DecTotalOrder c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _\u2264_\n  field\n    Carrier         : Set c\n    _\u2248_             : Rel Carrier \u2113\u2081\n    _\u2264_             : Rel Carrier \u2113\u2082\n    isDecTotalOrder : IsDecTotalOrder _\u2248_ _\u2264_\n\n  private module DTO = IsDecTotalOrder isDecTotalOrder\n\n  open DTO public\n    using (_\u225f_; _\u2264?_; isTotalOrder; isDecPartialOrder)\n\n  totalOrder : TotalOrder c \u2113\u2081 \u2113\u2082\n  totalOrder = record\n    { isTotalOrder = isTotalOrder\n    }\n\n  open TotalOrder totalOrder public\n    hiding (Carrier; _\u2248_; _\u2264_; isTotalOrder; module Eq)\n\n  decPoset : DecPoset c \u2113\u2081 \u2113\u2082\n  decPoset = record\n    { isDecPartialOrder = isDecPartialOrder\n    }\n\n  open DecPoset decPoset public\n    using (module Eq)\n\n\n-- Note that these orders are decidable. The current implementation\n-- of `Trichotomous` subsumes irreflexivity and asymmetry. Any reasonable\n-- definition capturing these three properties implies decidability\n-- as `Trichotomous` necessarily separates out the equality case.\n\nrecord StrictTotalOrder c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _&lt;_\n  field\n    Carrier            : Set c\n    _\u2248_                : Rel Carrier \u2113\u2081\n    _&lt;_                : Rel Carrier \u2113\u2082\n    isStrictTotalOrder : IsStrictTotalOrder _\u2248_ _&lt;_\n\n  open IsStrictTotalOrder isStrictTotalOrder public\n    using\n    ( _\u225f_; _&lt;?_; compare; isStrictPartialOrder\n    ; isDecStrictPartialOrder; isDecEquivalence\n    )\n\n  strictPartialOrder : StrictPartialOrder c \u2113\u2081 \u2113\u2082\n  strictPartialOrder = record\n    { isStrictPartialOrder = isStrictPartialOrder\n    }\n\n  open StrictPartialOrder strictPartialOrder public\n    hiding (Carrier; _\u2248_; _&lt;_; isStrictPartialOrder; module Eq)\n\n  decStrictPartialOrder : DecStrictPartialOrder c \u2113\u2081 \u2113\u2082\n  decStrictPartialOrder = record\n    { isDecStrictPartialOrder = isDecStrictPartialOrder\n    }\n\n  open DecStrictPartialOrder decStrictPartialOrder public\n    using (module Eq)\n\n  decSetoid : DecSetoid c \u2113\u2081\n  decSetoid = record\n    { isDecEquivalence = Eq.isDecEquivalence\n    }\n  {-# WARNING_ON_USAGE decSetoid\n  \"Warning: decSetoid was deprecated in v1.3.\n  Please use Eq.decSetoid instead.\"\n  #-}\n\n\nrecord DenseLinearOrder c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _&lt;_\n  field\n    Carrier            : Set c\n    _\u2248_                : Rel Carrier \u2113\u2081\n    _&lt;_                : Rel Carrier \u2113\u2082\n    isDenseLinearOrder : IsDenseLinearOrder _\u2248_ _&lt;_\n\n  open IsDenseLinearOrder isDenseLinearOrder public\n    using (isStrictTotalOrder; dense)\n\n  strictTotalOrder : StrictTotalOrder c \u2113\u2081 \u2113\u2082\n  strictTotalOrder = record\n    { isStrictTotalOrder = isStrictTotalOrder\n    }\n\n  open StrictTotalOrder strictTotalOrder public\n    hiding (Carrier; _\u2248_; _&lt;_; isStrictTotalOrder)\n\n\n------------------------------------------------------------------------\n-- Apartness relations\n------------------------------------------------------------------------\n\nrecord ApartnessRelation c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _#_\n  field\n    Carrier             : Set c\n    _\u2248_                 : Rel Carrier \u2113\u2081\n    _#_                 : Rel Carrier \u2113\u2082\n    isApartnessRelation : IsApartnessRelation _\u2248_ _#_\n\n  open IsApartnessRelation isApartnessRelation public\n    hiding (_\u00ac#_)\n\n  rawRelation : RawRelation _ _ _\n  rawRelation = record { _\u2248_ = _\u2248_ ; _\u223c_ = _#_ }\n\n  open RawRelation rawRelation public\n    renaming (_\u2241_ to _\u00ac#_; _\u223c\u1d52_ to _#\u1d52_; _\u2241\u1d52_ to _\u00ac#\u1d52_)\n    hiding (Carrier; _\u2248_ ; _\u223c_)\n\n</pre>"},{"location":"md/Relation/Binary/Bundles/Raw/","title":"Relation.Binary.Bundles.Raw","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Raw bundles for homogeneous binary relations\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via `Relation.Binary`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Bundles.Raw where\n\nopen import Function.Base using (flip)\nopen import Level using (Level; suc; _\u2294_)\nopen import Relation.Binary.Core using (Rel)\nopen import Relation.Nullary.Negation.Core using (\u00ac_)\n\n\n------------------------------------------------------------------------\n-- RawSetoid\n------------------------------------------------------------------------\n\nrecord RawSetoid a \u2113 : Set (suc (a \u2294 \u2113)) where\n  infix 4 _\u2248_\n  field\n    Carrier              : Set a\n    _\u2248_                  : Rel Carrier \u2113\n\n  infix 4 _\u2249_\n  _\u2249_ : Rel Carrier _\n  x \u2249 y = \u00ac (x \u2248 y)\n\n\n------------------------------------------------------------------------\n-- RawRelation: basis for Relation.Binary.Bundles.*Order\n------------------------------------------------------------------------\n\nrecord RawRelation c \u2113\u2081 \u2113\u2082 : Set (suc (c \u2294 \u2113\u2081 \u2294 \u2113\u2082)) where\n  infix 4 _\u2248_ _\u223c_\n  field\n    Carrier    : Set c\n    _\u2248_        : Rel Carrier \u2113\u2081  -- The underlying equality.\n    _\u223c_        : Rel Carrier \u2113\u2082  -- The underlying relation.\n\n  rawSetoid : RawSetoid c \u2113\u2081\n  rawSetoid = record { _\u2248_ = _\u2248_ }\n\n  open RawSetoid rawSetoid public\n    using (_\u2249_)\n\n  infix 4 _\u2241_\n  _\u2241_ : Rel Carrier _\n  x \u2241 y = \u00ac (x \u223c y)\n\n  infix 4 _\u223c\u1d52_\n  _\u223c\u1d52_ = flip _\u223c_\n\n  infix 4 _\u2241\u1d52_\n  _\u2241\u1d52_ = flip _\u2241_\n\n</pre>"},{"location":"md/Relation/Binary/Consequences/","title":"Relation.Binary.Consequences","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Some properties imply others\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Consequences where\n\nopen import Data.Empty using (\u22a5-elim)\nopen import Data.Product.Base using (_,_)\nopen import Data.Sum.Base as Sum using (inj\u2081; inj\u2082; [_,_]\u2032)\nopen import Function.Base using (_\u2218_; _\u2218\u2082_; _$_; flip)\nopen import Level using (Level)\nopen import Relation.Binary.Core\nopen import Relation.Binary.Definitions\nopen import Relation.Nullary.Negation.Core using (\u00ac_)\nopen import Relation.Nullary.Decidable.Core\n  using (yes; no; recompute; map\u2032; dec\u21d2maybe)\nopen import Relation.Unary using (\u2201; Pred)\n\nprivate\n  variable\n    a \u2113 \u2113\u2081 \u2113\u2082 \u2113\u2083 \u2113\u2084 p : Level\n    A B : Set a\n\n------------------------------------------------------------------------\n-- Substitutive properties\n\nmodule _ {_\u223c_ : Rel A \u2113} (R : Rel A p) where\n\n  subst\u21d2resp\u02e1 : Substitutive _\u223c_ p \u2192 R Respects\u02e1 _\u223c_\n  subst\u21d2resp\u02e1 subst {y} x\u2032\u223cx Px\u2032y = subst (flip R y) x\u2032\u223cx Px\u2032y\n\n  subst\u21d2resp\u02b3 : Substitutive _\u223c_ p \u2192 R Respects\u02b3 _\u223c_\n  subst\u21d2resp\u02b3 subst {x} y\u2032\u223cy Pxy\u2032 = subst (R x) y\u2032\u223cy Pxy\u2032\n\n  subst\u21d2resp\u2082 : Substitutive _\u223c_ p \u2192 R Respects\u2082 _\u223c_\n  subst\u21d2resp\u2082 subst = subst\u21d2resp\u02b3 subst , subst\u21d2resp\u02e1 subst\n\nmodule _ {_\u223c_ : Rel A \u2113} {P : Pred A p} where\n\n  resp\u21d2\u00ac-resp : Symmetric _\u223c_ \u2192 P Respects _\u223c_ \u2192 (\u2201 P) Respects _\u223c_\n  resp\u21d2\u00ac-resp sym resp x\u223cy \u00acPx Py = \u00acPx (resp (sym x\u223cy) Py)\n\n------------------------------------------------------------------------\n-- Proofs for negation\n\nmodule _ {_\u223c_ : Rel A \u2113} where\n\n  sym\u21d2\u00ac-sym : Symmetric _\u223c_ \u2192 Symmetric (\u00ac_ \u2218\u2082 _\u223c_)\n  sym\u21d2\u00ac-sym sym\u2241 x\u2241y y\u223cx = x\u2241y (sym\u2241 y\u223cx)\n\n  -- N.B. the implicit arguments to Cotransitive are permuted w.r.t.\n  -- those of Transitive\n  cotrans\u21d2\u00ac-trans : Cotransitive _\u223c_ \u2192 Transitive (\u00ac_ \u2218\u2082 _\u223c_)\n  cotrans\u21d2\u00ac-trans cotrans {j = z} x\u2241z z\u2241y x\u223cy =\n    [ x\u2241z , z\u2241y ]\u2032 (cotrans x\u223cy z)\n\n------------------------------------------------------------------------\n-- Proofs for Irreflexive relations\n\nmodule _ {_\u2248_ : Rel A \u2113\u2081} {_\u223c_ : Rel A \u2113\u2082} where\n\n  irrefl\u21d2\u00ac-refl : Reflexive _\u2248_ \u2192 Irreflexive _\u2248_ _\u223c_ \u2192\n                  Reflexive (\u00ac_ \u2218\u2082 _\u223c_)\n  irrefl\u21d2\u00ac-refl re irr = irr re\n\n------------------------------------------------------------------------\n-- Proofs for non-strict orders\n\nmodule _ {_\u2248_ : Rel A \u2113\u2081} {_\u2264_ : Rel A \u2113\u2082} where\n\n  total\u21d2refl : _\u2264_ Respects\u2082 _\u2248_ \u2192 Symmetric _\u2248_ \u2192\n               Total _\u2264_ \u2192 _\u2248_ \u21d2 _\u2264_\n  total\u21d2refl (resp\u02b3 , resp\u02e1) sym total {x} {y} x\u2248y with total x y\n  ... | inj\u2081 x\u223cy = x\u223cy\n  ... | inj\u2082 y\u223cx = resp\u02b3 x\u2248y (resp\u02e1 (sym x\u2248y) y\u223cx)\n\n  total\u2227dec\u21d2dec : _\u2248_ \u21d2 _\u2264_ \u2192 Antisymmetric _\u2248_ _\u2264_ \u2192\n                  Total _\u2264_ \u2192 Decidable _\u2248_ \u2192 Decidable _\u2264_\n  total\u2227dec\u21d2dec refl antisym total _\u225f_ x y with total x y\n  ... | inj\u2081 x\u2264y = yes x\u2264y\n  ... | inj\u2082 y\u2264x = map\u2032 refl (flip antisym y\u2264x) (x \u225f y)\n\nmodule _ (\u2248\u2081 : Rel A \u2113\u2081) (\u2248\u2082 : Rel B \u2113\u2082) {\u2264\u2081 : Rel A \u2113\u2083} {\u2264\u2082 : Rel B \u2113\u2084} where\n\n  mono\u21d2cong : Symmetric \u2248\u2081 \u2192 \u2248\u2081 \u21d2 \u2264\u2081 \u2192 Antisymmetric \u2248\u2082 \u2264\u2082 \u2192\n              \u2200 {f} \u2192 f Preserves \u2264\u2081 \u27f6 \u2264\u2082 \u2192 f Preserves \u2248\u2081 \u27f6 \u2248\u2082\n  mono\u21d2cong sym reflexive antisym mono x\u2248y = antisym\n    (mono (reflexive x\u2248y))\n    (mono (reflexive (sym x\u2248y)))\n\n  antimono\u21d2cong : Symmetric \u2248\u2081 \u2192 \u2248\u2081 \u21d2 \u2264\u2081 \u2192 Antisymmetric \u2248\u2082 \u2264\u2082 \u2192\n                  \u2200 {f} \u2192 f Preserves \u2264\u2081 \u27f6 (flip \u2264\u2082) \u2192 f Preserves \u2248\u2081 \u27f6 \u2248\u2082\n  antimono\u21d2cong sym reflexive antisym antimono p\u2248q = antisym\n    (antimono (reflexive (sym p\u2248q)))\n    (antimono (reflexive p\u2248q))\n\n  mono\u2082\u21d2cong\u2082 : Symmetric \u2248\u2081 \u2192 \u2248\u2081 \u21d2 \u2264\u2081 \u2192 Antisymmetric \u2248\u2082 \u2264\u2082 \u2192 \u2200 {f} \u2192\n                f Preserves\u2082 \u2264\u2081 \u27f6 \u2264\u2081 \u27f6 \u2264\u2082 \u2192\n                f Preserves\u2082 \u2248\u2081 \u27f6 \u2248\u2081 \u27f6 \u2248\u2082\n  mono\u2082\u21d2cong\u2082 sym reflexive antisym mono x\u2248y u\u2248v = antisym\n    (mono (reflexive x\u2248y) (reflexive u\u2248v))\n    (mono (reflexive (sym x\u2248y)) (reflexive (sym u\u2248v)))\n\n------------------------------------------------------------------------\n-- Proofs for strict orders\n\nmodule _ {_\u2248_ : Rel A \u2113\u2081} {_&lt;_ : Rel A \u2113\u2082} where\n\n  trans\u2227irr\u21d2asym : Reflexive _\u2248_ \u2192 Transitive _&lt;_ \u2192\n                   Irreflexive _\u2248_ _&lt;_ \u2192 Asymmetric _&lt;_\n  trans\u2227irr\u21d2asym refl trans irrefl x&lt;y y&lt;x =\n    irrefl refl (trans x&lt;y y&lt;x)\n\n  irr\u2227antisym\u21d2asym : Irreflexive _\u2248_ _&lt;_ \u2192 Antisymmetric _\u2248_ _&lt;_ \u2192\n                     Asymmetric _&lt;_\n  irr\u2227antisym\u21d2asym irrefl antisym x&lt;y y&lt;x =\n    irrefl (antisym x&lt;y y&lt;x) x&lt;y\n\n  asym\u21d2antisym : Asymmetric _&lt;_ \u2192 Antisymmetric _\u2248_ _&lt;_\n  asym\u21d2antisym asym x&lt;y y&lt;x = \u22a5-elim (asym x&lt;y y&lt;x)\n\n  asym\u21d2irr : _&lt;_ Respects\u2082 _\u2248_ \u2192 Symmetric _\u2248_ \u2192\n             Asymmetric _&lt;_ \u2192 Irreflexive _\u2248_ _&lt;_\n  asym\u21d2irr (resp\u02b3 , resp\u02e1) sym asym {x} {y} x\u2248y x&lt;y =\n    asym x&lt;y (resp\u02b3 (sym x\u2248y) (resp\u02e1 x\u2248y x&lt;y))\n\n  tri\u21d2asym : Trichotomous _\u2248_ _&lt;_ \u2192 Asymmetric _&lt;_\n  tri\u21d2asym tri {x} {y} x&lt;y x&gt;y with tri x y\n  ... | tri&lt; _   _ x\u226fy = x\u226fy x&gt;y\n  ... | tri\u2248 _   _ x\u226fy = x\u226fy x&gt;y\n  ... | tri&gt; x\u226ey _ _   = x\u226ey x&lt;y\n\n  tri\u21d2irr : Trichotomous _\u2248_ _&lt;_ \u2192 Irreflexive _\u2248_ _&lt;_\n  tri\u21d2irr compare {x} {y} x\u2248y x&lt;y with compare x y\n  ... | tri&lt; _   x\u2249y y\u226ex = x\u2249y x\u2248y\n  ... | tri&gt; x\u226ey x\u2249y y&lt;x = x\u2249y x\u2248y\n  ... | tri\u2248 x\u226ey _   y\u226ex = x\u226ey x&lt;y\n\n  tri\u21d2dec\u2248 : Trichotomous _\u2248_ _&lt;_ \u2192 Decidable _\u2248_\n  tri\u21d2dec\u2248 compare x y with compare x y\n  ... | tri&lt; _ x\u2249y _ = no  x\u2249y\n  ... | tri\u2248 _ x\u2248y _ = yes x\u2248y\n  ... | tri&gt; _ x\u2249y _ = no  x\u2249y\n\n  tri\u21d2dec&lt; : Trichotomous _\u2248_ _&lt;_ \u2192 Decidable _&lt;_\n  tri\u21d2dec&lt; compare x y with compare x y\n  ... | tri&lt; x&lt;y _ _ = yes x&lt;y\n  ... | tri\u2248 x\u226ey _ _ = no  x\u226ey\n  ... | tri&gt; x\u226ey _ _ = no  x\u226ey\n\n  trans\u2227tri\u21d2resp\u02b3 : Symmetric _\u2248_ \u2192 Transitive _\u2248_ \u2192\n                    Transitive _&lt;_ \u2192 Trichotomous _\u2248_ _&lt;_ \u2192\n                    _&lt;_ Respects\u02b3 _\u2248_\n  trans\u2227tri\u21d2resp\u02b3 sym \u2248-tr &lt;-tr tri {x} {y} {z} y\u2248z x&lt;y with tri x z\n  ... | tri&lt; x&lt;z _ _ = x&lt;z\n  ... | tri\u2248 _ x\u2248z _ = \u22a5-elim (tri\u21d2irr tri (\u2248-tr x\u2248z (sym y\u2248z)) x&lt;y)\n  ... | tri&gt; _ _ z&lt;x = \u22a5-elim (tri\u21d2irr tri (sym y\u2248z) (&lt;-tr z&lt;x x&lt;y))\n\n  trans\u2227tri\u21d2resp\u02e1 : Transitive _\u2248_ \u2192\n                    Transitive _&lt;_ \u2192 Trichotomous _\u2248_ _&lt;_ \u2192\n                    _&lt;_ Respects\u02e1 _\u2248_\n  trans\u2227tri\u21d2resp\u02e1 \u2248-tr &lt;-tr tri {z} {_} {y} x\u2248y x&lt;z with tri y z\n  ... | tri&lt; y&lt;z _ _ = y&lt;z\n  ... | tri\u2248 _ y\u2248z _ = \u22a5-elim (tri\u21d2irr tri (\u2248-tr x\u2248y y\u2248z) x&lt;z)\n  ... | tri&gt; _ _ z&lt;y = \u22a5-elim (tri\u21d2irr tri x\u2248y (&lt;-tr x&lt;z z&lt;y))\n\n  trans\u2227tri\u21d2resp : Symmetric _\u2248_ \u2192 Transitive _\u2248_ \u2192\n                   Transitive _&lt;_ \u2192 Trichotomous _\u2248_ _&lt;_ \u2192\n                   _&lt;_ Respects\u2082 _\u2248_\n  trans\u2227tri\u21d2resp sym \u2248-tr &lt;-tr tri =\n    trans\u2227tri\u21d2resp\u02b3 sym \u2248-tr &lt;-tr tri ,\n    trans\u2227tri\u21d2resp\u02e1 \u2248-tr &lt;-tr tri\n\n------------------------------------------------------------------------\n-- Without Loss of Generality\n\nmodule _  {_R_ : Rel A \u2113\u2081} {Q : Rel A \u2113\u2082} where\n\n  wlog : Total _R_ \u2192 Symmetric Q \u2192\n         (\u2200 a b \u2192 a R b \u2192 Q a b) \u2192\n         \u2200 a b \u2192 Q a b\n  wlog r-total q-sym prf a b with r-total a b\n  ... | inj\u2081 aRb = prf a b aRb\n  ... | inj\u2082 bRa = q-sym (prf b a bRa)\n\n------------------------------------------------------------------------\n-- Other proofs\n\nmodule _ {R : REL A B p} where\n\n  dec\u21d2weaklyDec : Decidable R \u2192 WeaklyDecidable R\n  dec\u21d2weaklyDec dec x y = dec\u21d2maybe (dec x y)\n\n  dec\u21d2recomputable : Decidable R \u2192 Recomputable R\n  dec\u21d2recomputable dec {a} {b} = recompute $ dec a b\n\nmodule _ {R : REL A B \u2113\u2081} {S : REL A B \u2113\u2082} where\n\n  map-NonEmpty : R \u21d2 S \u2192 NonEmpty R \u2192 NonEmpty S\n  map-NonEmpty f x = nonEmpty (f (NonEmpty.proof x))\n\nmodule _ {R : REL A B \u2113\u2081} {S : REL B A \u2113\u2082} where\n\n  flip-Connex : Connex R S \u2192 Connex S R\n  flip-Connex f x y = Sum.swap (f y x)\n\n\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 1.6\n\nsubst\u27f6resp\u02e1 = subst\u21d2resp\u02e1\n{-# WARNING_ON_USAGE subst\u27f6resp\u02e1\n\"Warning: subst\u27f6resp\u02e1 was deprecated in v1.6.\nPlease use subst\u21d2resp\u02e1 instead.\"\n#-}\nsubst\u27f6resp\u02b3 = subst\u21d2resp\u02b3\n{-# WARNING_ON_USAGE subst\u27f6resp\u02b3\n\"Warning: subst\u27f6resp\u02b3 was deprecated in v1.6.\nPlease use subst\u21d2resp\u02b3 instead.\"\n#-}\nsubst\u27f6resp\u2082 = subst\u21d2resp\u2082\n{-# WARNING_ON_USAGE subst\u27f6resp\u2082\n\"Warning: subst\u27f6resp\u2082 was deprecated in v1.6.\nPlease use subst\u21d2resp\u2082 instead.\"\n#-}\nP-resp\u27f6\u00acP-resp = resp\u21d2\u00ac-resp\n{-# WARNING_ON_USAGE P-resp\u27f6\u00acP-resp\n\"Warning: P-resp\u27f6\u00acP-resp was deprecated in v1.6.\nPlease use resp\u21d2\u00ac-resp instead.\"\n#-}\ntotal\u27f6refl = total\u21d2refl\n{-# WARNING_ON_USAGE total\u27f6refl\n\"Warning: total\u27f6refl was deprecated in v1.6.\nPlease use total\u21d2refl instead.\"\n#-}\ntotal+dec\u27f6dec = total\u2227dec\u21d2dec\n{-# WARNING_ON_USAGE total+dec\u27f6dec\n\"Warning: total+dec\u27f6dec was deprecated in v1.6.\nPlease use total\u2227dec\u21d2dec instead.\"\n#-}\ntrans\u2227irr\u27f6asym = trans\u2227irr\u21d2asym\n{-# WARNING_ON_USAGE trans\u2227irr\u27f6asym\n\"Warning: trans\u2227irr\u27f6asym was deprecated in v1.6.\nPlease use trans\u2227irr\u21d2asym instead.\"\n#-}\nirr\u2227antisym\u27f6asym = irr\u2227antisym\u21d2asym\n{-# WARNING_ON_USAGE irr\u2227antisym\u27f6asym\n\"Warning: irr\u2227antisym\u27f6asym was deprecated in v1.6.\nPlease use irr\u2227antisym\u21d2asym instead.\"\n#-}\nasym\u27f6antisym = asym\u21d2antisym\n{-# WARNING_ON_USAGE asym\u27f6antisym\n\"Warning: asym\u27f6antisym was deprecated in v1.6.\nPlease use asym\u21d2antisym instead.\"\n#-}\nasym\u27f6irr = asym\u21d2irr\n{-# WARNING_ON_USAGE asym\u27f6irr\n\"Warning: asym\u27f6irr was deprecated in v1.6.\nPlease use asym\u21d2irr instead.\"\n#-}\ntri\u27f6asym = tri\u21d2asym\n{-# WARNING_ON_USAGE tri\u27f6asym\n\"Warning: tri\u27f6asym was deprecated in v1.6.\nPlease use tri\u21d2asym instead.\"\n#-}\ntri\u27f6irr = tri\u21d2irr\n{-# WARNING_ON_USAGE tri\u27f6irr\n\"Warning: tri\u27f6irr was deprecated in v1.6.\nPlease use tri\u21d2irr instead.\"\n#-}\ntri\u27f6dec\u2248 = tri\u21d2dec\u2248\n{-# WARNING_ON_USAGE tri\u27f6dec\u2248\n\"Warning: tri\u27f6dec\u2248 was deprecated in v1.6.\nPlease use tri\u21d2dec\u2248 instead.\"\n#-}\ntri\u27f6dec&lt; = tri\u21d2dec&lt;\n{-# WARNING_ON_USAGE tri\u27f6dec&lt;\n\"Warning: tri\u27f6dec&lt; was deprecated in v1.6.\nPlease use tri\u21d2dec&lt; instead.\"\n#-}\ntrans\u2227tri\u27f6resp\u02b3\u2248 = trans\u2227tri\u21d2resp\u02b3\n{-# WARNING_ON_USAGE trans\u2227tri\u27f6resp\u02b3\u2248\n\"Warning: trans\u2227tri\u27f6resp\u02b3\u2248 was deprecated in v1.6.\nPlease use trans\u2227tri\u21d2resp\u02b3 instead.\"\n#-}\ntrans\u2227tri\u27f6resp\u02e1\u2248 = trans\u2227tri\u21d2resp\u02e1\n{-# WARNING_ON_USAGE trans\u2227tri\u27f6resp\u02e1\u2248\n\"Warning: trans\u2227tri\u27f6resp\u02e1\u2248 was deprecated in v1.6.\nPlease use trans\u2227tri\u21d2resp\u02e1 instead.\"\n#-}\ntrans\u2227tri\u27f6resp\u2248 = trans\u2227tri\u21d2resp\n{-# WARNING_ON_USAGE trans\u2227tri\u27f6resp\u2248\n\"Warning: trans\u2227tri\u27f6resp\u2248 was deprecated in v1.6.\nPlease use trans\u2227tri\u21d2resp instead.\"\n#-}\ndec\u27f6weaklyDec = dec\u21d2weaklyDec\n{-# WARNING_ON_USAGE dec\u27f6weaklyDec\n\"Warning: dec\u27f6weaklyDec was deprecated in v1.6.\nPlease use dec\u21d2weaklyDec instead.\"\n#-}\ndec\u27f6recomputable = dec\u21d2recomputable\n{-# WARNING_ON_USAGE dec\u27f6recomputable\n\"Warning: dec\u27f6recomputable was deprecated in v1.6.\nPlease use dec\u21d2recomputable instead.\"\n#-}\n</pre>"},{"location":"md/Relation/Binary/Construct/Closure/Reflexive/","title":"Relation.Binary.Construct.Closure.Reflexive","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Reflexive closures\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Construct.Closure.Reflexive where\n\nopen import Data.Unit.Base\nopen import Level\nopen import Function.Base using (_\u220b_)\nopen import Relation.Binary.Core using (Rel; _=[_]\u21d2_; _\u21d2_)\nopen import Relation.Binary.Definitions using (Reflexive)\nopen import Relation.Binary.Construct.Constant.Core using (Const)\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_ ; refl)\n\nprivate\n  variable\n    a \u2113 \u2113\u2081 \u2113\u2082 : Level\n    A B : Set a\n\n------------------------------------------------------------------------\n-- Definition\n\ndata ReflClosure {A : Set a} (_\u223c_ : Rel A \u2113) : Rel A (a \u2294 \u2113) where\n  refl : Reflexive (ReflClosure _\u223c_)\n  [_]  : \u2200 {x y} (x\u223cy : x \u223c y) \u2192 ReflClosure _\u223c_ x y\n\n------------------------------------------------------------------------\n-- Operations\n\nmap : \u2200 {R : Rel A \u2113\u2081} {S : Rel B \u2113\u2082} {f : A \u2192 B} \u2192\n      R =[ f ]\u21d2 S \u2192 ReflClosure R =[ f ]\u21d2 ReflClosure S\nmap R\u21d2S [ xRy ] = [ R\u21d2S xRy ]\nmap R\u21d2S refl    = refl\n\n------------------------------------------------------------------------\n-- Properties\n\n-- The reflexive closure has no effect on reflexive relations.\ndrop-refl : {R : Rel A \u2113} \u2192 Reflexive R \u2192 ReflClosure R \u21d2 R\ndrop-refl rfl [ xRy ] = xRy\ndrop-refl rfl refl    = rfl\n\nreflexive : {R : Rel A \u2113} \u2192 _\u2261_ \u21d2 ReflClosure R\nreflexive refl = refl\n\n[]-injective : {R : Rel A \u2113} \u2192 \u2200 {x y p q} \u2192\n               (ReflClosure R x y \u220b [ p ]) \u2261 [ q ] \u2192 p \u2261 q\n[]-injective refl = refl\n\n------------------------------------------------------------------------\n-- Example usage\n\nprivate\n  module Maybe where\n    Maybe : Set a \u2192 Set a\n    Maybe A = ReflClosure (Const A) tt tt\n\n    nothing : Maybe A\n    nothing = refl\n\n    just : A \u2192 Maybe A\n    just = [_]\n\n\n\n------------------------------------------------------------------------\n-- Deprecations\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- v1.5\n\nRefl = ReflClosure\n{-# WARNING_ON_USAGE Refl\n\"Warning: Refl was deprecated in v1.5.\nPlease use ReflClosure instead.\"\n#-}\n</pre>"},{"location":"md/Relation/Binary/Construct/Composition/","title":"Relation.Binary.Construct.Composition","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Composition of two binary relations\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Construct.Composition where\n\nopen import Data.Product.Base using (\u2203; _\u00d7_; _,_)\nopen import Function.Base\nopen import Level\nopen import Relation.Binary.Core using (Rel; REL; _\u21d2_)\nopen import Relation.Binary.Structures using (IsPreorder)\nopen import Relation.Binary.Definitions\n  using (_Respects_; _Respects\u02b3_; _Respects\u02e1_; _Respects\u2082_; Reflexive; Transitive)\n\nprivate\n  variable\n    a b c \u2113 \u2113\u2081 \u2113\u2082 : Level\n    A : Set a\n    B : Set b\n    C : Set c\n\n------------------------------------------------------------------------\n-- Definition\n\ninfixr 9 _\u037e_\n\n_\u037e_ : {A : Set a} {B : Set b} {C : Set c} \u2192\n      REL A B \u2113\u2081 \u2192 REL B C \u2113\u2082 \u2192 REL A C (b \u2294 \u2113\u2081 \u2294 \u2113\u2082)\nL \u037e R = \u03bb i j \u2192 \u2203 \u03bb k \u2192 L i k \u00d7 R k j\n\n------------------------------------------------------------------------\n-- Properties\n\nmodule _ (L : Rel A \u2113\u2081) (R : Rel A \u2113\u2082) where\n\n  reflexive : Reflexive L \u2192 Reflexive R \u2192 Reflexive (L \u037e R)\n  reflexive L-refl R-refl = _ , L-refl , R-refl\n\n  respects : \u2200 {p} {P : A \u2192 Set p} \u2192\n             P Respects L \u2192 P Respects R \u2192 P Respects (L \u037e R)\n  respects resp-L resp-R (k , Lik , Rkj) = resp-R Rkj \u2218 resp-L Lik\n\nmodule _ {\u2248 : Rel A \u2113} (L : REL A B \u2113\u2081) (R : REL B C \u2113\u2082) where\n\n  respects\u02e1 : L Respects\u02e1 \u2248 \u2192 (L \u037e R) Respects\u02e1 \u2248\n  respects\u02e1 L\u02e1 i\u2248i\u2032 (k , Lik , Rkj) = k , L\u02e1 i\u2248i\u2032 Lik , Rkj\n\nmodule _ {\u2248 : Rel C \u2113} (L : REL A B \u2113\u2081) (R : REL B C \u2113\u2082) where\n\n  respects\u02b3 : R Respects\u02b3 \u2248 \u2192 (L \u037e R) Respects\u02b3 \u2248\n  respects\u02b3 R\u02b3 j\u2248j\u2032 (k , Lik , Rkj) = k , Lik , R\u02b3 j\u2248j\u2032 Rkj\n\nmodule _ {\u2248 : Rel A \u2113} (L : REL A B \u2113\u2081) (R : REL B A \u2113\u2082) where\n\n  respects\u2082 :  L Respects\u02e1 \u2248 \u2192 R Respects\u02b3 \u2248 \u2192 (L \u037e R) Respects\u2082 \u2248\n  respects\u2082 L\u02e1 R\u02b3 = respects\u02b3 L R R\u02b3 , respects\u02e1 L R L\u02e1\n\nmodule _ {\u2248 : REL A B \u2113} (L : REL A B \u2113\u2081) (R : Rel B \u2113\u2082) where\n\n  implies\u02e1 : Reflexive R \u2192 (\u2248 \u21d2 L) \u2192 (\u2248 \u21d2 L \u037e R)\n  implies\u02e1 R-refl \u2248\u21d2L {i} {j} i\u2248j = j , \u2248\u21d2L i\u2248j , R-refl\n\nmodule _ {\u2248 : REL A B \u2113} (L : Rel A \u2113\u2081) (R : REL A B \u2113\u2082) where\n\n  implies\u02b3 : Reflexive L \u2192 (\u2248 \u21d2 R) \u2192 (\u2248 \u21d2 L \u037e R)\n  implies\u02b3 L-refl \u2248\u21d2R {i} {j} i\u2248j = i , L-refl , \u2248\u21d2R i\u2248j\n\nmodule _ (L : Rel A \u2113\u2081) (R : Rel A \u2113\u2082) (comm : R \u037e L \u21d2 L \u037e R) where\n\n  transitive : Transitive L \u2192 Transitive R \u2192 Transitive (L \u037e R)\n  transitive L-trans R-trans {i} {j} {k} (x , Lix , Rxj) (y , Ljy , Ryk) =\n    let z , Lxz , Rzy = comm (j , Rxj , Ljy) in z , L-trans Lix  Lxz , R-trans Rzy Ryk\n\n  isPreorder : {\u2248 : Rel A \u2113} \u2192 IsPreorder \u2248 L \u2192 IsPreorder \u2248 R \u2192 IsPreorder \u2248 (L \u037e R)\n  isPreorder O\u02e1 O\u02b3 = record\n    { isEquivalence = O\u02e1.isEquivalence\n    ; reflexive     = implies\u02e1 L R O\u02b3.refl O\u02e1.reflexive\n    ; trans         = transitive O\u02e1.trans O\u02b3.trans\n    }\n    where module O\u02e1 = IsPreorder O\u02e1; module O\u02b3 = IsPreorder O\u02b3\n\ntransitive\u21d2\u2248\u037e\u2248\u2286\u2248 : (\u2248 : Rel A \u2113) \u2192 Transitive \u2248 \u2192 (\u2248 \u037e \u2248) \u21d2 \u2248\ntransitive\u21d2\u2248\u037e\u2248\u2286\u2248 _ trans (_ , l , r) = trans l r\n</pre>"},{"location":"md/Relation/Binary/Construct/Constant/Core/","title":"Relation.Binary.Construct.Constant.Core","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- The binary relation defined by a constant\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Construct.Constant.Core where\n\nopen import Level\nopen import Relation.Binary.Core using (REL)\n\nprivate\n  variable\n    a b c : Level\n    A : Set a\n    B : Set b\n\n------------------------------------------------------------------------\n-- Definition\n\nConst : Set c \u2192 REL A B c\nConst I = \u03bb _ _ \u2192 I\n</pre>"},{"location":"md/Relation/Binary/Core/","title":"Relation.Binary.Core","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Properties of binary relations\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via `Relation.Binary`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Core where\n\nopen import Data.Product.Base using (_\u00d7_)\nopen import Function.Base using (_on_)\nopen import Level using (Level; _\u2294_; suc)\n\nprivate\n  variable\n    a b c \u2113 \u2113\u2081 \u2113\u2082 \u2113\u2083 : Level\n    A : Set a\n    B : Set b\n    C : Set c\n\n------------------------------------------------------------------------\n-- Definitions\n------------------------------------------------------------------------\n\n-- Heterogeneous binary relations\n\nREL : Set a \u2192 Set b \u2192 (\u2113 : Level) \u2192 Set (a \u2294 b \u2294 suc \u2113)\nREL A B \u2113 = A \u2192 B \u2192 Set \u2113\n\n-- Homogeneous binary relations\n\nRel : Set a \u2192 (\u2113 : Level) \u2192 Set (a \u2294 suc \u2113)\nRel A \u2113 = REL A A \u2113\n\n------------------------------------------------------------------------\n-- Relationships between relations\n------------------------------------------------------------------------\n\ninfix 4 _\u21d2_ _\u21d4_ _=[_]\u21d2_\n\n-- Implication/containment - could also be written _\u2286_.\n-- and corresponding notion of equivalence\n\n_\u21d2_ : REL A B \u2113\u2081 \u2192 REL A B \u2113\u2082 \u2192 Set _\nP \u21d2 Q = \u2200 {x y} \u2192 P x y \u2192 Q x y\n\n_\u21d4_ : REL A B \u2113\u2081 \u2192 REL A B \u2113\u2082 \u2192 Set _\nP \u21d4 Q = P \u21d2 Q \u00d7 Q \u21d2 P\n\n-- Generalised implication - if P \u2261 Q it can be read as \"f preserves P\".\n\n_=[_]\u21d2_ : Rel A \u2113\u2081 \u2192 (A \u2192 B) \u2192 Rel B \u2113\u2082 \u2192 Set _\nP =[ f ]\u21d2 Q = P \u21d2 (Q on f)\n\n-- A synonym for _=[_]\u21d2_.\n\n_Preserves_\u27f6_ : (A \u2192 B) \u2192 Rel A \u2113\u2081 \u2192 Rel B \u2113\u2082 \u2192 Set _\nf Preserves P \u27f6 Q = P =[ f ]\u21d2 Q\n\n-- A binary variant of _Preserves_\u27f6_.\n\n_Preserves\u2082_\u27f6_\u27f6_ : (A \u2192 B \u2192 C) \u2192 Rel A \u2113\u2081 \u2192 Rel B \u2113\u2082 \u2192 Rel C \u2113\u2083 \u2192 Set _\n_\u2219_ Preserves\u2082 P \u27f6 Q \u27f6 R = \u2200 {x y u v} \u2192 P x y \u2192 Q u v \u2192 R (x \u2219 u) (y \u2219 v)\n</pre>"},{"location":"md/Relation/Binary/Definitions/","title":"Relation.Binary.Definitions","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Properties of binary relations\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via `Relation.Binary`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Definitions where\n\nopen import Agda.Builtin.Equality using (_\u2261_)\n\nopen import Data.Product.Base using (_\u00d7_; \u2203-syntax)\nopen import Data.Sum.Base using (_\u228e_)\nopen import Function.Base using (_on_; flip)\nopen import Level\nopen import Relation.Binary.Core\nopen import Relation.Nullary as Nullary using (\u00ac_; Dec)\n\nprivate\n  variable\n    a b c \u2113 \u2113\u2081 \u2113\u2082 \u2113\u2083 : Level\n    A : Set a\n    B : Set b\n    C : Set c\n\n------------------------------------------------------------------------\n-- Definitions\n------------------------------------------------------------------------\n\n-- Reflexivity - defined without an underlying equality. It could\n-- alternatively be defined as `_\u2248_ \u21d2 _\u223c_` for some equality `_\u2248_`.\n\n-- Confusingly the convention in the library is to use the name \"refl\"\n-- for proofs of Reflexive and `reflexive` for proofs of type `_\u2248_ \u21d2 _\u223c_`,\n-- e.g. in the definition of `IsEquivalence` later in this file. This\n-- convention is a legacy from the early days of the library.\n\nReflexive : Rel A \u2113 \u2192 Set _\nReflexive _\u223c_ = \u2200 {x} \u2192 x \u223c x\n\n-- Generalised symmetry.\n\nSym : REL A B \u2113\u2081 \u2192 REL B A \u2113\u2082 \u2192 Set _\nSym P Q = P \u21d2 flip Q\n\n-- Symmetry.\n\nSymmetric : Rel A \u2113 \u2192 Set _\nSymmetric _\u223c_ = Sym _\u223c_ _\u223c_\n\n-- Generalised transitivity.\n\nTrans : REL A B \u2113\u2081 \u2192 REL B C \u2113\u2082 \u2192 REL A C \u2113\u2083 \u2192 Set _\nTrans P Q R = \u2200 {i j k} \u2192 P i j \u2192 Q j k \u2192 R i k\n\nRightTrans : REL A B \u2113\u2081 \u2192 REL B B \u2113\u2082 \u2192 Set _\nRightTrans R S = Trans R S R\n\nLeftTrans : REL A A \u2113\u2081 \u2192 REL A B \u2113\u2082 \u2192 Set _\nLeftTrans S R = Trans S R R\n\n-- A flipped variant of generalised transitivity.\n\nTransFlip : REL A B \u2113\u2081 \u2192 REL B C \u2113\u2082 \u2192 REL A C \u2113\u2083 \u2192 Set _\nTransFlip P Q R = \u2200 {i j k} \u2192 Q j k \u2192 P i j \u2192 R i k\n\n-- Transitivity.\n\nTransitive : Rel A \u2113 \u2192 Set _\nTransitive _\u223c_ = Trans _\u223c_ _\u223c_ _\u223c_\n\n-- Generalised antisymmetry\n\nAntisym : REL A B \u2113\u2081 \u2192 REL B A \u2113\u2082 \u2192 REL A B \u2113\u2083 \u2192 Set _\nAntisym R S E = \u2200 {i j} \u2192 R i j \u2192 S j i \u2192 E i j\n\n-- Antisymmetry.\n\nAntisymmetric : Rel A \u2113\u2081 \u2192 Rel A \u2113\u2082 \u2192 Set _\nAntisymmetric _\u2248_ _\u2264_ = Antisym _\u2264_ _\u2264_ _\u2248_\n\n-- Irreflexivity - this is defined terms of the underlying equality.\n\nIrreflexive : REL A B \u2113\u2081 \u2192 REL A B \u2113\u2082 \u2192 Set _\nIrreflexive _\u2248_ _&lt;_ = \u2200 {x y} \u2192 x \u2248 y \u2192 \u00ac (x &lt; y)\n\n-- Asymmetry.\n\nAsymmetric : Rel A \u2113 \u2192 Set _\nAsymmetric _&lt;_ = \u2200 {x y} \u2192 x &lt; y \u2192 \u00ac (y &lt; x)\n\n-- Density\n\nDense : Rel A \u2113 \u2192 Set _\nDense _&lt;_ = \u2200 {x y} \u2192 x &lt; y \u2192 \u2203[ z ] x &lt; z \u00d7 z &lt; y\n\n-- Generalised connex - at least one of the two relations holds.\n\nConnex : REL A B \u2113\u2081 \u2192 REL B A \u2113\u2082 \u2192 Set _\nConnex P Q = \u2200 x y \u2192 P x y \u228e Q y x\n\n-- Totality.\n\nTotal : Rel A \u2113 \u2192 Set _\nTotal _\u223c_ = Connex _\u223c_ _\u223c_\n\n-- Generalised trichotomy - exactly one of three types has a witness.\n\ndata Tri (A : Set a) (B : Set b) (C : Set c) : Set (a \u2294 b \u2294 c) where\n  tri&lt; : ( a :   A) (\u00acb : \u00ac B) (\u00acc : \u00ac C) \u2192 Tri A B C\n  tri\u2248 : (\u00aca : \u00ac A) ( b :   B) (\u00acc : \u00ac C) \u2192 Tri A B C\n  tri&gt; : (\u00aca : \u00ac A) (\u00acb : \u00ac B) ( c :   C) \u2192 Tri A B C\n\n-- Trichotomy.\n\nTrichotomous : Rel A \u2113\u2081 \u2192 Rel A \u2113\u2082 \u2192 Set _\nTrichotomous _\u2248_ _&lt;_ = \u2200 x y \u2192 Tri (x &lt; y) (x \u2248 y) (x &gt; y)\n  where _&gt;_ = flip _&lt;_\n\n-- Generalised maximum element.\n\nMax : REL A B \u2113 \u2192 B \u2192 Set _\nMax _\u2264_ T = \u2200 x \u2192 x \u2264 T\n\n-- Maximum element.\n\nMaximum : Rel A \u2113 \u2192 A \u2192 Set _\nMaximum = Max\n\n-- Generalised minimum element.\n\nMin : REL A B \u2113 \u2192 A \u2192 Set _\nMin R = Max (flip R)\n\n-- Minimum element.\n\nMinimum : Rel A \u2113 \u2192 A \u2192 Set _\nMinimum = Min\n\n-- Definitions for apartness relations\n\n-- Note that Cotransitive's arguments are permuted with respect to Transitive's.\nCotransitive : Rel A \u2113 \u2192 Set _\nCotransitive _#_ = \u2200 {x y} \u2192 x # y \u2192 \u2200 z \u2192 (x # z) \u228e (z # y)\n\nTight : Rel A \u2113\u2081 \u2192 Rel A \u2113\u2082 \u2192 Set _\nTight _\u2248_ _#_ = \u2200 x y \u2192 (\u00ac x # y \u2192 x \u2248 y) \u00d7 (x \u2248 y \u2192 \u00ac x # y)\n\n-- Properties of order morphisms, aka order-preserving maps\n\nMonotonic\u2081 : Rel A \u2113\u2081 \u2192 Rel B \u2113\u2082 \u2192 (A \u2192 B) \u2192 Set _\nMonotonic\u2081 _\u2264_ _\u2291_ f = f Preserves _\u2264_ \u27f6 _\u2291_\n\nAntitonic\u2081 : Rel A \u2113\u2081 \u2192 Rel B \u2113\u2082 \u2192 (A \u2192 B) \u2192 Set _\nAntitonic\u2081 _\u2264_ _\u2291_ f = f Preserves (flip _\u2264_) \u27f6 _\u2291_\n\nMonotonic\u2082 : Rel A \u2113\u2081 \u2192 Rel B \u2113\u2082 \u2192 Rel C \u2113\u2083 \u2192 (A \u2192 B \u2192 C) \u2192 Set _\nMonotonic\u2082 _\u2264_ _\u2291_ _\u227c_ \u2219 = \u2219 Preserves\u2082 _\u2264_ \u27f6 _\u2291_ \u27f6 _\u227c_\n\nMonotonicAntitonic : Rel A \u2113\u2081 \u2192 Rel B \u2113\u2082 \u2192 Rel C \u2113\u2083 \u2192 (A \u2192 B \u2192 C) \u2192 Set _\nMonotonicAntitonic _\u2264_ _\u2291_ _\u227c_ \u2219 = \u2219 Preserves\u2082 _\u2264_ \u27f6 (flip _\u2291_) \u27f6 _\u227c_\n\nAntitonicMonotonic : Rel A \u2113\u2081 \u2192 Rel B \u2113\u2082 \u2192 Rel C \u2113\u2083 \u2192 (A \u2192 B \u2192 C) \u2192 Set _\nAntitonicMonotonic _\u2264_ _\u2291_ _\u227c_ \u2219 = \u2219 Preserves\u2082 (flip _\u2264_) \u27f6 _\u2291_ \u27f6 _\u227c_\n\nAntitonic\u2082 : Rel A \u2113\u2081 \u2192 Rel B \u2113\u2082 \u2192 Rel C \u2113\u2083 \u2192 (A \u2192 B \u2192 C) \u2192 Set _\nAntitonic\u2082 _\u2264_ _\u2291_ _\u227c_ \u2219 = \u2219 Preserves\u2082 (flip _\u2264_) \u27f6 (flip _\u2291_) \u27f6 _\u227c_\n\nAdjoint : Rel A \u2113\u2081 \u2192 Rel B \u2113\u2082 \u2192 (A \u2192 B) \u2192 (B \u2192 A) \u2192 Set _\nAdjoint _\u2264_ _\u2291_ f g = \u2200 {x y} \u2192 (f x \u2291 y \u2192 x \u2264 g y) \u00d7 (x \u2264 g y \u2192 f x \u2291 y)\n\n-- Unary relations respecting a binary relation.\n\n_\u27f6_Respects_ : (A \u2192 Set \u2113\u2081) \u2192 (B \u2192 Set \u2113\u2082) \u2192 REL A B \u2113\u2083 \u2192 Set _\nP \u27f6 Q Respects _\u223c_ = \u2200 {x y} \u2192 x \u223c y \u2192 P x \u2192 Q y\n\n-- Unary relation respects a binary relation.\n\n_Respects_ : (A \u2192 Set \u2113\u2081) \u2192 Rel A \u2113\u2082 \u2192 Set _\nP Respects _\u223c_ = P \u27f6 P Respects _\u223c_\n\n-- Right respecting - relatedness is preserved on the right by equality.\n\n_Respects\u02b3_ : REL A B \u2113\u2081 \u2192 Rel B \u2113\u2082 \u2192 Set _\n_\u223c_ Respects\u02b3 _\u2248_ = \u2200 {x} \u2192 (x \u223c_) Respects _\u2248_\n\n-- Left respecting - relatedness is preserved on the left by equality.\n\n_Respects\u02e1_ : REL A B \u2113\u2081 \u2192 Rel A \u2113\u2082 \u2192 Set _\nP Respects\u02e1 _\u223c_ = \u2200 {y} \u2192 (flip P y) Respects _\u223c_\n\n-- Respecting - relatedness is preserved on both sides by equality\n\n_Respects\u2082_ : Rel A \u2113\u2081 \u2192 Rel A \u2113\u2082 \u2192 Set _\nP Respects\u2082 _\u223c_ = (P Respects\u02b3 _\u223c_) \u00d7 (P Respects\u02e1 _\u223c_)\n\n-- Substitutivity - any two related elements satisfy exactly the same\n-- set of unary relations. Note that only the various derivatives\n-- of propositional equality can satisfy this property.\n\nSubstitutive : Rel A \u2113\u2081 \u2192 (\u2113\u2082 : Level) \u2192 Set _\nSubstitutive {A = A} _\u223c_ p = (P : A \u2192 Set p) \u2192 P Respects _\u223c_\n\n-- Irrelevancy - all proofs that a given pair of elements are related\n-- are indistinguishable.\n\nIrrelevant : REL A B \u2113 \u2192 Set _\nIrrelevant _\u223c_ = \u2200 {x y} \u2192 Nullary.Irrelevant (x \u223c y)\n\n-- Recomputability - we can rebuild a relevant proof given an\n-- irrelevant one.\n\nRecomputable : REL A B \u2113 \u2192 Set _\nRecomputable _\u223c_ = \u2200 {x y} \u2192 Nullary.Recomputable (x \u223c y)\n\n-- Stability\n\nStable : REL A B \u2113 \u2192 Set _\nStable _\u223c_ = \u2200 x y \u2192 Nullary.Stable (x \u223c y)\n\n-- Weak decidability - it is sometimes possible to determine if a given\n-- pair of elements are related.\n\nWeaklyDecidable : REL A B \u2113 \u2192 Set _\nWeaklyDecidable _\u223c_ = \u2200 x y \u2192 Nullary.WeaklyDecidable (x \u223c y)\n\n-- Decidability - it is possible to determine whether a given pair of\n-- elements are related.\n\nDecidable : REL A B \u2113 \u2192 Set _\nDecidable _\u223c_ = \u2200 x y \u2192 Dec (x \u223c y)\n\n-- Propositional equality is decidable for the type.\n\nDecidableEquality : (A : Set a) \u2192 Set _\nDecidableEquality A = Decidable {A = A} _\u2261_\n\n-- Universal - all pairs of elements are related\n\nUniversal : REL A B \u2113 \u2192 Set _\nUniversal _\u223c_ = \u2200 x y \u2192 x \u223c y\n\n-- Empty - no elements are related\n\nEmpty : REL A B \u2113 \u2192 Set _\nEmpty _\u223c_ = \u2200 {x y} \u2192 \u00ac (x \u223c y)\n\n-- Non-emptiness - at least one pair of elements are related.\n\nrecord NonEmpty {A : Set a} {B : Set b}\n                (T : REL A B \u2113) : Set (a \u2294 b \u2294 \u2113) where\n  constructor nonEmpty\n  field\n    {x}   : A\n    {y}   : B\n    proof : T x y\n</pre>"},{"location":"md/Relation/Binary/Indexed/Heterogeneous/Core/","title":"Relation.Binary.Indexed.Heterogeneous.Core","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Indexed binary relations\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via\n-- `Relation.Binary.Indexed.Heterogeneous`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.Indexed.Heterogeneous.Core where\n\nopen import Level\nimport Relation.Binary.Core as B\n\n------------------------------------------------------------------------\n-- Indexed binary relations\n\n-- Heterogeneous types\n\nIREL : \u2200 {i\u2081 i\u2082 a\u2081 a\u2082} {I\u2081 : Set i\u2081} {I\u2082 : Set i\u2082} \u2192\n      (I\u2081 \u2192 Set a\u2081) \u2192 (I\u2082 \u2192 Set a\u2082) \u2192 (\u2113 : Level) \u2192 Set _\nIREL A\u2081 A\u2082 \u2113 = \u2200 {i\u2081 i\u2082} \u2192 A\u2081 i\u2081 \u2192 A\u2082 i\u2082 \u2192 Set \u2113\n\n-- Homogeneous types\n\nIRel : \u2200 {i a} {I : Set i} \u2192 (I \u2192 Set a) \u2192 (\u2113 : Level) \u2192 Set _\nIRel A \u2113 = IREL A A \u2113\n\n------------------------------------------------------------------------\n-- Generalised implication.\n\ninfixr 4 _=[_]\u21d2_\n\n_=[_]\u21d2_ : \u2200 {a b \u2113\u2081 \u2113\u2082} {A : Set a} {B : A \u2192 Set b} \u2192\n          B.Rel A \u2113\u2081 \u2192 ((x : A) \u2192 B x) \u2192 IRel B \u2113\u2082 \u2192 Set _\nP =[ f ]\u21d2 Q = \u2200 {i j} \u2192 P i j \u2192 Q (f i) (f j)\n</pre>"},{"location":"md/Relation/Binary/Properties/Setoid/","title":"Relation.Binary.Properties.Setoid","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Additional properties for setoids\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Data.Product.Base using (_,_)\nopen import Function.Base using (_\u2218_; id; _$_; flip)\nopen import Relation.Nullary.Negation.Core using (\u00ac_; contradiction)\nopen import Relation.Binary.Core using (_\u21d2_)\nopen import Relation.Binary.PropositionalEquality.Core as \u2261 using (_\u2261_)\nopen import Relation.Binary.Bundles using (Setoid; Preorder; Poset)\nopen import Relation.Binary.Definitions\n  using (Symmetric; _Respects\u02e1_; _Respects\u02b3_; _Respects\u2082_; Irreflexive)\nopen import Relation.Binary.Structures using (IsPreorder; IsPartialOrder)\nopen import Relation.Binary.Construct.Composition\n  using (_\u037e_; implies\u02e1; transitive\u21d2\u2248\u037e\u2248\u2286\u2248)\n\nmodule Relation.Binary.Properties.Setoid {a \u2113} (S : Setoid a \u2113) where\n\nopen Setoid S\n\n------------------------------------------------------------------------\n-- Every setoid is a preorder and partial order with respect to\n-- propositional equality\n\nisPreorder : IsPreorder _\u2261_ _\u2248_\nisPreorder = record\n  { isEquivalence = record\n    { refl  = \u2261.refl\n    ; sym   = \u2261.sym\n    ; trans = \u2261.trans\n    }\n  ; reflexive     = reflexive\n  ; trans         = trans\n  }\n\n\u2248-isPreorder : IsPreorder _\u2248_ _\u2248_\n\u2248-isPreorder = record\n  { isEquivalence = isEquivalence\n  ; reflexive     = id\n  ; trans         = trans\n  }\n\n\u2248-isPartialOrder : IsPartialOrder _\u2248_ _\u2248_\n\u2248-isPartialOrder = record\n  { isPreorder = \u2248-isPreorder\n  ; antisym    = \u03bb i\u2248j _ \u2192 i\u2248j\n  }\n\npreorder : Preorder a a \u2113\npreorder = record\n  { isPreorder = isPreorder\n  }\n\n\u2248-preorder : Preorder a \u2113 \u2113\n\u2248-preorder = record\n  { isPreorder = \u2248-isPreorder\n  }\n\n\u2248-poset : Poset a \u2113 \u2113\n\u2248-poset = record\n  { isPartialOrder = \u2248-isPartialOrder\n  }\n\n------------------------------------------------------------------------\n-- Properties of _\u2249_\n\n\u2249-sym :  Symmetric _\u2249_\n\u2249-sym x\u2249y =  x\u2249y \u2218 sym\n\n\u2249-resp\u02e1 : _\u2249_ Respects\u02e1 _\u2248_\n\u2249-resp\u02e1 x\u2248x\u2032 x\u2249y = x\u2249y \u2218 trans x\u2248x\u2032\n\n\u2249-resp\u02b3 : _\u2249_ Respects\u02b3 _\u2248_\n\u2249-resp\u02b3 y\u2248y\u2032 x\u2249y x\u2248y\u2032 = x\u2249y $ trans x\u2248y\u2032 (sym y\u2248y\u2032)\n\n\u2249-resp\u2082 : _\u2249_ Respects\u2082 _\u2248_\n\u2249-resp\u2082 = \u2249-resp\u02b3 , \u2249-resp\u02e1\n\n\u2249-irrefl : Irreflexive _\u2248_ _\u2249_\n\u2249-irrefl x\u2248y x\u2249y = contradiction x\u2248y x\u2249y\n\n------------------------------------------------------------------------\n-- Equality is closed under composition\n\n\u2248\u037e\u2248\u21d2\u2248 : _\u2248_ \u037e _\u2248_ \u21d2 _\u2248_\n\u2248\u037e\u2248\u21d2\u2248 = transitive\u21d2\u2248\u037e\u2248\u2286\u2248 _ trans\n\n\u2248\u21d2\u2248\u037e\u2248 : _\u2248_ \u21d2 _\u2248_ \u037e _\u2248_\n\u2248\u21d2\u2248\u037e\u2248 = implies\u02e1 _\u2248_ _\u2248_ refl id\n\n------------------------------------------------------------------------\n-- Other properties\n\nresp\u02b3-flip : _\u2248_ Respects\u02b3 (flip _\u2248_)\nresp\u02b3-flip y\u2248z x\u2248z = trans x\u2248z (sym y\u2248z)\n\nresp\u02e1-flip : _\u2248_ Respects\u02e1 (flip _\u2248_)\nresp\u02e1-flip = trans\n</pre>"},{"location":"md/Relation/Binary/PropositionalEquality/Core/","title":"Relation.Binary.PropositionalEquality.Core","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Propositional equality\n--\n-- This file contains some core definitions which are re-exported by\n-- Relation.Binary.PropositionalEquality.\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.PropositionalEquality.Core where\n\nopen import Data.Product.Base using (_,_)\nopen import Function.Base using (_\u2218_)\nopen import Level\nopen import Relation.Binary.Core\nopen import Relation.Binary.Definitions\nopen import Relation.Nullary.Negation.Core using (\u00ac_)\n\nprivate\n  variable\n    a b \u2113 : Level\n    A B C : Set a\n\n------------------------------------------------------------------------\n-- Propositional equality\n\nopen import Agda.Builtin.Equality public\n\ninfix 4 _\u2262_\n_\u2262_ : {A : Set a} \u2192 Rel A a\nx \u2262 y = \u00ac x \u2261 y\n\n------------------------------------------------------------------------\n-- Pointwise equality\n\ninfix 4 _\u2257_\n\n_\u2257_ : (f g : A \u2192 B) \u2192 Set _\n_\u2257_ {A = A} {B = B} f g = \u2200 x \u2192 f x \u2261 g x\n\n\n------------------------------------------------------------------------\n-- A variant of `refl` where the argument is explicit\n\npattern erefl x = refl {x = x}\n\n------------------------------------------------------------------------\n-- Congruence lemmas\n\ncong : \u2200 (f : A \u2192 B) {x y} \u2192 x \u2261 y \u2192 f x \u2261 f y\ncong f refl = refl\n\ncong\u2032 : \u2200 {f : A \u2192 B} x \u2192 f x \u2261 f x\ncong\u2032 _ = refl\n\nicong : \u2200 {f : A \u2192 B} {x y} \u2192 x \u2261 y \u2192 f x \u2261 f y\nicong = cong _\n\nicong\u2032 : \u2200 {f : A \u2192 B} x \u2192 f x \u2261 f x\nicong\u2032 _ = refl\n\ncong\u2082 : \u2200 (f : A \u2192 B \u2192 C) {x y u v} \u2192 x \u2261 y \u2192 u \u2261 v \u2192 f x u \u2261 f y v\ncong\u2082 f refl refl = refl\n\ncong-app : \u2200 {A : Set a} {B : A \u2192 Set b} {f g : (x : A) \u2192 B x} \u2192\n           f \u2261 g \u2192 (x : A) \u2192 f x \u2261 g x\ncong-app refl x = refl\n\n------------------------------------------------------------------------\n-- Properties of _\u2261_\n\nsym : Symmetric {A = A} _\u2261_\nsym refl = refl\n\ntrans : Transitive {A = A} _\u2261_\ntrans refl eq = eq\n\nsubst : Substitutive {A = A} _\u2261_ \u2113\nsubst P refl p = p\n\nsubst\u2082 : \u2200 (_\u223c_ : REL A B \u2113) {x y u v} \u2192 x \u2261 y \u2192 u \u2261 v \u2192 x \u223c u \u2192 y \u223c v\nsubst\u2082 _ refl refl p = p\n\nresp : \u2200 (P : A \u2192 Set \u2113) \u2192 P Respects _\u2261_\nresp P refl p = p\n\nresp\u02e1 : \u2200 (\u223c : Rel A \u2113) \u2192 \u223c Respects\u02e1 _\u2261_\nresp\u02e1 _\u223c_ refl x\u223cy = x\u223cy\n\nresp\u02b3 : \u2200 (\u223c : Rel A \u2113) \u2192 \u223c Respects\u02b3 _\u2261_\nresp\u02b3 _\u223c_ refl x\u223cy = x\u223cy\n\nresp\u2082 : \u2200 (\u223c : Rel A \u2113) \u2192 \u223c Respects\u2082 _\u2261_\nresp\u2082 _\u223c_ = resp\u02b3 _\u223c_ , resp\u02e1 _\u223c_\n\n------------------------------------------------------------------------\n-- Properties of _\u2262_\n\n\u2262-sym : Symmetric {A = A} _\u2262_\n\u2262-sym x\u2262y =  x\u2262y \u2218 sym\n</pre>"},{"location":"md/Relation/Binary/PropositionalEquality/Properties/","title":"Relation.Binary.PropositionalEquality.Properties","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Propositional equality\n--\n-- This file contains some core properies of propositional equality\n-- which are re-exported by Relation.Binary.PropositionalEquality. They\n-- are ``equality rearrangement'' lemmas.\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Binary.PropositionalEquality.Properties where\n\nopen import Function.Base using (id; _\u2218_)\nopen import Level using (Level)\nopen import Relation.Binary.Bundles\n  using (Setoid; DecSetoid; Preorder; Poset)\nopen import Relation.Binary.Structures\n  using (IsEquivalence; IsDecEquivalence; IsPreorder; IsPartialOrder)\nopen import Relation.Binary.Definitions\n  using (DecidableEquality)\nimport Relation.Binary.Properties.Setoid as Setoid\nopen import Relation.Binary.PropositionalEquality.Core\nopen import Relation.Unary using (Pred)\nopen import Relation.Binary.Reasoning.Syntax\n\n\nprivate\n  variable\n    a b c p : Level\n    A B C : Set a\n\n------------------------------------------------------------------------\n-- Standard eliminator for the propositional equality type\n\nJ : {A : Set a} {x : A} (B : (y : A) \u2192 x \u2261 y \u2192 Set b)\n    {y : A} (p : x \u2261 y) \u2192 B x refl \u2192 B y p\nJ B refl b = b\n\n------------------------------------------------------------------------\n-- Binary and/or dependent versions of standard operations on equality\n\ndcong : \u2200 {A : Set a} {B : A \u2192 Set b} (f : (x : A) \u2192 B x) {x y}\n      \u2192 (p : x \u2261 y) \u2192 subst B p (f x) \u2261 f y\ndcong f refl = refl\n\ndcong\u2082 : \u2200 {A : Set a} {B : A \u2192 Set b} {C : Set c}\n         (f : (x : A) \u2192 B x \u2192 C) {x\u2081 x\u2082 y\u2081 y\u2082}\n       \u2192 (p : x\u2081 \u2261 x\u2082) \u2192 subst B p y\u2081 \u2261 y\u2082\n       \u2192 f x\u2081 y\u2081 \u2261 f x\u2082 y\u2082\ndcong\u2082 f refl refl = refl\n\ndsubst\u2082 : \u2200 {A : Set a} {B : A \u2192 Set b} (C : (x : A) \u2192 B x \u2192 Set c)\n          {x\u2081 x\u2082 y\u2081 y\u2082} (p : x\u2081 \u2261 x\u2082) \u2192 subst B p y\u2081 \u2261 y\u2082\n        \u2192 C x\u2081 y\u2081 \u2192 C x\u2082 y\u2082\ndsubst\u2082 C refl refl c = c\n\nddcong\u2082 : \u2200 {A : Set a} {B : A \u2192 Set b} {C : (x : A) \u2192 B x \u2192 Set c}\n         (f : (x : A) (y : B x) \u2192 C x y) {x\u2081 x\u2082 y\u2081 y\u2082}\n         (p : x\u2081 \u2261 x\u2082) (q : subst B p y\u2081 \u2261 y\u2082)\n       \u2192 dsubst\u2082 C p q (f x\u2081 y\u2081) \u2261 f x\u2082 y\u2082\nddcong\u2082 f refl refl = refl\n\n------------------------------------------------------------------------\n-- Various equality rearrangement lemmas\n\ntrans-refl\u02b3 : \u2200 {x y : A} (p : x \u2261 y) \u2192 trans p refl \u2261 p\ntrans-refl\u02b3 refl = refl\n\ntrans-assoc : \u2200 {x y z u : A} (p : x \u2261 y) {q : y \u2261 z} {r : z \u2261 u} \u2192\n  trans (trans p q) r \u2261 trans p (trans q r)\ntrans-assoc refl = refl\n\ntrans-sym\u02e1 : \u2200 {x y : A} (p : x \u2261 y) \u2192 trans (sym p) p \u2261 refl\ntrans-sym\u02e1 refl = refl\n\ntrans-sym\u02b3 : \u2200 {x y : A} (p : x \u2261 y) \u2192 trans p (sym p) \u2261 refl\ntrans-sym\u02b3 refl = refl\n\ntrans-injective\u02e1 : \u2200 {x y z : A} {p\u2081 p\u2082 : x \u2261 y} (q : y \u2261 z) \u2192\n                   trans p\u2081 q \u2261 trans p\u2082 q \u2192 p\u2081 \u2261 p\u2082\ntrans-injective\u02e1 refl = subst\u2082 _\u2261_ (trans-refl\u02b3 _) (trans-refl\u02b3 _)\n\ntrans-injective\u02b3 : \u2200 {x y z : A} (p : x \u2261 y) {q\u2081 q\u2082 : y \u2261 z} \u2192\n                   trans p q\u2081 \u2261 trans p q\u2082 \u2192 q\u2081 \u2261 q\u2082\ntrans-injective\u02b3 refl eq = eq\n\ncong-id : \u2200 {x y : A} (p : x \u2261 y) \u2192 cong id p \u2261 p\ncong-id refl = refl\n\ncong-\u2218 : \u2200 {x y : A} {f : B \u2192 C} {g : A \u2192 B} (p : x \u2261 y) \u2192\n         cong (f \u2218 g) p \u2261 cong f (cong g p)\ncong-\u2218 refl = refl\n\nsym-cong : \u2200 {x y : A} {f : A \u2192 B} (p : x \u2261 y) \u2192 sym (cong f p) \u2261 cong f (sym p)\nsym-cong refl = refl\n\ntrans-cong : \u2200 {x y z : A} {f : A \u2192 B} (p : x \u2261 y) {q : y \u2261 z} \u2192\n             trans (cong f p) (cong f q) \u2261 cong f (trans p q)\ntrans-cong refl = refl\n\ncong\u2082-refl\u02e1 : \u2200 {_\u2219_ : A \u2192 B \u2192 C} {x u v} \u2192 (p : u \u2261 v) \u2192\n              cong\u2082 _\u2219_ refl p \u2261 cong (x \u2219_) p\ncong\u2082-refl\u02e1 refl = refl\n\ncong\u2082-refl\u02b3 : \u2200 {_\u2219_ : A \u2192 B \u2192 C} {x y u} \u2192 (p : x \u2261 y) \u2192\n              cong\u2082 _\u2219_ p refl \u2261 cong (_\u2219 u) p\ncong\u2082-refl\u02b3 refl = refl\n\nmodule _ {P : Pred A p} {x y : A} where\n\n  subst-injective : \u2200 (x\u2261y : x \u2261 y) {p q : P x} \u2192\n                    subst P x\u2261y p \u2261 subst P x\u2261y q \u2192 p \u2261 q\n  subst-injective refl p\u2261q = p\u2261q\n\n  subst-subst : \u2200 {z} (x\u2261y : x \u2261 y) {y\u2261z : y \u2261 z} {p : P x} \u2192\n                subst P y\u2261z (subst P x\u2261y p) \u2261 subst P (trans x\u2261y y\u2261z) p\n  subst-subst refl = refl\n\n  subst-subst-sym : (x\u2261y : x \u2261 y) {p : P y} \u2192\n                    subst P x\u2261y (subst P (sym x\u2261y) p) \u2261 p\n  subst-subst-sym refl = refl\n\n  subst-sym-subst : (x\u2261y : x \u2261 y) {p : P x} \u2192\n                    subst P (sym x\u2261y) (subst P x\u2261y p) \u2261 p\n  subst-sym-subst refl = refl\n\nsubst-\u2218 : \u2200 {x y : A} {P : Pred B p} {f : A \u2192 B}\n          (x\u2261y : x \u2261 y) {p : P (f x)} \u2192\n          subst (P \u2218 f) x\u2261y p \u2261 subst P (cong f x\u2261y) p\nsubst-\u2218 refl = refl\n\n-- Lemma 2.3.11 in the HoTT book, and `transport_map` in the UniMath\n-- library\nsubst-application\u2032 : \u2200 {a b\u2081 b\u2082} {A : Set a}\n                     (B\u2081 : A \u2192 Set b\u2081) {B\u2082 : A \u2192 Set b\u2082}\n                     {x\u2081 x\u2082 : A} {y : B\u2081 x\u2081}\n                     (g : \u2200 x \u2192 B\u2081 x \u2192 B\u2082 x) (eq : x\u2081 \u2261 x\u2082) \u2192\n                     subst B\u2082 eq (g x\u2081 y) \u2261 g x\u2082 (subst B\u2081 eq y)\nsubst-application\u2032 _ _ refl = refl\n\nsubst-application : \u2200 {a\u2081 a\u2082 b\u2081 b\u2082} {A\u2081 : Set a\u2081} {A\u2082 : Set a\u2082}\n                    (B\u2081 : A\u2081 \u2192 Set b\u2081) {B\u2082 : A\u2082 \u2192 Set b\u2082}\n                    {f : A\u2082 \u2192 A\u2081} {x\u2081 x\u2082 : A\u2082} {y : B\u2081 (f x\u2081)}\n                    (g : \u2200 x \u2192 B\u2081 (f x) \u2192 B\u2082 x) (eq : x\u2081 \u2261 x\u2082) \u2192\n                    subst B\u2082 eq (g x\u2081 y) \u2261 g x\u2082 (subst B\u2081 (cong f eq) y)\nsubst-application _ _ refl = refl\n\n------------------------------------------------------------------------\n-- Structure of equality as a binary relation\n\nisEquivalence : IsEquivalence {A = A} _\u2261_\nisEquivalence = record\n  { refl  = refl\n  ; sym   = sym\n  ; trans = trans\n  }\n\nisDecEquivalence : DecidableEquality A \u2192 IsDecEquivalence _\u2261_\nisDecEquivalence _\u225f_ = record\n  { isEquivalence = isEquivalence\n  ; _\u225f_           = _\u225f_\n  }\n\nsetoid : Set a \u2192 Setoid _ _\nsetoid A = record\n  { Carrier       = A\n  ; _\u2248_           = _\u2261_\n  ; isEquivalence = isEquivalence\n  }\n\ndecSetoid : DecidableEquality A \u2192 DecSetoid _ _\ndecSetoid _\u225f_ = record\n  { _\u2248_              = _\u2261_\n  ; isDecEquivalence = isDecEquivalence _\u225f_\n  }\n\n------------------------------------------------------------------------\n-- Bundles for equality as a binary relation\n\nisPreorder : IsPreorder {A = A} _\u2261_ _\u2261_\nisPreorder = Setoid.\u2248-isPreorder (setoid _)\n\nisPartialOrder : IsPartialOrder {A = A} _\u2261_ _\u2261_\nisPartialOrder = Setoid.\u2248-isPartialOrder (setoid _)\n\npreorder : Set a \u2192 Preorder _ _ _\npreorder A = Setoid.\u2248-preorder (setoid A)\n\nposet : Set a \u2192 Poset _ _ _\nposet A = Setoid.\u2248-poset (setoid A)\n\n------------------------------------------------------------------------\n-- Reasoning\n\n-- This is a special instance of `Relation.Binary.Reasoning.Setoid`.\n-- Rather than instantiating the latter with (setoid A), we reimplement\n-- equation chains from scratch since then goals are printed much more\n-- readably.\nmodule \u2261-Reasoning {a} {A : Set a} where\n\n  open begin-syntax {A = A} _\u2261_ id public\n  open \u2261-syntax {A = A} _\u2261_ trans public\n  open end-syntax {A = A} _\u2261_ refl public\n</pre>"},{"location":"md/Relation/Binary/Reasoning/Syntax/","title":"Relation.Binary.Reasoning.Syntax","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Syntax for the building blocks of equational reasoning modules\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Level using (Level; _\u2294_; suc)\nopen import Relation.Nullary.Decidable.Core\n  using (Dec; True; toWitness)\nopen import Relation.Nullary.Negation.Core using (contradiction)\nopen import Relation.Binary.Core using (Rel; REL; _\u21d2_)\nopen import Relation.Binary.Definitions\n  using (_Respects\u02b3_; Asymmetric; Trans; Sym; Reflexive)\nopen import Relation.Binary.PropositionalEquality.Core as \u2261\n  using (_\u2261_)\n\n-- List of `Reasoning` modules that do not use this framework and so\n-- need to be updated manually if the syntax changes.\n--\n--   Data/Vec/Relation/Binary/Equality/Cast\n--   Relation/Binary/HeterogeneousEquality\n--   Effect/Monad/Partiality\n--   Effect/Monad/Partiality/All\n--   Codata/Guarded/Stream/Relation/Binary/Pointwise\n--   Function/Reasoning\n\nmodule Relation.Binary.Reasoning.Syntax where\n\nprivate\n  variable\n    a \u2113\u2081 \u2113\u2082 \u2113\u2083 \u2113\u2084 : Level\n    A B C : Set a\n    x y z : A\n\n------------------------------------------------------------------------\n-- Syntax for beginning a reasoning chain\n------------------------------------------------------------------------\n\n------------------------------------------------------------------------\n-- Basic begin syntax\n\nmodule begin-syntax\n  (R : REL A B \u2113\u2081)\n  {S : REL A B \u2113\u2082}\n  (reflexive : R \u21d2 S)\n  where\n\n  infix 1 begin_\n\n  begin_ : R x y \u2192 S x y\n  begin_ = reflexive\n\n------------------------------------------------------------------------\n-- Begin subrelation syntax\n\n-- Sometimes we want to support sub-relations with the\n-- same reasoning operators as the main relations (e.g. perform equality\n-- proofs with non-strict reasoning operators). This record bundles all\n-- the parts needed to extract the sub-relation proofs.\nrecord SubRelation {A : Set a} (R : Rel A \u2113\u2081) \u2113\u2082 \u2113\u2083 : Set (a \u2294 \u2113\u2081 \u2294 suc \u2113\u2082 \u2294 suc \u2113\u2083) where\n  field\n    S : Rel A \u2113\u2082\n    IsS : R x y \u2192 Set \u2113\u2083\n    IsS? : \u2200 (xRy : R x y) \u2192 Dec (IsS xRy)\n    extract : \u2200 {xRy : R x y} \u2192 IsS xRy \u2192 S x y\n\nmodule begin-subrelation-syntax\n  (R : Rel A \u2113\u2081)\n  (sub : SubRelation R \u2113\u2082 \u2113\u2083)\n  where\n  open SubRelation sub\n\n  infix 1 begin_\n\n  begin_ : \u2200 {x y} (xRy : R x y) \u2192 {s : True (IsS? xRy)} \u2192 S x y\n  begin_ r {s} = extract (toWitness s)\n\n-- Begin equality syntax\nmodule begin-equality-syntax\n  (R : Rel A \u2113\u2081)\n  (sub : SubRelation R \u2113\u2082 \u2113\u2083) where\n\n  open begin-subrelation-syntax R sub public\n    renaming (begin_ to begin-equality_)\n\n-- Begin apartness syntax\nmodule begin-apartness-syntax\n  (R : Rel A \u2113\u2081)\n  (sub : SubRelation R \u2113\u2082 \u2113\u2083) where\n\n  open begin-subrelation-syntax R sub public\n    renaming (begin_ to begin-apartness_)\n\n-- Begin strict syntax\nmodule begin-strict-syntax\n  (R : Rel A \u2113\u2081)\n  (sub : SubRelation R \u2113\u2082 \u2113\u2083) where\n\n  open begin-subrelation-syntax R sub public\n    renaming (begin_ to begin-strict_)\n\n------------------------------------------------------------------------\n-- Begin membership syntax\n\nmodule begin-membership-syntax\n  (R : Rel A \u2113\u2081)\n  (_\u2208_ : REL B A \u2113\u2082)\n  (resp : _\u2208_ Respects\u02b3 R) where\n\n  infix  1 step-\u2208\n\n  step-\u2208 : \u2200 (x : B) {xs ys} \u2192 R xs ys \u2192 x \u2208 xs \u2192 x \u2208 ys\n  step-\u2208 x = resp\n\n  syntax step-\u2208 x  xs\u2286ys x\u2208xs  = x \u2208\u27e8 x\u2208xs \u27e9 xs\u2286ys\n\n------------------------------------------------------------------------\n-- Begin contradiction syntax\n\n-- Used with asymmetric subrelations to derive a contradiction from a\n-- proof that an element is related to itself.\nmodule begin-contradiction-syntax\n  (R : Rel A \u2113\u2081)\n  (sub : SubRelation R \u2113\u2082 \u2113\u2083)\n  (asym : Asymmetric (SubRelation.S sub))\n  where\n\n  open SubRelation sub\n\n  infix 1 begin-contradiction_\n\n  begin-contradiction_ : \u2200 (xRx : R x x) {s : True (IsS? xRx)} \u2192\n                         \u2200 {b} {B : Set b} \u2192 B\n  begin-contradiction_ {x} r {s} = contradiction x&lt;x (asym x&lt;x)\n    where\n    x&lt;x : S x x\n    x&lt;x = extract (toWitness s)\n\n------------------------------------------------------------------------\n-- Syntax for continuing a chain of reasoning steps\n------------------------------------------------------------------------\n\n-- Note that the arguments to the `step`s are not provided in their\n-- \"natural\" order and syntax declarations are later used to re-order\n-- them. This is because the `step` ordering allows the type-checker to\n-- better infer the middle argument `y` from the `_IsRelatedTo_`\n-- argument (see issue 622).\n--\n-- This has two practical benefits. First it speeds up type-checking by\n-- approximately a factor of 5. Secondly it allows the combinators to be\n-- used with macros that use reflection, e.g. `Tactic.RingSolver`, where\n-- they need to be able to extract `y` using reflection.\n\n------------------------------------------------------------------------\n-- Syntax for unidirectional relations\n\n-- See https://github.com/agda/agda-stdlib/issues/2150 for a possible\n-- simplification.\n\nmodule _\n  {R : REL A B \u2113\u2082}\n  (S : REL B C \u2113\u2081)\n  (T : REL A C \u2113\u2083)\n  (step : Trans R S T)\n  where\n\n  forward : \u2200 (x : A) {y z} \u2192 S y z \u2192 R x y \u2192 T x z\n  forward x yRz x\u223cy = step {x} x\u223cy yRz\n\n  -- Arbitrary relation syntax\n  module \u223c-syntax where\n    infixr 2 step-\u223c\n    step-\u223c = forward\n    syntax step-\u223c x yRz x\u223cy = x \u223c\u27e8 x\u223cy \u27e9 yRz\n\n\n  -- Preorder syntax\n  module \u2272-syntax where\n    infixr 2 step-\u2272\n    step-\u2272 = forward\n    syntax step-\u2272 x yRz x\u2272y = x \u2272\u27e8 x\u2272y \u27e9 yRz\n\n\n  -- Partial order syntax\n  module \u2264-syntax where\n    infixr 2 step-\u2264\n    step-\u2264 = forward\n    syntax step-\u2264 x yRz x\u2264y = x \u2264\u27e8 x\u2264y \u27e9 yRz\n\n\n  -- Strict partial order syntax\n  module &lt;-syntax where\n    infixr 2 step-&lt;\n    step-&lt; = forward\n    syntax step-&lt; x yRz x&lt;y = x &lt;\u27e8 x&lt;y \u27e9 yRz\n\n\n  -- Subset order syntax\n  module \u2286-syntax where\n    infixr 2 step-\u2286\n    step-\u2286 = forward\n    syntax step-\u2286 x yRz x\u2286y = x \u2286\u27e8 x\u2286y \u27e9 yRz\n\n\n  -- Strict subset order syntax\n  module \u2282-syntax where\n    infixr 2 step-\u2282\n    step-\u2282 = forward\n    syntax step-\u2282 x yRz x\u2282y = x \u2282\u27e8 x\u2282y \u27e9 yRz\n\n\n  -- Square subset order syntax\n  module \u2291-syntax where\n    infixr 2 step-\u2291\n    step-\u2291 = forward\n    syntax step-\u2291 x yRz x\u2291y = x \u2291\u27e8 x\u2291y \u27e9 yRz\n\n\n  -- Strict square subset order syntax\n  module \u228f-syntax where\n    infixr 2 step-\u228f\n    step-\u228f = forward\n    syntax step-\u228f x yRz x\u228fy = x \u228f\u27e8 x\u228fy \u27e9 yRz\n\n\n  -- Divisibility syntax\n  module \u2223-syntax where\n    infixr 2 step-\u2223\n    step-\u2223 = forward\n    syntax step-\u2223 x yRz x\u2223y = x \u2223\u27e8 x\u2223y \u27e9 yRz\n\n\n  -- Single-step syntax\n  module \u27f6-syntax where\n    infixr 2 step-\u27f6\n    step-\u27f6 = forward\n    syntax step-\u27f6 x yRz x\u2223y = x \u27f6\u27e8 x\u2223y \u27e9 yRz\n\n\n  -- Multi-step syntax\n  module \u27f6*-syntax where\n    infixr 2 step-\u27f6*\n    step-\u27f6* = forward\n    syntax step-\u27f6* x yRz x\u2223y = x \u27f6*\u27e8 x\u2223y \u27e9 yRz\n\n\n------------------------------------------------------------------------\n-- Syntax for bidirectional relations\n\n  module _\n    {U : REL B A \u2113\u2084}\n    (sym : Sym U R)\n    where\n\n    backward : \u2200 x {y z} \u2192 S y z \u2192 U y x \u2192 T x z\n    backward x yRz x\u2248y = forward x yRz (sym x\u2248y)\n\n    -- Setoid equality syntax\n    module \u2248-syntax where\n      infixr 2 step-\u2248-\u27e9 step-\u2248-\u27e8\n      step-\u2248-\u27e9 = forward\n      step-\u2248-\u27e8 = backward\n      syntax step-\u2248-\u27e9 x yRz x\u2248y = x \u2248\u27e8 x\u2248y \u27e9 yRz\n      syntax step-\u2248-\u27e8 x yRz y\u2248x = x \u2248\u27e8 y\u2248x \u27e8 yRz\n\n      -- Deprecated\n      infixr 2 step-\u2248 step-\u2248\u02d8\n      step-\u2248 = step-\u2248-\u27e9\n      {-# WARNING_ON_USAGE step-\u2248\n      \"Warning: step-\u2248 was deprecated in v2.0.\n      Please use step-\u2248-\u27e9 instead.\"\n      #-}\n      step-\u2248\u02d8 = step-\u2248-\u27e8\n      {-# WARNING_ON_USAGE step-\u2248\u02d8\n      \"Warning: step-\u2248\u02d8 and _\u2248\u02d8\u27e8_\u27e9_ was deprecated in v2.0.\n      Please use step-\u2248-\u27e8 and _\u2248\u27e8_\u27e8_ instead.\"\n      #-}\n      syntax step-\u2248\u02d8 x yRz y\u2248x = x \u2248\u02d8\u27e8 y\u2248x \u27e9 yRz\n\n\n    -- Container equality syntax\n    module \u224b-syntax where\n      infixr 2 step-\u224b-\u27e9 step-\u224b-\u27e8\n      step-\u224b-\u27e9 = forward\n      step-\u224b-\u27e8 = backward\n      syntax step-\u224b-\u27e9 x yRz x\u224by = x \u224b\u27e8 x\u224by \u27e9 yRz\n      syntax step-\u224b-\u27e8 x yRz y\u224bx = x \u224b\u27e8 y\u224bx \u27e8 yRz\n\n\n      -- Don't remove until https://github.com/agda/agda/issues/5617 fixed.\n      infixr 2 step-\u224b step-\u224b\u02d8\n      step-\u224b = step-\u224b-\u27e9\n      {-# WARNING_ON_USAGE step-\u224b\n      \"Warning: step-\u224b was deprecated in v2.0.\n      Please use step-\u224b-\u27e9 instead.\"\n      #-}\n      step-\u224b\u02d8 = step-\u224b-\u27e8\n      {-# WARNING_ON_USAGE step-\u224b\u02d8\n      \"Warning: step-\u224b\u02d8 and _\u224b\u02d8\u27e8_\u27e9_ was deprecated in v2.0.\n      Please use step-\u224b-\u27e8 and _\u224b\u27e8_\u27e8_ instead.\"\n      #-}\n      syntax step-\u224b\u02d8 x yRz y\u224bx = x \u224b\u02d8\u27e8 y\u224bx \u27e9 yRz\n\n\n    -- Other equality syntax\n    module \u2243-syntax where\n      infixr 2 step-\u2243-\u27e9 step-\u2243-\u27e8\n      step-\u2243-\u27e9 = forward\n      step-\u2243-\u27e8 = backward\n      syntax step-\u2243-\u27e9 x yRz x\u2243y = x \u2243\u27e8 x\u2243y \u27e9 yRz\n      syntax step-\u2243-\u27e8 x yRz y\u2243x = x \u2243\u27e8 y\u2243x \u27e8 yRz\n\n\n    -- Apartness relation syntax\n    module #-syntax where\n      infixr 2 step-#-\u27e9 step-#-\u27e8\n      step-#-\u27e9 = forward\n      step-#-\u27e8 = backward\n      syntax step-#-\u27e9 x yRz x#y = x #\u27e8 x#y \u27e9 yRz\n      syntax step-#-\u27e8 x yRz y#x = x #\u27e8 y#x \u27e8 yRz\n\n      -- Don't remove until https://github.com/agda/agda/issues/5617 fixed.\n      infixr 2 step-# step-#\u02d8\n      step-# = step-#-\u27e9\n      {-# WARNING_ON_USAGE step-#\n      \"Warning: step-# was deprecated in v2.0.\n      Please use step-#-\u27e9 instead.\"\n      #-}\n      step-#\u02d8 = step-#-\u27e8\n      {-# WARNING_ON_USAGE step-#\u02d8\n      \"Warning: step-#\u02d8 and _#\u02d8\u27e8_\u27e9_ was deprecated in v2.0.\n      Please use step-#-\u27e8 and _#\u27e8_\u27e8_ instead.\"\n      #-}\n      syntax step-#\u02d8 x yRz y#x = x #\u02d8\u27e8 y#x \u27e9 yRz\n\n\n    -- Bijection syntax\n    module \u2916-syntax where\n      infixr 2 step-\u2916 step-\u2b3b\n      step-\u2916 = forward\n      step-\u2b3b = backward\n      syntax step-\u2916 x yRz x\u2916y = x \u2916\u27e8 x\u2916y \u27e9 yRz\n      syntax step-\u2b3b x yRz y\u2916x = x \u2b3b\u27e8 y\u2916x \u27e9 yRz\n\n\n    -- Inverse syntax\n    module \u2194-syntax where\n      infixr 2 step-\u2194-\u27e9 step-\u2194-\u27e8\n      step-\u2194-\u27e9 = forward\n      step-\u2194-\u27e8 = backward\n      syntax step-\u2194-\u27e9 x yRz x\u2194y = x \u2194\u27e8 x\u2194y \u27e9 yRz\n      syntax step-\u2194-\u27e8 x yRz y\u2194x = x \u2194\u27e8 y\u2194x \u27e8 yRz\n\n\n    -- Inverse syntax\n    module \u21ad-syntax where\n      infixr 2 step-\u21ad-\u27e9 step-\u21ad-\u27e8\n      step-\u21ad-\u27e9 = forward\n      step-\u21ad-\u27e8 = backward\n      syntax step-\u21ad-\u27e9 x yRz x\u21ady = x \u21ad\u27e8 x\u21ady \u27e9 yRz\n      syntax step-\u21ad-\u27e8 x yRz y\u21adx = x \u21ad\u27e8 y\u21adx \u27e8 yRz\n\n\n      -- Don't remove until https://github.com/agda/agda/issues/5617 fixed.\n      infixr 2 step-\u21ad step-\u21ad\u02d8\n      step-\u21ad = forward\n      {-# WARNING_ON_USAGE step-\u21ad\n      \"Warning: step-\u21ad was deprecated in v2.0.\n      Please use step-\u21ad-\u27e9 instead.\"\n      #-}\n      step-\u21ad\u02d8 = backward\n      {-# WARNING_ON_USAGE step-\u21ad\u02d8\n      \"Warning: step-\u21ad\u02d8 and _\u21ad\u02d8\u27e8_\u27e9_ was deprecated in v2.0.\n      Please use step-\u21ad-\u27e8 and _\u21ad\u27e8_\u27e8_ instead.\"\n      #-}\n      syntax step-\u21ad\u02d8 x yRz y\u21adx = x \u21ad\u02d8\u27e8 y\u21adx \u27e9 yRz\n\n------------------------------------------------------------------------\n-- Propositional equality\n\n-- Crucially often the step function cannot just be `subst` or pattern\n-- match on `refl` as we often want to compute which constructor the\n-- relation begins with, in order for the implicit subrelation\n-- arguments to resolve. See `\u2261-noncomputable-syntax` below if this\n-- is not required.\nmodule \u2261-syntax\n  (R : REL A B \u2113\u2081)\n  (step : Trans _\u2261_ R R)\n  where\n\n  infixr 2 step-\u2261-\u27e9  step-\u2261-\u2223 step-\u2261-\u27e8\n  step-\u2261-\u27e9 = forward R R step\n\n  step-\u2261-\u2223 : \u2200 x {y} \u2192 R x y \u2192 R x y\n  step-\u2261-\u2223 x xRy = xRy\n\n  step-\u2261-\u27e8 = backward R R step \u2261.sym\n\n  syntax step-\u2261-\u27e9 x yRz x\u2261y = x \u2261\u27e8 x\u2261y \u27e9 yRz\n  syntax step-\u2261-\u2223 x xRy     = x \u2261\u27e8\u27e9 xRy\n  syntax step-\u2261-\u27e8 x yRz y\u2261x = x \u2261\u27e8 y\u2261x \u27e8 yRz\n\n\n  -- Don't remove until https://github.com/agda/agda/issues/5617 fixed.\n  infixr 2 step-\u2261 step-\u2261\u02d8\n  step-\u2261 = step-\u2261-\u27e9\n  {-# WARNING_ON_USAGE step-\u2261\n  \"Warning: step-\u2261 was deprecated in v2.0.\n  Please use step-\u2261-\u27e9 instead.\"\n  #-}\n  step-\u2261\u02d8 = step-\u2261-\u27e8\n  {-# WARNING_ON_USAGE step-\u2261\u02d8\n  \"Warning: step-\u2261\u02d8 and _\u2261\u02d8\u27e8_\u27e9_ was deprecated in v2.0.\n  Please use step-\u2261-\u27e8 and _\u2261\u27e8_\u27e8_ instead.\"\n  #-}\n  syntax step-\u2261\u02d8 x yRz y\u2261x = x \u2261\u02d8\u27e8 y\u2261x \u27e9 yRz\n\n\n-- Unlike \u2261-syntax above, chains of reasoning using this syntax will not\n-- reduce when proofs of propositional equality which are not definitionally\n-- equal to `refl` are passed.\nmodule \u2261-noncomputing-syntax (R : REL A B \u2113\u2081) where\n\n  private\n    step : Trans _\u2261_ R R\n    step \u2261.refl xRy = xRy\n\n  open \u2261-syntax R step public\n\n------------------------------------------------------------------------\n-- Syntax for ending a chain of reasoning\n------------------------------------------------------------------------\n\nmodule end-syntax\n  (R : Rel A \u2113\u2081)\n  (reflexive : Reflexive R)\n  where\n\n  infix 3 _\u220e\n\n  _\u220e : \u2200 x \u2192 R x x\n  x \u220e = reflexive\n\n</pre>"},{"location":"md/Relation/Binary/Structures/","title":"Relation.Binary.Structures","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Structures for homogeneous binary relations\n------------------------------------------------------------------------\n\n-- The contents of this module should be accessed via `Relation.Binary`.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nopen import Relation.Binary.Core\n\nmodule Relation.Binary.Structures\n  {a \u2113} {A : Set a} -- The underlying set\n  (_\u2248_ : Rel A \u2113)   -- The underlying equality relation\n  where\n\nopen import Data.Product.Base using (proj\u2081; proj\u2082; _,_)\nopen import Level using (Level; _\u2294_)\nopen import Relation.Nullary.Negation.Core using (\u00ac_)\nopen import Relation.Binary.PropositionalEquality.Core as \u2261 using (_\u2261_)\nopen import Relation.Binary.Consequences\nopen import Relation.Binary.Definitions\n\nprivate\n  variable\n    \u2113\u2082 : Level\n\n------------------------------------------------------------------------\n-- Equivalences\n------------------------------------------------------------------------\n-- Note all the following equivalences refer to the equality provided\n-- as a module parameter at the top of this file.\n\nrecord IsPartialEquivalence : Set (a \u2294 \u2113) where\n  field\n    sym   : Symmetric _\u2248_\n    trans : Transitive _\u2248_\n\n-- The preorders of this library are defined in terms of an underlying\n-- equivalence relation, and hence equivalence relations are not\n-- defined in terms of preorders.\n\n-- To preserve backwards compatability, equivalence relations are\n-- not defined in terms of their partial counterparts.\n\nrecord IsEquivalence : Set (a \u2294 \u2113) where\n  field\n    refl  : Reflexive _\u2248_\n    sym   : Symmetric _\u2248_\n    trans : Transitive _\u2248_\n\n  reflexive : _\u2261_ \u21d2 _\u2248_\n  reflexive \u2261.refl = refl\n\n  isPartialEquivalence : IsPartialEquivalence\n  isPartialEquivalence = record\n    { sym = sym\n    ; trans = trans\n    }\n\n\nrecord IsDecEquivalence : Set (a \u2294 \u2113) where\n  infix 4 _\u225f_\n  field\n    isEquivalence : IsEquivalence\n    _\u225f_           : Decidable _\u2248_\n\n  open IsEquivalence isEquivalence public\n\n\n------------------------------------------------------------------------\n-- Preorders\n------------------------------------------------------------------------\n\nrecord IsPreorder (_\u2272_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  field\n    isEquivalence : IsEquivalence\n    -- Reflexivity is expressed in terms of the underlying equality:\n    reflexive     : _\u2248_ \u21d2 _\u2272_\n    trans         : Transitive _\u2272_\n\n  module Eq = IsEquivalence isEquivalence\n\n  refl : Reflexive _\u2272_\n  refl = reflexive Eq.refl\n\n  \u2272-resp\u02e1-\u2248 : _\u2272_ Respects\u02e1 _\u2248_\n  \u2272-resp\u02e1-\u2248 x\u2248y x\u223cz = trans (reflexive (Eq.sym x\u2248y)) x\u223cz\n\n  \u2272-resp\u02b3-\u2248 : _\u2272_ Respects\u02b3 _\u2248_\n  \u2272-resp\u02b3-\u2248 x\u2248y z\u223cx = trans z\u223cx (reflexive x\u2248y)\n\n  \u2272-resp-\u2248 : _\u2272_ Respects\u2082 _\u2248_\n  \u2272-resp-\u2248 = \u2272-resp\u02b3-\u2248 , \u2272-resp\u02e1-\u2248\n\n  \u223c-resp\u02e1-\u2248 = \u2272-resp\u02e1-\u2248\n  {-# WARNING_ON_USAGE \u223c-resp\u02e1-\u2248\n  \"Warning: \u223c-resp\u02e1-\u2248 was deprecated in v2.0.\n  Please use \u2272-resp\u02e1-\u2248 instead. \"\n  #-}\n  \u223c-resp\u02b3-\u2248 = \u2272-resp\u02b3-\u2248\n  {-# WARNING_ON_USAGE \u223c-resp\u02b3-\u2248\n  \"Warning: \u223c-resp\u02b3-\u2248 was deprecated in v2.0.\n  Please use \u2272-resp\u02b3-\u2248 instead. \"\n  #-}\n  \u223c-resp-\u2248 = \u2272-resp-\u2248\n  {-# WARNING_ON_USAGE \u223c-resp-\u2248\n  \"Warning: \u223c-resp-\u2248 was deprecated in v2.0.\n  Please use \u2272-resp-\u2248 instead. \"\n  #-}\n\n\nrecord IsTotalPreorder (_\u2272_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  field\n    isPreorder : IsPreorder _\u2272_\n    total      : Total _\u2272_\n\n  open IsPreorder isPreorder public\n\n\nrecord IsDecPreorder (_\u2272_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  field\n    isPreorder : IsPreorder _\u2272_\n    _\u225f_        : Decidable _\u2248_\n    _\u2272?_       : Decidable _\u2272_\n\n  open IsPreorder isPreorder public\n    hiding (module Eq)\n\n  module Eq where\n\n    isDecEquivalence : IsDecEquivalence\n    isDecEquivalence = record\n      { isEquivalence = isEquivalence\n      ; _\u225f_           = _\u225f_\n      }\n\n    open IsDecEquivalence isDecEquivalence public\n\n\n------------------------------------------------------------------------\n-- Partial orders\n------------------------------------------------------------------------\n\nrecord IsPartialOrder (_\u2264_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  field\n    isPreorder : IsPreorder _\u2264_\n    antisym    : Antisymmetric _\u2248_ _\u2264_\n\n  open IsPreorder isPreorder public\n    renaming\n    ( \u223c-resp\u02e1-\u2248 to \u2264-resp\u02e1-\u2248\n    ; \u223c-resp\u02b3-\u2248 to \u2264-resp\u02b3-\u2248\n    ; \u223c-resp-\u2248  to \u2264-resp-\u2248\n    )\n\n\nrecord IsDecPartialOrder (_\u2264_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  infix 4 _\u225f_ _\u2264?_\n  field\n    isPartialOrder : IsPartialOrder _\u2264_\n    _\u225f_            : Decidable _\u2248_\n    _\u2264?_           : Decidable _\u2264_\n\n  open IsPartialOrder isPartialOrder public\n    hiding (module Eq)\n\n  isDecPreorder : IsDecPreorder _\u2264_\n  isDecPreorder = record\n    { isPreorder = isPreorder\n    ; _\u225f_ = _\u225f_\n    ; _\u2272?_ = _\u2264?_\n    }\n\n  open IsDecPreorder isDecPreorder public\n    using (module Eq)\n\n\nrecord IsStrictPartialOrder (_&lt;_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  field\n    isEquivalence : IsEquivalence\n    irrefl        : Irreflexive _\u2248_ _&lt;_\n    trans         : Transitive _&lt;_\n    &lt;-resp-\u2248      : _&lt;_ Respects\u2082 _\u2248_\n\n  module Eq = IsEquivalence isEquivalence\n\n  asym : Asymmetric _&lt;_\n  asym {x} {y} = trans\u2227irr\u21d2asym Eq.refl trans irrefl {x = x} {y}\n\n  &lt;-resp\u02b3-\u2248 : _&lt;_ Respects\u02b3 _\u2248_\n  &lt;-resp\u02b3-\u2248 = proj\u2081 &lt;-resp-\u2248\n\n  &lt;-resp\u02e1-\u2248 : _&lt;_ Respects\u02e1 _\u2248_\n  &lt;-resp\u02e1-\u2248 = proj\u2082 &lt;-resp-\u2248\n\n\nrecord IsDecStrictPartialOrder (_&lt;_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  infix 4 _\u225f_ _&lt;?_\n  field\n    isStrictPartialOrder : IsStrictPartialOrder _&lt;_\n    _\u225f_                  : Decidable _\u2248_\n    _&lt;?_                 : Decidable _&lt;_\n\n  private\n    module SPO = IsStrictPartialOrder isStrictPartialOrder\n\n  open SPO public hiding (module Eq)\n\n  module Eq where\n\n    isDecEquivalence : IsDecEquivalence\n    isDecEquivalence = record\n      { isEquivalence = SPO.isEquivalence\n      ; _\u225f_           = _\u225f_\n      }\n\n    open IsDecEquivalence isDecEquivalence public\n\n\n------------------------------------------------------------------------\n-- Total orders\n------------------------------------------------------------------------\n\nrecord IsTotalOrder (_\u2264_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  field\n    isPartialOrder : IsPartialOrder _\u2264_\n    total          : Total _\u2264_\n\n  open IsPartialOrder isPartialOrder public\n\n  isTotalPreorder : IsTotalPreorder _\u2264_\n  isTotalPreorder = record\n    { isPreorder = isPreorder\n    ; total      = total\n    }\n\n\nrecord IsDecTotalOrder (_\u2264_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  infix 4 _\u225f_ _\u2264?_\n  field\n    isTotalOrder : IsTotalOrder _\u2264_\n    _\u225f_          : Decidable _\u2248_\n    _\u2264?_         : Decidable _\u2264_\n\n  open IsTotalOrder isTotalOrder public\n    hiding (module Eq)\n\n  isDecPartialOrder : IsDecPartialOrder _\u2264_\n  isDecPartialOrder = record\n    { isPartialOrder = isPartialOrder\n    ; _\u225f_            = _\u225f_\n    ; _\u2264?_           = _\u2264?_\n    }\n\n  open IsDecPartialOrder isDecPartialOrder public\n    using (isDecPreorder; module Eq)\n\n-- Note that these orders are decidable. The current implementation\n-- of `Trichotomous` subsumes irreflexivity and asymmetry. See\n-- `Relation.Binary.Structures.Biased` for ways of constructing this\n-- record without having to prove `isStrictPartialOrder`.\n\nrecord IsStrictTotalOrder (_&lt;_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  field\n    isStrictPartialOrder : IsStrictPartialOrder _&lt;_\n    compare              : Trichotomous _\u2248_ _&lt;_\n\n  open IsStrictPartialOrder isStrictPartialOrder public\n    hiding (module Eq)\n\n  -- `Trichotomous` necessarily separates out the equality case so\n  --  it implies decidability.\n  infix 4 _\u225f_ _&lt;?_\n\n  _\u225f_ : Decidable _\u2248_\n  _\u225f_ = tri\u21d2dec\u2248 compare\n\n  _&lt;?_ : Decidable _&lt;_\n  _&lt;?_ = tri\u21d2dec&lt; compare\n\n  isDecStrictPartialOrder : IsDecStrictPartialOrder _&lt;_\n  isDecStrictPartialOrder = record\n    { isStrictPartialOrder = isStrictPartialOrder\n    ; _\u225f_                  = _\u225f_\n    ; _&lt;?_                 = _&lt;?_\n    }\n\n  -- Redefine the `Eq` module to include decidability proofs\n  module Eq where\n\n    isDecEquivalence : IsDecEquivalence\n    isDecEquivalence = record\n      { isEquivalence = isEquivalence\n      ; _\u225f_           = _\u225f_\n      }\n\n    open IsDecEquivalence isDecEquivalence public\n\n  isDecEquivalence : IsDecEquivalence\n  isDecEquivalence = record\n    { isEquivalence = isEquivalence\n    ; _\u225f_           = _\u225f_\n    }\n  {-# WARNING_ON_USAGE isDecEquivalence\n  \"Warning: isDecEquivalence was deprecated in v2.0.\n  Please use Eq.isDecEquivalence instead. \"\n  #-}\n\nrecord IsDenseLinearOrder (_&lt;_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  field\n    isStrictTotalOrder : IsStrictTotalOrder _&lt;_\n    dense              : Dense _&lt;_\n\n  open IsStrictTotalOrder isStrictTotalOrder public\n\n\n------------------------------------------------------------------------\n-- Apartness relations\n------------------------------------------------------------------------\n\nrecord IsApartnessRelation (_#_ : Rel A \u2113\u2082) : Set (a \u2294 \u2113 \u2294 \u2113\u2082) where\n  field\n    irrefl  : Irreflexive _\u2248_ _#_\n    sym     : Symmetric _#_\n    cotrans : Cotransitive _#_\n\n  _\u00ac#_ : A \u2192 A \u2192 Set _\n  x \u00ac# y = \u00ac (x # y)\n</pre>"},{"location":"md/Relation/Nullary/","title":"Relation.Nullary","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Operations on nullary relations (like negation and decidability)\n------------------------------------------------------------------------\n\n-- Some operations on/properties of nullary relations, i.e. sets.\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Nullary where\n\nopen import Agda.Builtin.Equality using (_\u2261_)\nopen import Agda.Builtin.Maybe using (Maybe)\nopen import Level using (Level)\n\nprivate\n  variable\n    p : Level\n    P : Set p\n\n\n------------------------------------------------------------------------\n-- Re-exports\n\nopen import Relation.Nullary.Recomputable public using (Recomputable)\nopen import Relation.Nullary.Negation.Core public\nopen import Relation.Nullary.Reflects public hiding (recompute; recompute-constant)\nopen import Relation.Nullary.Decidable.Core public\n\n------------------------------------------------------------------------\n-- Irrelevant types\n\nIrrelevant : Set p \u2192 Set p\nIrrelevant P = \u2200 (p\u2081 p\u2082 : P) \u2192 p\u2081 \u2261 p\u2082\n\n------------------------------------------------------------------------\n-- Weak decidability\n-- `nothing` is 'don't know'/'give up'; `just` is `yes`/`definitely`\n\nWeaklyDecidable : Set p \u2192 Set p\nWeaklyDecidable = Maybe\n</pre>"},{"location":"md/Relation/Nullary/Decidable/","title":"Relation.Nullary.Decidable","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Operations on and properties of decidable relations\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Nullary.Decidable where\n\nopen import Level using (Level)\nopen import Data.Bool.Base using (true; false)\nopen import Data.Product.Base using (\u2203; _,_)\nopen import Function.Bundles using\n  (Injection; module Injection; module Equivalence; _\u21d4_; _\u2194_; mk\u2194\u209b\u2032)\nopen import Relation.Binary.Bundles using (Setoid; module Setoid)\nopen import Relation.Binary.Definitions using (Decidable)\nopen import Relation.Nullary using (Irrelevant)\nopen import Relation.Nullary.Negation.Core using (\u00ac_; contradiction)\nopen import Relation.Nullary.Reflects using (invert)\nopen import Relation.Binary.PropositionalEquality.Core\n  using (_\u2261_; refl; sym; trans; cong\u2032)\n\nprivate\n  variable\n    a b \u2113\u2081 \u2113\u2082 : Level\n    A B : Set a\n\n------------------------------------------------------------------------\n-- Re-exporting the core definitions\n\nopen import Relation.Nullary.Decidable.Core public\n\n------------------------------------------------------------------------\n-- Maps\n\nmap : A \u21d4 B \u2192 Dec A \u2192 Dec B\nmap A\u21d4B = map\u2032 to from\n  where open Equivalence A\u21d4B\n\n-- If there is an injection from one setoid to another, and the\n-- latter's equivalence relation is decidable, then the former's\n-- equivalence relation is also decidable.\nvia-injection : {S : Setoid a \u2113\u2081} {T : Setoid b \u2113\u2082}\n                (inj : Injection S T) (open Injection inj) \u2192\n                Decidable Eq\u2082._\u2248_ \u2192 Decidable Eq\u2081._\u2248_\nvia-injection inj _\u225f_ x y = map\u2032 injective cong (to x \u225f to y)\n  where open Injection inj\n\n------------------------------------------------------------------------\n-- A lemma relating True and Dec\n\nTrue-\u2194 : (a? : Dec A) \u2192 Irrelevant A \u2192 True a? \u2194 A\nTrue-\u2194 (true  because [a]) irr = let a = invert [a] in mk\u2194\u209b\u2032 (\u03bb _ \u2192 a) _ (irr a) cong\u2032\nTrue-\u2194 (false because [\u00aca]) _  = let \u00aca = invert [\u00aca] in mk\u2194\u209b\u2032 (\u03bb ()) \u00aca (\u03bb a \u2192 contradiction a \u00aca) \u03bb ()\n\n------------------------------------------------------------------------\n-- Result of decidability\n\nisYes\u2257does : (a? : Dec A) \u2192 isYes a? \u2261 does a?\nisYes\u2257does (true  because _) = refl\nisYes\u2257does (false because _) = refl\n\ndec-true : (a? : Dec A) \u2192 A \u2192 does a? \u2261 true\ndec-true (true  because   _ ) a = refl\ndec-true (false because [\u00aca]) a = contradiction a (invert [\u00aca])\n\ndec-false : (a? : Dec A) \u2192 \u00ac A \u2192 does a? \u2261 false\ndec-false (false because  _ ) \u00aca = refl\ndec-false (true  because [a]) \u00aca = contradiction (invert [a]) \u00aca\n\ndec-yes : (a? : Dec A) \u2192 A \u2192 \u2203 \u03bb a \u2192 a? \u2261 yes a\ndec-yes a? a with yes a\u2032 \u2190 a? | refl \u2190 dec-true a? a = a\u2032 , refl\n\ndec-no : (a? : Dec A) (\u00aca : \u00ac A) \u2192 a? \u2261 no \u00aca\ndec-no a? \u00aca with no _ \u2190 a? | refl \u2190 dec-false a? \u00aca = refl\n\ndec-yes-irr : (a? : Dec A) \u2192 Irrelevant A \u2192 (a : A) \u2192 a? \u2261 yes a\ndec-yes-irr a? irr a with a\u2032 , eq \u2190 dec-yes a? a rewrite irr a a\u2032 = eq\n\n\u230a\u230b-map\u2032 : \u2200 t f (a? : Dec A) \u2192 \u230a map\u2032 {B = B} t f a? \u230b \u2261 \u230a a? \u230b\n\u230a\u230b-map\u2032 t f a? = trans (isYes\u2257does (map\u2032 t f a?)) (sym (isYes\u2257does a?))\n\ndoes-\u2261 : (a? b? : Dec A) \u2192 does a? \u2261 does b?\ndoes-\u2261 a? (yes a) = dec-true a? a\ndoes-\u2261 a? (no \u00aca) = dec-false a? \u00aca\n\ndoes-\u21d4 : A \u21d4 B \u2192 (a? : Dec A) \u2192 (b? : Dec B) \u2192 does a? \u2261 does b?\ndoes-\u21d4 A\u21d4B a? = does-\u2261 (map A\u21d4B a?)\n</pre>"},{"location":"md/Relation/Nullary/Decidable/Core/","title":"Relation.Nullary.Decidable.Core","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Operations on and properties of decidable relations\n--\n-- This file contains some core definitions which are re-exported by\n-- Relation.Nullary.Decidable\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Nullary.Decidable.Core where\n\n-- decToMaybe was deprecated in v2.1 #2330/#2336\n-- this can go through `Data.Maybe.Base` once that deprecation is fully done.\nopen import Agda.Builtin.Maybe using (Maybe; just; nothing)\n\nopen import Agda.Builtin.Equality using (_\u2261_)\nopen import Level using (Level)\nopen import Data.Bool.Base using (Bool; T; false; true; not; _\u2227_; _\u2228_)\nopen import Data.Unit.Polymorphic.Base using (\u22a4)\nopen import Data.Product.Base using (_\u00d7_)\nopen import Data.Sum.Base using (_\u228e_; inj\u2081; inj\u2082)\nopen import Function.Base using (_\u2218_; const; _$_; flip)\nopen import Relation.Nullary.Recomputable as Recomputable hiding (recompute-constant)\nopen import Relation.Nullary.Reflects as Reflects hiding (recompute; recompute-constant)\nopen import Relation.Nullary.Negation.Core\n  using (\u00ac_; Stable; negated-stable; contradiction; DoubleNegation)\n\n\nprivate\n  variable\n    a b : Level\n    A B : Set a\n\n------------------------------------------------------------------------\n-- Definition.\n\n-- Decidability proofs have two parts: the `does` term which contains\n-- the boolean result and the `proof` term which contains a proof that\n-- reflects the boolean result. This definition allows the boolean\n-- part of the decision procedure to compute independently from the\n-- proof. This leads to better computational behaviour when we only care\n-- about the result and not the proof. See README.Design.Decidability\n-- for further details.\n\ninfix 2 _because_\n\nrecord Dec (A : Set a) : Set a where\n  constructor _because_\n  field\n    does  : Bool\n    proof : Reflects A does\n\nopen Dec public\n\npattern yes a =  true because of\u02b8  a\npattern no \u00aca = false because of\u207f \u00aca\n\n------------------------------------------------------------------------\n-- Flattening\n\nmodule _ {A : Set a} where\n\n  From-yes : Dec A \u2192 Set a\n  From-yes (true  because _) = A\n  From-yes (false because _) = \u22a4\n\n  From-no : Dec A \u2192 Set a\n  From-no (false because _) = \u00ac A\n  From-no (true  because _) = \u22a4\n\n------------------------------------------------------------------------\n-- Recompute\n\n-- Given an irrelevant proof of a decidable type, a proof can\n-- be recomputed and subsequently used in relevant contexts.\n\nrecompute : Dec A \u2192 Recomputable A\nrecompute = Reflects.recompute \u2218 proof\n\nrecompute-constant : (a? : Dec A) (p q : A) \u2192 recompute a? p \u2261 recompute a? q\nrecompute-constant = Recomputable.recompute-constant \u2218 recompute\n\n------------------------------------------------------------------------\n-- Interaction with negation, sum, product etc.\n\ninfixr 1 _\u228e-dec_\ninfixr 2 _\u00d7-dec_ _\u2192-dec_\n\nT? : \u2200 x \u2192 Dec (T x)\nT? x = x because T-reflects x\n\n\u00ac? : Dec A \u2192 Dec (\u00ac A)\ndoes  (\u00ac? a?) = not (does a?)\nproof (\u00ac? a?) = \u00ac-reflects (proof a?)\n\n_\u00d7-dec_ : Dec A \u2192 Dec B \u2192 Dec (A \u00d7 B)\ndoes  (a? \u00d7-dec b?) = does a? \u2227 does b?\nproof (a? \u00d7-dec b?) = proof a? \u00d7-reflects proof b?\n\n_\u228e-dec_ : Dec A \u2192 Dec B \u2192 Dec (A \u228e B)\ndoes  (a? \u228e-dec b?) = does a? \u2228 does b?\nproof (a? \u228e-dec b?) = proof a? \u228e-reflects proof b?\n\n_\u2192-dec_ : Dec A \u2192 Dec B \u2192 Dec (A \u2192 B)\ndoes  (a? \u2192-dec b?) = not (does a?) \u2228 does b?\nproof (a? \u2192-dec b?) = proof a? \u2192-reflects proof b?\n\n------------------------------------------------------------------------\n-- Relationship with Maybe\n\ndec\u21d2maybe : Dec A \u2192 Maybe A\ndec\u21d2maybe ( true because [a]) = just (invert [a])\ndec\u21d2maybe (false because  _ ) = nothing\n\n------------------------------------------------------------------------\n-- Relationship with Sum\n\ntoSum : Dec A \u2192 A \u228e \u00ac A\ntoSum ( true because  [p]) = inj\u2081 (invert  [p])\ntoSum (false because [\u00acp]) = inj\u2082 (invert [\u00acp])\n\nfromSum : A \u228e \u00ac A \u2192 Dec A\nfromSum (inj\u2081 p)  = yes p\nfromSum (inj\u2082 \u00acp) = no \u00acp\n\n------------------------------------------------------------------------\n-- Relationship with booleans\n\n-- `isYes` is a stricter version of `does`. The lack of computation\n-- means that we can recover the proposition `P` from `isYes a?` by\n-- unification. This is useful when we are using the decision procedure\n-- for proof automation.\n\nisYes : Dec A \u2192 Bool\nisYes (true  because _) = true\nisYes (false because _) = false\n\nisNo : Dec A \u2192 Bool\nisNo = not \u2218 isYes\n\nTrue : Dec A \u2192 Set\nTrue = T \u2218 isYes\n\nFalse : Dec A \u2192 Set\nFalse = T \u2218 isNo\n\n-- The traditional name for isYes is \u230a_\u230b, indicating the stripping of evidence.\n\u230a_\u230b = isYes\n\n------------------------------------------------------------------------\n-- Witnesses\n\n-- Gives a witness to the \"truth\".\ntoWitness : {a? : Dec A} \u2192 True a? \u2192 A\ntoWitness {a? = true  because [a]} _  = invert [a]\ntoWitness {a? = false because  _ } ()\n\n-- Establishes a \"truth\", given a witness.\nfromWitness : {a? : Dec A} \u2192 A \u2192 True a?\nfromWitness {a? = true  because   _ } = const _\nfromWitness {a? = false because [\u00aca]} = invert [\u00aca]\n\n-- Variants for False.\ntoWitnessFalse : {a? : Dec A} \u2192 False a? \u2192 \u00ac A\ntoWitnessFalse {a? = true  because   _ } ()\ntoWitnessFalse {a? = false because [\u00aca]} _  = invert [\u00aca]\n\nfromWitnessFalse : {a? : Dec A} \u2192 \u00ac A \u2192 False a?\nfromWitnessFalse {a? = true  because [a]} = flip _$_ (invert [a])\nfromWitnessFalse {a? = false because  _ } = const _\n\n-- If a decision procedure returns \"yes\", then we can extract the\n-- proof using from-yes.\nfrom-yes : (a? : Dec A) \u2192 From-yes a?\nfrom-yes (true  because [a]) = invert [a]\nfrom-yes (false because _ ) = _\n\n-- If a decision procedure returns \"no\", then we can extract the proof\n-- using from-no.\nfrom-no : (a? : Dec A) \u2192 From-no a?\nfrom-no (false because [\u00aca]) = invert [\u00aca]\nfrom-no (true  because   _ ) = _\n\n------------------------------------------------------------------------\n-- Maps\n\nmap\u2032 : (A \u2192 B) \u2192 (B \u2192 A) \u2192 Dec A \u2192 Dec B\ndoes  (map\u2032 A\u2192B B\u2192A a?)                   = does a?\nproof (map\u2032 A\u2192B B\u2192A (true  because  [a])) = of (A\u2192B (invert [a]))\nproof (map\u2032 A\u2192B B\u2192A (false because [\u00aca])) = of (invert [\u00aca] \u2218 B\u2192A)\n\n------------------------------------------------------------------------\n-- Relationship with double-negation\n\n-- Decidable predicates are stable.\n\ndecidable-stable : Dec A \u2192 Stable A\ndecidable-stable (true  because  [a]) \u00ac\u00aca = invert [a]\ndecidable-stable (false because [\u00aca]) \u00ac\u00aca = contradiction (invert [\u00aca]) \u00ac\u00aca\n\n\u00ac-drop-Dec : Dec (\u00ac \u00ac A) \u2192 Dec (\u00ac A)\n\u00ac-drop-Dec \u00ac\u00aca? = map\u2032 negated-stable contradiction (\u00ac? \u00ac\u00aca?)\n\n-- A double-negation-translated variant of excluded middle (or: every\n-- nullary relation is decidable in the double-negation monad).\n\n\u00ac\u00ac-excluded-middle : DoubleNegation (Dec A)\n\u00ac\u00ac-excluded-middle \u00ac?a = \u00ac?a (no (\u03bb a \u2192 \u00ac?a (yes a)))\n\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 2.0\n\nexcluded-middle = \u00ac\u00ac-excluded-middle\n{-# WARNING_ON_USAGE excluded-middle\n\"Warning: excluded-middle was deprecated in v2.0.\nPlease use \u00ac\u00ac-excluded-middle instead.\"\n#-}\n\n-- Version 2.1\n\ndecToMaybe = dec\u21d2maybe\n{-# WARNING_ON_USAGE decToMaybe\n\"Warning: decToMaybe was deprecated in v2.1.\nPlease use Relation.Nullary.Decidable.Core.dec\u21d2maybe instead.\"\n#-}\n\nfromDec = toSum\n{-# WARNING_ON_USAGE fromDec\n\"Warning: fromDec was deprecated in v2.1.\nPlease use Relation.Nullary.Decidable.Core.toSum instead.\"\n#-}\n\ntoDec = fromSum\n{-# WARNING_ON_USAGE toDec\n\"Warning: toDec was deprecated in v2.1.\nPlease use Relation.Nullary.Decidable.Core.fromSum instead.\"\n#-}\n</pre>"},{"location":"md/Relation/Nullary/Negation/","title":"Relation.Nullary.Negation","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Properties related to negation\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Nullary.Negation where\n\nopen import Data.Bool.Base using (Bool; false; true; if_then_else_)\nopen import Data.Product.Base as Product using (_,_; \u03a3; \u03a3-syntax; \u2203; curry; uncurry)\nopen import Data.Sum.Base as Sum using (_\u228e_; inj\u2081; inj\u2082; [_,_])\nopen import Effect.Monad using (RawMonad; mkRawMonad)\nopen import Function.Base using (flip; _\u2218_; const; _\u2218\u2032_)\nopen import Level using (Level)\nopen import Relation.Nullary.Decidable.Core using (Dec; yes; no; \u00ac\u00ac-excluded-middle)\nopen import Relation.Unary using (Universal; Pred)\n\nprivate\n  variable\n    a b c d p w : Level\n    A B C D : Set a\n    P : Pred A p\n    Whatever : Set w\n\n------------------------------------------------------------------------\n-- Re-export public definitions\n\nopen import Relation.Nullary.Negation.Core public\n\n------------------------------------------------------------------------\n-- Quantifier juggling\n\n\u2203\u27f6\u00ac\u2200\u00ac : \u2203 P \u2192 \u00ac (\u2200 x \u2192 \u00ac P x)\n\u2203\u27f6\u00ac\u2200\u00ac = flip uncurry\n\n\u2200\u27f6\u00ac\u2203\u00ac : (\u2200 x \u2192 P x) \u2192 \u00ac \u2203 \u03bb x \u2192 \u00ac P x\n\u2200\u27f6\u00ac\u2203\u00ac \u2200xPx (x , \u00acPx) = \u00acPx (\u2200xPx x)\n\n\u00ac\u2203\u27f6\u2200\u00ac : \u00ac \u2203 (\u03bb x \u2192 P x) \u2192 \u2200 x \u2192 \u00ac P x\n\u00ac\u2203\u27f6\u2200\u00ac = curry\n\n\u2200\u00ac\u27f6\u00ac\u2203 : (\u2200 x \u2192 \u00ac P x) \u2192 \u00ac \u2203 (\u03bb x \u2192 P x)\n\u2200\u00ac\u27f6\u00ac\u2203 = uncurry\n\n\u2203\u00ac\u27f6\u00ac\u2200 : \u2203 (\u03bb x \u2192 \u00ac P x) \u2192 \u00ac (\u2200 x \u2192 P x)\n\u2203\u00ac\u27f6\u00ac\u2200 = flip \u2200\u27f6\u00ac\u2203\u00ac\n\n------------------------------------------------------------------------\n-- Double Negation\n\n-- Double-negation is a monad (if we assume that all elements of \u00ac \u00ac P\n-- are equal).\n\n\u00ac\u00ac-Monad : RawMonad {a} DoubleNegation\n\u00ac\u00ac-Monad = mkRawMonad\n  DoubleNegation\n  contradiction\n  (\u03bb x f \u2192 negated-stable (\u00ac\u00ac-map f x))\n\n\u00ac\u00ac-push : DoubleNegation \u03a0[ P ] \u2192 \u03a0[ DoubleNegation \u2218 P ]\n\u00ac\u00ac-push \u00ac\u00ac\u2200P a \u00acPa = \u00ac\u00ac\u2200P (\u03bb \u2200P \u2192 \u00acPa (\u2200P a))\n\n-- If Whatever is instantiated with \u00ac\u00a0\u00ac\u00a0something, then this function\n-- is call with current continuation in the double-negation monad, or,\n-- if you will, a double-negation translation of Peirce's law.\n--\n-- In order to prove \u00ac\u00a0\u00ac\u00a0P one can assume \u00ac\u00a0P and prove \u22a5. However,\n-- sometimes it is nice to avoid leaving the double-negation monad; in\n-- that case this function can be used (with Whatever instantiated to\n-- \u22a5).\n\ncall/cc : ((A \u2192 Whatever) \u2192 DoubleNegation A) \u2192 DoubleNegation A\ncall/cc hyp \u00aca = hyp (flip contradiction \u00aca) \u00aca\n\n-- The \"independence of premise\" rule, in the double-negation monad.\n-- It is assumed that the index set (A) is inhabited.\n\nindependence-of-premise : A \u2192 (B \u2192 \u03a3 A P) \u2192 DoubleNegation (\u03a3[ x \u2208 A ] (B \u2192 P x))\nindependence-of-premise {A = A} {B = B} {P = P} q f = \u00ac\u00ac-map helper \u00ac\u00ac-excluded-middle\n  where\n  helper : Dec B \u2192 \u03a3[ x \u2208 A ] (B \u2192 P x)\n  helper (yes p) = Product.map\u2082 const (f p)\n  helper (no \u00acp) = (q , flip contradiction \u00acp)\n\n-- The independence of premise rule for binary sums.\n\nindependence-of-premise-\u228e : (A \u2192 B \u228e C) \u2192 DoubleNegation ((A \u2192 B) \u228e (A \u2192 C))\nindependence-of-premise-\u228e {A = A} {B = B} {C = C} f = \u00ac\u00ac-map helper \u00ac\u00ac-excluded-middle\n  where\n  helper : Dec A \u2192 (A \u2192 B) \u228e (A \u2192 C)\n  helper (yes p) = Sum.map const const (f p)\n  helper (no \u00acp) = inj\u2081 (flip contradiction \u00acp)\n\nprivate\n\n  -- Note that independence-of-premise-\u228e is a consequence of\n  -- independence-of-premise (for simplicity it is assumed that Q and\n  -- R have the same type here):\n\n  corollary : {B C : Set b} \u2192 (A \u2192 B \u228e C) \u2192 DoubleNegation ((A \u2192 B) \u228e (A \u2192 C))\n  corollary {A = A} {B = B} {C = C} f =\n    \u00ac\u00ac-map helper (independence-of-premise true ([ _,_ true , _,_ false ] \u2218\u2032 f))\n    where\n    helper : \u2203 (\u03bb b \u2192 A \u2192 if b then B else C) \u2192 (A \u2192 B) \u228e (A \u2192 C)\n    helper (true  , f) = inj\u2081 f\n    helper (false , f) = inj\u2082 f\n</pre>"},{"location":"md/Relation/Nullary/Negation/Core/","title":"Relation.Nullary.Negation.Core","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Core properties related to negation\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Nullary.Negation.Core where\n\nopen import Data.Empty using (\u22a5; \u22a5-elim-irr)\nopen import Data.Sum.Base using (_\u228e_; [_,_]; inj\u2081; inj\u2082)\nopen import Function.Base using (flip; _\u2218_; const)\nopen import Level\n\nprivate\n  variable\n    a p q w : Level\n    A B C : Set a\n    Whatever : Set w\n\n------------------------------------------------------------------------\n-- Negation.\n\ninfix 3 \u00ac_\n\u00ac_ : Set a \u2192 Set a\n\u00ac A = A \u2192 \u22a5\n\n------------------------------------------------------------------------\n-- Stability.\n\n-- Double-negation\nDoubleNegation : Set a \u2192 Set a\nDoubleNegation A = \u00ac \u00ac A\n\n-- Stability under double-negation.\nStable : Set a \u2192 Set a\nStable A = \u00ac \u00ac A \u2192 A\n\n------------------------------------------------------------------------\n-- Relationship to sum\n\ninfixr 1 _\u00ac-\u228e_\n_\u00ac-\u228e_ : \u00ac A \u2192 \u00ac B \u2192 \u00ac (A \u228e B)\n_\u00ac-\u228e_ = [_,_]\n\n------------------------------------------------------------------------\n-- Uses of negation\n\ncontradiction-irr : .A \u2192 \u00ac A \u2192 Whatever\ncontradiction-irr a \u00aca = \u22a5-elim-irr (\u00aca a)\n\ncontradiction : A \u2192 \u00ac A \u2192 Whatever\ncontradiction a = contradiction-irr a\n\ncontradiction\u2082 : A \u228e B \u2192 \u00ac A \u2192 \u00ac B \u2192 Whatever\ncontradiction\u2082 (inj\u2081 a) \u00aca \u00acb = contradiction a \u00aca\ncontradiction\u2082 (inj\u2082 b) \u00aca \u00acb = contradiction b \u00acb\n\ncontraposition : (A \u2192 B) \u2192 \u00ac B \u2192 \u00ac A\ncontraposition f \u00acb a = contradiction (f a) \u00acb\n\n-- Everything is stable in the double-negation monad.\nstable : \u00ac \u00ac Stable A\nstable \u00ac[\u00ac\u00aca\u2192a] = \u00ac[\u00ac\u00aca\u2192a] (contradiction (\u00ac[\u00ac\u00aca\u2192a] \u2218 const))\n\n-- Negated predicates are stable.\nnegated-stable : Stable (\u00ac A)\nnegated-stable \u00ac\u00ac\u00aca a = \u00ac\u00ac\u00aca (contradiction a)\n\n\u00ac\u00ac-map : (A \u2192 B) \u2192 \u00ac \u00ac A \u2192 \u00ac \u00ac B\n\u00ac\u00ac-map f = contraposition (contraposition f)\n\n-- Note also the following use of flip:\nprivate\n  note : (A \u2192 \u00ac B) \u2192 B \u2192 \u00ac A\n  note = flip\n\n</pre>"},{"location":"md/Relation/Nullary/Recomputable/","title":"Relation.Nullary.Recomputable","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Recomputable types and their algebra as Harrop formulas\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Nullary.Recomputable where\n\nopen import Agda.Builtin.Equality using (_\u2261_; refl)\nopen import Data.Empty using (\u22a5)\nopen import Data.Irrelevant\nopen import Data.Product.Base using (_\u00d7_; _,_; proj\u2081; proj\u2082)\nopen import Level using (Level)\nopen import Relation.Nullary.Negation.Core using (\u00ac_)\n\nprivate\n  variable\n    a b : Level\n    A : Set a\n    B : Set b\n\n------------------------------------------------------------------------\n-- Definition\n--\n-- The idea of being 'recomputable' is that, given an *irrelevant* proof\n-- of a proposition `A` (signalled by being a value of type `.A`, all of\n-- whose inhabitants are identified up to definitional equality, and hence\n-- do *not* admit pattern-matching), one may 'promote' such a value to a\n-- 'genuine' value of `A`, available for subsequent eg. pattern-matching.\n\nRecomputable : (A : Set a) \u2192 Set a\nRecomputable A = .A \u2192 A\n\n------------------------------------------------------------------------\n-- Fundamental property: 'promotion' is a constant function\n\nrecompute-constant : (r : Recomputable A) (p q : A) \u2192 r p \u2261 r q\nrecompute-constant r p q = refl\n\n------------------------------------------------------------------------\n-- Constructions\n\n-- Irrelevant types are Recomputable\n\nirrelevant-recompute : Recomputable (Irrelevant A)\nirrelevant (irrelevant-recompute [ a ]) = a\n\n-- Corollary: so too is \u22a5\n\n\u22a5-recompute : Recomputable \u22a5\n\u22a5-recompute = irrelevant-recompute\n\n_\u00d7-recompute_ : Recomputable A \u2192 Recomputable B \u2192 Recomputable (A \u00d7 B)\n(rA \u00d7-recompute rB) p = rA (p .proj\u2081) , rB (p .proj\u2082)\n\n_\u2192-recompute_ : (A : Set a) \u2192 Recomputable B \u2192 Recomputable (A \u2192 B)\n(A \u2192-recompute rB) f a = rB (f a)\n\n\u03a0-recompute : (B : A \u2192 Set b) \u2192 (\u2200 x \u2192 Recomputable (B x)) \u2192 Recomputable (\u2200 x \u2192 B x)\n\u03a0-recompute B rB f a = rB a (f a)\n\n\u2200-recompute : (B : A \u2192 Set b) \u2192 (\u2200 {x} \u2192 Recomputable (B x)) \u2192 Recomputable (\u2200 {x} \u2192 B x)\n\u2200-recompute B rB f = rB f\n\n-- Corollary: negations are Recomputable\n\n\u00ac-recompute : Recomputable (\u00ac A)\n\u00ac-recompute {A = A} = A \u2192-recompute \u22a5-recompute\n\n</pre>"},{"location":"md/Relation/Nullary/Reflects/","title":"Relation.Nullary.Reflects","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Properties of the `Reflects` construct\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Nullary.Reflects where\n\nopen import Agda.Builtin.Equality\n\nopen import Data.Bool.Base\nopen import Data.Sum.Base using (_\u228e_; inj\u2081; inj\u2082)\nopen import Data.Product.Base using (_\u00d7_; _,_; proj\u2081; proj\u2082)\nopen import Level using (Level)\nopen import Function.Base using (_$_; _\u2218_; const; id)\nopen import Relation.Nullary.Negation.Core\n  using (\u00ac_; contradiction-irr; contradiction; _\u00ac-\u228e_)\nopen import Relation.Nullary.Recomputable as Recomputable using (Recomputable)\n\nprivate\n  variable\n    a : Level\n    A B : Set a\n\n------------------------------------------------------------------------\n-- `Reflects` idiom.\n\n-- The truth value of A is reflected by a boolean value.\n-- `Reflects A b` is equivalent to `if b then A else \u00ac A`.\n\ndata Reflects (A : Set a) : Bool \u2192 Set a where\n  of\u02b8 : ( a :   A) \u2192 Reflects A true\n  of\u207f : (\u00aca : \u00ac A) \u2192 Reflects A false\n\n------------------------------------------------------------------------\n-- Constructors and destructors\n\n-- These lemmas are intended to be used mostly when `b` is a value, so\n-- that the `if` expressions have already been evaluated away.\n-- In this case, `of` works like the relevant constructor (`of\u207f` or\n-- `of\u02b8`), and `invert` strips off the constructor to just give either\n-- the proof of `A` or the proof of `\u00ac A`.\n\nof : \u2200 {b} \u2192 if b then A else \u00ac A \u2192 Reflects A b\nof {b = false} \u00aca = of\u207f \u00aca\nof {b = true }  a = of\u02b8 a\n\ninvert : \u2200 {b} \u2192 Reflects A b \u2192 if b then A else \u00ac A\ninvert (of\u02b8  a) = a\ninvert (of\u207f \u00aca) = \u00aca\n\n------------------------------------------------------------------------\n-- recompute\n\n-- Given an irrelevant proof of a reflected type, a proof can\n-- be recomputed and subsequently used in relevant contexts.\n\nrecompute : \u2200 {b} \u2192 Reflects A b \u2192 Recomputable A\nrecompute (of\u02b8  a) _ = a\nrecompute (of\u207f \u00aca) a = contradiction-irr a \u00aca\n\nrecompute-constant : \u2200 {b} (r : Reflects A b) (p q : A) \u2192\n                     recompute r p \u2261 recompute r q\nrecompute-constant = Recomputable.recompute-constant \u2218 recompute\n\n------------------------------------------------------------------------\n-- Interaction with negation, product, sums etc.\n\ninfixr 1 _\u228e-reflects_\ninfixr 2 _\u00d7-reflects_ _\u2192-reflects_\n\nT-reflects : \u2200 b \u2192 Reflects (T b) b\nT-reflects true  = of _\nT-reflects false = of id\n\n-- If we can decide A, then we can decide its negation.\n\u00ac-reflects : \u2200 {b} \u2192 Reflects A b \u2192 Reflects (\u00ac A) (not b)\n\u00ac-reflects (of\u02b8  a) = of (_$ a)\n\u00ac-reflects (of\u207f \u00aca) = of \u00aca\n\n-- If we can decide A and Q then we can decide their product\n_\u00d7-reflects_ : \u2200 {a b} \u2192 Reflects A a \u2192 Reflects B b \u2192\n               Reflects (A \u00d7 B) (a \u2227 b)\nof\u02b8  a \u00d7-reflects of\u02b8  b = of (a , b)\nof\u02b8  a \u00d7-reflects of\u207f \u00acb = of (\u00acb \u2218 proj\u2082)\nof\u207f \u00aca \u00d7-reflects _      = of (\u00aca \u2218 proj\u2081)\n\n_\u228e-reflects_ : \u2200 {a b} \u2192 Reflects A a \u2192 Reflects B b \u2192\n               Reflects (A \u228e B) (a \u2228 b)\nof\u02b8  a \u228e-reflects      _ = of (inj\u2081 a)\nof\u207f \u00aca \u228e-reflects of\u02b8  b = of (inj\u2082 b)\nof\u207f \u00aca \u228e-reflects of\u207f \u00acb = of (\u00aca \u00ac-\u228e \u00acb)\n\n_\u2192-reflects_ : \u2200 {a b} \u2192 Reflects A a \u2192 Reflects B b \u2192\n                Reflects (A \u2192 B) (not a \u2228 b)\nof\u02b8  a \u2192-reflects of\u02b8  b = of (const b)\nof\u02b8  a \u2192-reflects of\u207f \u00acb = of (\u00acb \u2218 (_$ a))\nof\u207f \u00aca \u2192-reflects _      = of (\u03bb a \u2192 contradiction a \u00aca)\n\n------------------------------------------------------------------------\n-- Other lemmas\n\nfromEquivalence : \u2200 {b} \u2192 (T b \u2192 A) \u2192 (A \u2192 T b) \u2192 Reflects A b\nfromEquivalence {b = true}  sound complete = of (sound _)\nfromEquivalence {b = false} sound complete = of complete\n\n-- `Reflects` is deterministic.\ndet : \u2200 {b b\u2032} \u2192 Reflects A b \u2192 Reflects A b\u2032 \u2192 b \u2261 b\u2032\ndet (of\u02b8  a) (of\u02b8  _) = refl\ndet (of\u02b8  a) (of\u207f \u00aca) = contradiction a \u00aca\ndet (of\u207f \u00aca) (of\u02b8  a) = contradiction a \u00aca\ndet (of\u207f \u00aca) (of\u207f  _) = refl\n\nT-reflects-elim : \u2200 {a b} \u2192 Reflects (T a) b \u2192 b \u2261 a\nT-reflects-elim {a} r = det r (T-reflects a)\n</pre>"},{"location":"md/Relation/Unary/","title":"Relation.Unary","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Unary relations\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Unary where\n\nopen import Data.Empty using (\u22a5)\nopen import Data.Unit.Base using (\u22a4)\nopen import Data.Product.Base using (_\u00d7_; _,_; \u03a3-syntax; \u2203; uncurry; swap)\nopen import Data.Sum.Base using (_\u228e_; [_,_])\nopen import Function.Base using (_\u2218_; _|&gt;_)\nopen import Level using (Level; _\u2294_; 0\u2113; suc; Lift)\nopen import Relation.Binary.PropositionalEquality.Core using (_\u2261_)\nopen import Relation.Nullary as Nullary using (\u00ac_; Dec; True)\n\nprivate\n  variable\n    a b c \u2113 \u2113\u2081 \u2113\u2082 : Level\n    A : Set a\n    B : Set b\n    C : Set c\n\n------------------------------------------------------------------------\n-- Definition\n\n-- Unary relations are known as predicates and `Pred A \u2113` can be viewed\n-- as some property that elements of type A might satisfy.\n\n-- Consequently `P : Pred A \u2113` can also be seen as a subset of A\n-- containing all the elements of A that satisfy property P. This view\n-- informs much of the notation used below.\n\nPred : \u2200 {a} \u2192 Set a \u2192 (\u2113 : Level) \u2192 Set (a \u2294 suc \u2113)\nPred A \u2113 = A \u2192 Set \u2113\n\n------------------------------------------------------------------------\n-- Special sets\n\n-- The empty set.\n-- Explicitly not level polymorphic as this often causes unsolved metas;\n-- see `Relation.Unary.Polymorphic` for a level-polymorphic version.\n\n\u2205 : Pred A 0\u2113\n\u2205 = \u03bb _ \u2192 \u22a5\n\n-- The singleton set.\n\n\uff5b_\uff5d : A \u2192 Pred A _\n\uff5b x \uff5d = x \u2261_\n\n-- The universal set.\n-- Explicitly not level polymorphic (see comments for `\u2205` for more details)\n\nU : Pred A 0\u2113\nU = \u03bb _ \u2192 \u22a4\n\n------------------------------------------------------------------------\n-- Membership\n\ninfix 4 _\u2208_ _\u2209_\n\n_\u2208_ : A \u2192 Pred A \u2113 \u2192 Set _\nx \u2208 P = P x\n\n_\u2209_ : A \u2192 Pred A \u2113 \u2192 Set _\nx \u2209 P = \u00ac x \u2208 P\n\n------------------------------------------------------------------------\n-- Subset relations\n\ninfix 4 _\u2286_ _\u2287_ _\u2288_ _\u2289_ _\u2282_ _\u2283_ _\u2284_ _\u2285_ _\u2250_ _\u2250\u2032_\n\n_\u2286_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2286 Q = \u2200 {x} \u2192 x \u2208 P \u2192 x \u2208 Q\n\n_\u2287_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2287 Q = Q \u2286 P\n\n_\u2288_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2288 Q = \u00ac (P \u2286 Q)\n\n_\u2289_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2289 Q = \u00ac (P \u2287 Q)\n\n_\u2282_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2282 Q = P \u2286 Q \u00d7 Q \u2288 P\n\n_\u2283_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2283 Q = Q \u2282 P\n\n_\u2284_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2284 Q = \u00ac (P \u2282 Q)\n\n_\u2285_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2285 Q = \u00ac (P \u2283 Q)\n\n_\u2250_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2250 Q = (P \u2286 Q) \u00d7 (Q \u2286 P)\n\n-- The following primed variants of _\u2286_ can be used when 'x' can't\n-- be inferred from 'x \u2208 P'.\n\ninfix 4 _\u2286\u2032_ _\u2287\u2032_ _\u2288\u2032_ _\u2289\u2032_ _\u2282\u2032_ _\u2283\u2032_ _\u2284\u2032_ _\u2285\u2032_\n\n_\u2286\u2032_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2286\u2032 Q = \u2200 x \u2192 x \u2208 P \u2192 x \u2208 Q\n\n_\u2287\u2032_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nQ \u2287\u2032 P = P \u2286\u2032 Q\n\n_\u2288\u2032_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2288\u2032 Q = \u00ac (P \u2286\u2032 Q)\n\n_\u2289\u2032_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2289\u2032 Q = \u00ac (P \u2287\u2032 Q)\n\n_\u2282\u2032_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2282\u2032 Q = P \u2286\u2032 Q \u00d7 Q \u2288\u2032 P\n\n_\u2283\u2032_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2283\u2032 Q = Q \u2282\u2032 P\n\n_\u2284\u2032_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2284\u2032 Q = \u00ac (P \u2282\u2032 Q)\n\n_\u2285\u2032_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2285\u2032 Q = \u00ac (P \u2283\u2032 Q)\n\n_\u2250\u2032_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u2250\u2032 Q = (P \u2286\u2032 Q) \u00d7 (Q \u2286\u2032 P)\n\n------------------------------------------------------------------------\n-- Properties of sets\n\ninfix 10 Satisfiable Universal IUniversal\n\n-- Emptiness - no element satisfies P.\n\nEmpty : Pred A \u2113 \u2192 Set _\nEmpty P = \u2200 x \u2192 x \u2209 P\n\n-- Satisfiable - at least one element satisfies P.\n\nSatisfiable : Pred A \u2113 \u2192 Set _\nSatisfiable P = \u2203 \u03bb x \u2192 x \u2208 P\n\nsyntax Satisfiable P = \u2203\u27e8 P \u27e9\n\n-- Universality - all elements satisfy P.\n\nUniversal : Pred A \u2113 \u2192 Set _\nUniversal P = \u2200 x \u2192 x \u2208 P\n\nsyntax Universal  P = \u03a0[ P ]\n\n-- Implicit universality - all elements satisfy P.\n\nIUniversal : Pred A \u2113 \u2192 Set _\nIUniversal P = \u2200 {x} \u2192 x \u2208 P\n\nsyntax IUniversal P = \u2200[ P ]\n\n-- Irrelevance - any two proofs that an element satifies P are\n-- indistinguishable.\n\nIrrelevant : Pred A \u2113 \u2192 Set _\nIrrelevant P = \u2200 {x} \u2192 Nullary.Irrelevant (P x)\n\n-- Recomputability - we can rebuild a relevant proof given an\n-- irrelevant one.\n\nRecomputable : Pred A \u2113 \u2192 Set _\nRecomputable P = \u2200 {x} \u2192 Nullary.Recomputable (P x)\n\n-- Stability - instances of P are stable wrt double negation\n\nStable : Pred A \u2113 \u2192 Set _\nStable P = \u2200 x \u2192 Nullary.Stable (P x)\n\n-- Weak Decidability\n\nWeaklyDecidable : Pred A \u2113 \u2192 Set _\nWeaklyDecidable P = \u2200 x \u2192 Nullary.WeaklyDecidable (P x)\n\n-- Decidability - it is possible to determine if an arbitrary element\n-- satisfies P.\n\nDecidable : Pred A \u2113 \u2192 Set _\nDecidable P = \u2200 x \u2192 Dec (P x)\n\n-- Erasure: A decidable predicate gives rise to another one, more\n-- amenable to \u03b7-expansion\n\n\u230a_\u230b : {P : Pred A \u2113} \u2192 Decidable P \u2192 Pred A \u2113\n\u230a P? \u230b a = Lift _ (True (P? a))\n\n------------------------------------------------------------------------\n-- Operations on sets\n\ninfix 10 \u22c3 \u22c2\ninfixr 9 _\u22a2_\ninfixr 8 _\u21d2_\ninfixr 7 _\u2229_\ninfixr 6 _\u222a_\ninfixr 6 _\u2216_\ninfix 4 _\u226c_\n\n-- Complement.\n\n\u2201 : Pred A \u2113 \u2192 Pred A \u2113\n\u2201 P = \u03bb x \u2192 x \u2209 P\n\n-- Implication.\n\n_\u21d2_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Pred A _\nP \u21d2 Q = \u03bb x \u2192 x \u2208 P \u2192 x \u2208 Q\n\n-- Union.\n\n_\u222a_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Pred A _\nP \u222a Q = \u03bb x \u2192 x \u2208 P \u228e x \u2208 Q\n\n-- Intersection.\n\n_\u2229_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Pred A _\nP \u2229 Q = \u03bb x \u2192 x \u2208 P \u00d7 x \u2208 Q\n\n-- Difference.\n\n_\u2216_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Pred A _\nP \u2216 Q = \u03bb x \u2192 x \u2208 P \u00d7 x \u2209 Q\n\n-- Infinitary union.\n\n\u22c3 : \u2200 {i} (I : Set i) \u2192 (I \u2192 Pred A \u2113) \u2192 Pred A _\n\u22c3 I P = \u03bb x \u2192 \u03a3[ i \u2208 I ] P i x\n\nsyntax \u22c3 I (\u03bb i \u2192 P) = \u22c3[ i \u2236 I ] P\n\n-- Infinitary intersection.\n\n\u22c2 : \u2200 {i} (I : Set i) \u2192 (I \u2192 Pred A \u2113) \u2192 Pred A _\n\u22c2 I P = \u03bb x \u2192 (i : I) \u2192 P i x\n\nsyntax \u22c2 I (\u03bb i \u2192 P) = \u22c2[ i \u2236 I ] P\n\n-- Positive version of non-disjointness, dual to inclusion.\n\n_\u226c_ : Pred A \u2113\u2081 \u2192 Pred A \u2113\u2082 \u2192 Set _\nP \u226c Q = \u2203 \u03bb x \u2192 x \u2208 P \u00d7 x \u2208 Q\n\n-- Update.\n\n_\u22a2_ : (A \u2192 B) \u2192 Pred B \u2113 \u2192 Pred A \u2113\nf \u22a2 P = \u03bb x \u2192 P (f x)\n\n------------------------------------------------------------------------\n-- Predicate combinators\n\n-- These differ from the set operations above, as the carrier set of the\n-- resulting predicates are not the same as the carrier set of the\n-- component predicates.\n\ninfixr  2 _\u27e8\u00d7\u27e9_\ninfixr  2 _\u27e8\u2299\u27e9_\ninfixr  1 _\u27e8\u228e\u27e9_\ninfixr  0 _\u27e8\u2192\u27e9_\ninfixl  9 _\u27e8\u00b7\u27e9_\ninfix  10 _~\ninfixr  9 _\u27e8\u2218\u27e9_\ninfixr  2 _//_ _\\\\_\n\n-- Product.\n\n_\u27e8\u00d7\u27e9_ : Pred A \u2113\u2081 \u2192 Pred B \u2113\u2082 \u2192 Pred (A \u00d7 B) _\n(P \u27e8\u00d7\u27e9 Q) (x , y) = x \u2208 P \u00d7 y \u2208 Q\n\n-- Sum over one element.\n\n_\u27e8\u228e\u27e9_ : Pred A \u2113 \u2192 Pred B \u2113 \u2192 Pred (A \u228e B) _\nP \u27e8\u228e\u27e9 Q = [ P , Q ]\n\n-- Sum over two elements.\n\n_\u27e8\u2299\u27e9_ : Pred A \u2113\u2081 \u2192 Pred B \u2113\u2082 \u2192 Pred (A \u00d7 B) _\n(P \u27e8\u2299\u27e9 Q) (x , y) = x \u2208 P \u228e y \u2208 Q\n\n-- Implication.\n\n_\u27e8\u2192\u27e9_ : Pred A \u2113\u2081 \u2192 Pred B \u2113\u2082 \u2192 Pred (A \u2192 B) _\n(P \u27e8\u2192\u27e9 Q) f = P \u2286 Q \u2218 f\n\n-- Product.\n\n_\u27e8\u00b7\u27e9_ : (P : Pred A \u2113\u2081) (Q : Pred B \u2113\u2082) \u2192\n        (P \u27e8\u00d7\u27e9 (P \u27e8\u2192\u27e9 Q)) \u2286 Q \u2218 uncurry _|&gt;_\n(P \u27e8\u00b7\u27e9 Q) (p , f) = f p\n\n-- Converse.\n\n_~ : Pred (A \u00d7 B) \u2113 \u2192 Pred (B \u00d7 A) \u2113\nP ~ = P \u2218 swap\n\n-- Composition.\n\n_\u27e8\u2218\u27e9_ : Pred (A \u00d7 B) \u2113\u2081 \u2192 Pred (B \u00d7 C) \u2113\u2082 \u2192 Pred (A \u00d7 C) _\n(P \u27e8\u2218\u27e9 Q) (x , z) = \u2203 \u03bb y \u2192 (x , y) \u2208 P \u00d7 (y , z) \u2208 Q\n\n-- Post-division.\n\n_//_ : Pred (A \u00d7 C) \u2113\u2081 \u2192 Pred (B \u00d7 C) \u2113\u2082 \u2192 Pred (A \u00d7 B) _\n(P // Q) (x , y) = Q \u2218 (y ,_) \u2286 P \u2218 (x ,_)\n\n-- Pre-division.\n\n_\\\\_ : Pred (A \u00d7 C) \u2113\u2081 \u2192 Pred (A \u00d7 B) \u2113\u2082 \u2192 Pred (B \u00d7 C) _\nP \\\\ Q = (P ~ // Q ~) ~\n</pre>"},{"location":"md/Relation/Unary/Properties/","title":"Relation.Unary.Properties","text":"<pre>------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Properties of constructions over unary relations\n------------------------------------------------------------------------\n\n{-# OPTIONS --cubical-compatible --safe #-}\n\nmodule Relation.Unary.Properties where\n\nopen import Data.Product.Base as Product using (_\u00d7_; _,_; swap; proj\u2081; zip\u2032)\nopen import Data.Sum.Base using (inj\u2081; inj\u2082)\nopen import Data.Unit.Base using (tt)\nopen import Level using (Level)\nopen import Relation.Binary.Core as Binary\nopen import Relation.Binary.Definitions\n  hiding (Decidable; Universal; Irrelevant; Empty)\nopen import Relation.Binary.PropositionalEquality.Core using (refl; _\u2257_)\nopen import Relation.Unary\nopen import Relation.Nullary.Decidable as Dec using (yes; no; _\u228e-dec_; _\u00d7-dec_; \u00ac?; map\u2032; does)\nopen import Function.Base using (id; _$_; _\u2218_)\n\nprivate\n  variable\n    a b \u2113 \u2113\u2081 \u2113\u2082 \u2113\u2083 : Level\n    A : Set a\n    B : Set b\n\n------------------------------------------------------------------------\n-- The empty set\n\n\u2205? : Decidable {A = A} \u2205\n\u2205? _ = no \u03bb()\n\n\u2205-Empty : Empty {A = A} \u2205\n\u2205-Empty x ()\n\n\u2201\u2205-Universal : Universal {A = A} (\u2201 \u2205)\n\u2201\u2205-Universal = \u03bb x x\u2208\u2205 \u2192 x\u2208\u2205\n\n------------------------------------------------------------------------\n-- The universe\n\nU? : Decidable {A = A} U\nU? _ = yes tt\n\nU-Universal : Universal {A = A} U\nU-Universal = \u03bb _ \u2192 _\n\n\u2201U-Empty : Empty {A = A} (\u2201 U)\n\u2201U-Empty = \u03bb x x\u2208\u2201U \u2192 x\u2208\u2201U _\n\n------------------------------------------------------------------------\n-- Subset properties\n\n\u2205-\u2286 : (P : Pred A \u2113) \u2192 \u2205 \u2286 P\n\u2205-\u2286 P ()\n\n\u2286-U : (P : Pred A \u2113) \u2192 P \u2286 U\n\u2286-U P _ = _\n\n\u2286-refl : Reflexive {A = Pred A \u2113} _\u2286_\n\u2286-refl x\u2208P = x\u2208P\n\n\u2286-reflexive : Binary._\u21d2_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2250_ _\u2286_\n\u2286-reflexive (P\u2286Q , Q\u2286P) = P\u2286Q\n\n\u2286-trans : Trans {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} {C = Pred A \u2113\u2083} _\u2286_ _\u2286_ _\u2286_\n\u2286-trans P\u2286Q Q\u2286R x\u2208P = Q\u2286R (P\u2286Q x\u2208P)\n\n\u2286-antisym : Antisymmetric {A = Pred A \u2113} _\u2250_ _\u2286_\n\u2286-antisym = _,_\n\n\u2286-min : Min {B = Pred A \u2113} _\u2286_ \u2205\n\u2286-min = \u2205-\u2286\n\n\u2286-max : Max {A = Pred A \u2113} _\u2286_ U\n\u2286-max = \u2286-U\n\n\u2282\u21d2\u2286 : Binary._\u21d2_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2282_ _\u2286_\n\u2282\u21d2\u2286 = proj\u2081\n\n\u2282-trans : Trans {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} {C = Pred A \u2113\u2083} _\u2282_ _\u2282_ _\u2282_\n\u2282-trans (P\u2286Q , Q\u2288P) (Q\u2286R , R\u2288Q) = (\u03bb x\u2208P \u2192 Q\u2286R (P\u2286Q x\u2208P)) , (\u03bb R\u2286P \u2192 R\u2288Q (\u03bb x\u2208R \u2192 P\u2286Q (R\u2286P x\u2208R)))\n\n\u2282-\u2286-trans : Trans {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} {C = Pred A \u2113\u2083} _\u2282_ _\u2286_ _\u2282_\n\u2282-\u2286-trans (P\u2286Q , Q\u2288P) Q\u2286R = (\u03bb x\u2208P \u2192 Q\u2286R (P\u2286Q x\u2208P)) , (\u03bb R\u2286P \u2192 Q\u2288P (\u03bb x\u2208Q \u2192 R\u2286P (Q\u2286R x\u2208Q)))\n\n\u2286-\u2282-trans : Trans {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} {C = Pred A \u2113\u2083} _\u2286_ _\u2282_ _\u2282_\n\u2286-\u2282-trans P\u2286Q (Q\u2286R , R\u2288Q) = (\u03bb x\u2208P \u2192 Q\u2286R (P\u2286Q x\u2208P)) , (\u03bb R\u2286P \u2192 R\u2288Q (\u03bb R\u2286Q \u2192 P\u2286Q (R\u2286P R\u2286Q)))\n\n\u2282-resp\u02b3-\u2250 : _Respects\u02b3_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2282_ _\u2250_\n\u2282-resp\u02b3-\u2250 (Q\u2286R , _) P\u2282Q = \u2282-\u2286-trans P\u2282Q Q\u2286R\n\n\u2282-resp\u02e1-\u2250 : _Respects\u02e1_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2282_ _\u2250_\n\u2282-resp\u02e1-\u2250 (_ , R\u2286Q) P\u2282Q = \u2286-\u2282-trans R\u2286Q P\u2282Q\n\n\u2282-resp-\u2250 : _Respects\u2082_ {A = Pred A \u2113} _\u2282_ _\u2250_\n\u2282-resp-\u2250 = \u2282-resp\u02b3-\u2250 , \u2282-resp\u02e1-\u2250\n\n\u2282-irrefl : Irreflexive {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2250_ _\u2282_\n\u2282-irrefl (_ , Q\u2286P) (_ , Q\u2288P) = Q\u2288P Q\u2286P\n\n\u2282-antisym : Antisymmetric {A = Pred A \u2113} _\u2250_ _\u2282_\n\u2282-antisym (P\u2286Q , _) (Q\u2286P , _) = \u2286-antisym P\u2286Q Q\u2286P\n\n\u2282-asym : Asymmetric {A = Pred A \u2113} _\u2282_\n\u2282-asym (_ , Q\u2288P) = Q\u2288P \u2218 proj\u2081\n\n\u2205-\u2286\u2032 : (P : Pred A \u2113) \u2192 \u2205 \u2286\u2032 P\n\u2205-\u2286\u2032 _ _ = \u03bb ()\n\n\u2286\u2032-U : (P : Pred A \u2113) \u2192 P \u2286\u2032 U\n\u2286\u2032-U _ _ _ = _\n\n\u2286\u2032-refl : Reflexive {A = Pred A \u2113} _\u2286\u2032_\n\u2286\u2032-refl x x\u2208P = x\u2208P\n\n\u2286\u2032-reflexive : Binary._\u21d2_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2250\u2032_ _\u2286\u2032_\n\u2286\u2032-reflexive (P\u2286Q , Q\u2286P) = P\u2286Q\n\n\u2286\u2032-trans : Trans {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} {C = Pred A \u2113\u2083} _\u2286\u2032_ _\u2286\u2032_ _\u2286\u2032_\n\u2286\u2032-trans P\u2286Q Q\u2286R x x\u2208P = Q\u2286R x (P\u2286Q x x\u2208P)\n\n\u2286\u2032-antisym : Antisymmetric {A = Pred A \u2113} _\u2250\u2032_ _\u2286\u2032_\n\u2286\u2032-antisym = _,_\n\n\u2286\u2032-min : Min {B = Pred A \u2113} _\u2286\u2032_ \u2205\n\u2286\u2032-min = \u2205-\u2286\u2032\n\n\u2286\u2032-max : Max {A = Pred A \u2113} _\u2286\u2032_ U\n\u2286\u2032-max = \u2286\u2032-U\n\n\u2282\u2032\u21d2\u2286\u2032 : Binary._\u21d2_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2282\u2032_ _\u2286\u2032_\n\u2282\u2032\u21d2\u2286\u2032 = proj\u2081\n\n\u2282\u2032-trans : Trans {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} {C = Pred A \u2113\u2083} _\u2282\u2032_ _\u2282\u2032_ _\u2282\u2032_\n\u2282\u2032-trans (P\u2286Q , Q\u2288P) (Q\u2286R , R\u2288Q) = \u2286\u2032-trans P\u2286Q Q\u2286R , \u03bb R\u2286P \u2192 R\u2288Q (\u2286\u2032-trans R\u2286P P\u2286Q)\n\n\u2282\u2032-\u2286\u2032-trans : Trans {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} {C = Pred A \u2113\u2083} _\u2282\u2032_ _\u2286\u2032_ _\u2282\u2032_\n\u2282\u2032-\u2286\u2032-trans (P\u2286Q , Q\u2288P) Q\u2286R = \u2286\u2032-trans P\u2286Q Q\u2286R , \u03bb R\u2286P \u2192 Q\u2288P (\u2286\u2032-trans Q\u2286R R\u2286P)\n\n\u2286\u2032-\u2282\u2032-trans : Trans {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} {C = Pred A \u2113\u2083} _\u2286\u2032_ _\u2282\u2032_ _\u2282\u2032_\n\u2286\u2032-\u2282\u2032-trans P\u2286Q (Q\u2286R , R\u2288Q) = \u2286\u2032-trans P\u2286Q Q\u2286R , \u03bb R\u2286P \u2192 R\u2288Q (\u2286\u2032-trans R\u2286P P\u2286Q)\n\n\u2282\u2032-resp\u02b3-\u2250\u2032 : _Respects\u02b3_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2282\u2032_ _\u2250\u2032_\n\u2282\u2032-resp\u02b3-\u2250\u2032 (Q\u2286R , _) P\u2282Q = \u2282\u2032-\u2286\u2032-trans P\u2282Q Q\u2286R\n\n\u2282\u2032-resp\u02e1-\u2250\u2032 : _Respects\u02e1_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2282\u2032_ _\u2250\u2032_\n\u2282\u2032-resp\u02e1-\u2250\u2032 (_ , R\u2286Q) P\u2282Q = \u2286\u2032-\u2282\u2032-trans R\u2286Q P\u2282Q\n\n\u2282\u2032-resp-\u2250\u2032 : _Respects\u2082_ {A = Pred A \u2113\u2081} _\u2282\u2032_ _\u2250\u2032_\n\u2282\u2032-resp-\u2250\u2032 = \u2282\u2032-resp\u02b3-\u2250\u2032 , \u2282\u2032-resp\u02e1-\u2250\u2032\n\n\u2282\u2032-irrefl : Irreflexive {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2250\u2032_ _\u2282\u2032_\n\u2282\u2032-irrefl (_ , Q\u2286P) (_ , Q\u2288P) = Q\u2288P Q\u2286P\n\n\u2282\u2032-antisym : Antisymmetric {A = Pred A \u2113} _\u2250\u2032_ _\u2282\u2032_\n\u2282\u2032-antisym (P\u2286Q , _) (Q\u2286P , _) = \u2286\u2032-antisym P\u2286Q Q\u2286P\n\n\u2286\u21d2\u2286\u2032 : Binary._\u21d2_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2286_ _\u2286\u2032_\n\u2286\u21d2\u2286\u2032 P\u2286Q _ x\u2208P = P\u2286Q x\u2208P\n\n\u2286\u2032\u21d2\u2286 : Binary._\u21d2_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2286\u2032_ _\u2286_\n\u2286\u2032\u21d2\u2286 P\u2286Q x\u2208P = P\u2286Q _ x\u2208P\n\n\u2282\u21d2\u2282\u2032 : Binary._\u21d2_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2282_ _\u2282\u2032_\n\u2282\u21d2\u2282\u2032 = Product.map \u2286\u21d2\u2286\u2032 (_\u2218 \u2286\u2032\u21d2\u2286)\n\n\u2282\u2032\u21d2\u2282 : Binary._\u21d2_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2282\u2032_ _\u2282_\n\u2282\u2032\u21d2\u2282 = Product.map \u2286\u2032\u21d2\u2286 (_\u2218 \u2286\u21d2\u2286\u2032)\n\n------------------------------------------------------------------------\n-- Equality properties\n\n\u2250-refl : Reflexive {A = Pred A \u2113} _\u2250_\n\u2250-refl = id , id\n\n\u2250-sym : Sym {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2250_ _\u2250_\n\u2250-sym = swap\n\n\u2250-trans : Trans {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} {C = Pred A \u2113\u2083} _\u2250_ _\u2250_ _\u2250_\n\u2250-trans = zip\u2032 (\u03bb P\u2286Q Q\u2286R x\u2208P \u2192 Q\u2286R (P\u2286Q x\u2208P)) (\u03bb Q\u2286P R\u2286Q x\u2208R \u2192 Q\u2286P (R\u2286Q x\u2208R))\n\n\u2250\u2032-refl : Reflexive {A = Pred A \u2113} _\u2250\u2032_\n\u2250\u2032-refl = (\u03bb _ \u2192 id) , (\u03bb _ \u2192 id)\n\n\u2250\u2032-sym : Sym {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2250\u2032_ _\u2250\u2032_\n\u2250\u2032-sym = swap\n\n\u2250\u2032-trans : Trans {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} {C = Pred A \u2113\u2083} _\u2250\u2032_ _\u2250\u2032_ _\u2250\u2032_\n\u2250\u2032-trans = zip\u2032 (\u03bb P\u2286Q Q\u2286R x x\u2208P \u2192 Q\u2286R x (P\u2286Q x x\u2208P)) \u03bb Q\u2286P R\u2286Q x x\u2208R \u2192 Q\u2286P x (R\u2286Q x x\u2208R)\n\n\u2250\u21d2\u2250\u2032 : Binary._\u21d2_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2250_ _\u2250\u2032_\n\u2250\u21d2\u2250\u2032 = Product.map \u2286\u21d2\u2286\u2032 \u2286\u21d2\u2286\u2032\n\n\u2250\u2032\u21d2\u2250 : Binary._\u21d2_ {A = Pred A \u2113\u2081} {B = Pred A \u2113\u2082} _\u2250\u2032_ _\u2250_\n\u2250\u2032\u21d2\u2250 = Product.map \u2286\u2032\u21d2\u2286 \u2286\u2032\u21d2\u2286\n\n------------------------------------------------------------------------\n-- Decidability properties\n\nmap : {P : Pred A \u2113\u2081} {Q : Pred A \u2113\u2082} \u2192\n      P \u2250 Q \u2192 Decidable P \u2192 Decidable Q\nmap (P\u2286Q , Q\u2286P) P? x = map\u2032 P\u2286Q Q\u2286P (P? x)\n\n\u2201? : {P : Pred A \u2113} \u2192 Decidable P \u2192 Decidable (\u2201 P)\n\u2201? P? x = \u00ac? (P? x)\n\ninfix 2 _\u00d7?_ _\u2299?_\ninfix 10 _~?\ninfixr 1 _\u228e?_\ninfixr 7 _\u2229?_\ninfixr 6 _\u222a?_\n\n_\u222a?_ : {P : Pred A \u2113\u2081} {Q : Pred A \u2113\u2082} \u2192\n       Decidable P \u2192 Decidable Q \u2192 Decidable (P \u222a Q)\n_\u222a?_ P? Q? x = (P? x) \u228e-dec (Q? x)\n\n_\u2229?_ : {P : Pred A \u2113\u2081} {Q : Pred A \u2113\u2082} \u2192\n       Decidable P \u2192 Decidable Q \u2192 Decidable (P \u2229 Q)\n_\u2229?_ P? Q? x = (P? x) \u00d7-dec (Q? x)\n\n_\u00d7?_ : {P : Pred A \u2113\u2081} {Q : Pred B \u2113\u2082} \u2192\n       Decidable P \u2192 Decidable Q \u2192 Decidable (P \u27e8\u00d7\u27e9 Q)\n_\u00d7?_ P? Q? (a , b) = (P? a) \u00d7-dec (Q? b)\n\n_\u2299?_ : {P : Pred A \u2113\u2081} {Q : Pred B \u2113\u2082} \u2192\n       Decidable P \u2192 Decidable Q \u2192 Decidable (P \u27e8\u2299\u27e9 Q)\n_\u2299?_ P? Q? (a , b) = (P? a) \u228e-dec (Q? b)\n\n_\u228e?_ : {P : Pred A \u2113} {Q : Pred B \u2113} \u2192\n       Decidable P \u2192 Decidable Q \u2192 Decidable (P \u27e8\u228e\u27e9 Q)\n_\u228e?_ P? Q? (inj\u2081 a) = P? a\n_\u228e?_ P? Q? (inj\u2082 b) = Q? b\n\n_~? : {P : Pred (A \u00d7 B) \u2113} \u2192 Decidable P \u2192 Decidable (P ~)\n_~? P? = P? \u2218 swap\n\ndoes-\u2261 : {P : Pred A \u2113} \u2192 (P? P?\u2032 : Decidable P) \u2192\n         does \u2218 P? \u2257 does \u2218 P?\u2032\ndoes-\u2261 P? P?\u2032 x = Dec.does-\u2261 (P? x) (P?\u2032 x)\n\ndoes-\u2250 : {P : Pred A \u2113\u2081} {Q : Pred A \u2113\u2082} \u2192 P \u2250 Q \u2192\n         (P? : Decidable P) \u2192 (Q? : Decidable Q) \u2192\n         does \u2218 P? \u2257 does \u2218 Q?\ndoes-\u2250 P\u2250Q P? = does-\u2261 (map P\u2250Q P?)\n\n------------------------------------------------------------------------\n-- Irrelevant properties\n\nU-irrelevant : Irrelevant {A = A} U\nU-irrelevant a b = refl\n\n\u2201-irrelevant : (P : Pred A \u2113) \u2192 Irrelevant (\u2201 P)\n\u2201-irrelevant P a b = refl\n</pre>"},{"location":"md/ScmQE/Abstract-Syntax/","title":"ScmQE.Abstract-Syntax","text":"<pre>\nmodule ScmQE.Abstract-Syntax where\n\nopen import Data.Integer.Base  renaming (\u2124 to Int) public\nopen import Data.String.Base   using (String) public\n\ndata       Con    : Set     -- constants, *excluding* quotations\nvariable   K      : Con\n\ndata       Key    : Set     -- keywords\nvariable   X      : Key\ndata       Dat    : Set     -- datum\nvariable   \u0394      : Dat\ndata       Dat\u22c6   : Set     -- datum sequences\nvariable   \u0394\u22c6     : Dat\u22c6\ndata       Dat\u207a   : Set     -- non-empty datum sequences\nvariable   \u0394\u207a     : Dat\u207a\n\nIde               = String  -- identifiers (variables)\nvariable   I      : Ide\ndata       Exp    : Set     -- expressions\nvariable   E      : Exp\ndata       Exp\u22c6   : Set     -- expression sequences\nvariable   E\u22c6     : Exp\u22c6\n\ndata       Body   : Set     -- body expression or definition\nvariable   B      : Body\ndata       Body\u207a  : Set     -- body sequences\nvariable   B\u207a     : Body\u207a\n\ndata       Prog   : Set     -- programs\nvariable   \u03a0      : Prog\n\n\n------------------------------------------------------------------------\n-- Literal constants\n\ndata Con where                -- basic constants\n  int  : Int \u2192 Con            -- integer numerals\n  #t   : Con                  -- true\n  #f   : Con                  -- false\n\n------------------------------------------------------------------------\n-- Quotations\n\ndata Key where                -- keyword symbols\n  begin define eval if lambda quote\u2032 set! : Key\n\ndata Dat where                -- datum syntax\n  con    : Con \u2192 Dat          -- constants\n  ide    : Ide \u2192 Dat          -- symbols\n  key    : Key \u2192 Dat          -- keywords\n  \u2032      : Dat \u2192 Dat          -- quotation '\u0394\n  \u2985_\u2986    : Dat\u22c6 \u2192 Dat         -- datum lists (\u0394\u22c6)\n  \u2985_\u00b7_\u2986  : Dat\u207a \u2192 Dat \u2192 Dat   -- datum pairs (\u0394\u207a.\u0394)\n  #proc  : Dat                -- procedures\n</pre> <p>\\clearpage</p> <pre>\ndata Dat\u22c6 where               -- datum sequences\n  \u2423\u2423\u2423    : Dat\u22c6               -- empty sequence\n  _\u2423\u2423_   : Dat \u2192 Dat\u22c6 \u2192 Dat\u22c6  -- prefix sequence \u0394 \u0394\u22c6\n\ndata Dat\u207a where               -- non-empty datum sequences\n  \u2423\u2423_    : Dat \u2192 Dat\u207a         -- single datum sequence \u0394\n  _\u2423\u2423_   : Dat\u207a \u2192 Dat \u2192 Dat\u207a  -- suffix sequence \u0394\u207a \u0394\n\n------------------------------------------------------------------------\n-- Expressions\n\ndata Exp where                          -- expressions\n  con          : Con \u2192 Exp              -- K\n  ide          : Ide \u2192 Exp              -- I\n  \u2985_\u2423_\u2986        : Exp \u2192 Exp\u22c6 \u2192 Exp       -- (E E\u22c6)\n  \u2985lambda_\u2423_\u2986  : Ide \u2192 Exp \u2192 Exp        -- (lambda I E)\n  \u2985if_\u2423_\u2423_\u2986    : Exp \u2192 Exp \u2192 Exp \u2192 Exp  -- (if E E\u2081 E\u2082)\n  \u2985set!_\u2423_\u2986    : Ide \u2192 Exp \u2192 Exp        -- (set! I E)\n  \u2985quote_\u2986     : Dat \u2192 Exp              -- (quote \u0394)\n  \u2985eval_\u2986      : Exp \u2192 Exp              -- (eval E)\n  \u2985\u2423\u2986          : Exp                    -- illegal\n\ndata Exp\u22c6 where                         -- expression sequences\n  \u2423\u2423\u2423          : Exp\u22c6                   -- empty sequence\n  _\u2423\u2423_         : Exp \u2192 Exp\u22c6 \u2192 Exp\u22c6      -- prefix sequence E E\u22c6\n\n------------------------------------------------------------------------\n-- Definitions and Programs\n\ndata Body where\n  \u2423\u2423_          : Exp \u2192 Body             -- side-effect expression E\n  \u2985define_\u2423_\u2986  : Ide \u2192 Exp \u2192 Body       -- definition (define I E)\n  \u2985begin_\u2986     : Body\u207a \u2192 Body           -- block (begin B\u207a)\n\ndata Body\u207a where                        -- body sequence\n  \u2423\u2423_          : Body \u2192 Body\u207a           -- single body sequence B\n  _\u2423\u2423_         : Body \u2192 Body\u207a \u2192 Body\u207a   -- prefix body sequence B B\u207a\n\ndata Prog where                         -- programs\n  \u2423\u2423\u2423          : Prog                   -- empty program\n  \u2423\u2423_          : Body\u207a \u2192 Prog           -- non-empty program B\u207a\n\ninfix 30 \u2423\u2423_\ninfixr 20 _\u2423\u2423_\n</pre>"},{"location":"md/ScmQE/All/","title":"ScmQE.All","text":"<pre>\nmodule ScmQE.All where\n\nimport Notation\nimport ScmQE.Abstract-Syntax\nimport ScmQE.Domain-Equations\nimport ScmQE.Semantic-Functions\nimport ScmQE.Auxiliary-Functions\n</pre>"},{"location":"md/ScmQE/Auxiliary-Functions/","title":"ScmQE.Auxiliary-Functions","text":"<pre>\nmodule ScmQE.Auxiliary-Functions where\n\nopen import Notation\nopen import ScmQE.Abstract-Syntax\nopen import ScmQE.Domain-Equations\n\n-- Environments \u03c1 : \ud835\udc14 = Ide \u2192 \ud835\udc0b\n\npostulate _==_ : Ide \u2192 Ide \u2192 Bool\n\n_[_/_] : \ud835\udc14 \u2192 \ud835\udc0b \u2192 Ide \u2192 \ud835\udc14\n\u03c1 [ \u03b1 / I ] = \u03bb I\u2032 \u2192 \u03b7 (I == I\u2032) \u27f6 \u03b1 , \u03c1 I\u2032\n\npostulate unknown : \ud835\udc0b\n-- \u03c1 I = unknown represents the lack of a binding for I in \u03c1\n\npostulate nullenv : \ud835\udc14\n-- nullenv shoud include various procedures and values\n\n-- Stores \u03c3 : \ud835\udc12 = \ud835\udc0b \u2192 \ud835\udc04\n\n_[_/_]\u2032 : \ud835\udc12 \u2192 \ud835\udc04 \u2192 \ud835\udc0b \u2192 \ud835\udc12\n\u03c3 [ \u03f5 / \u03b1 ]\u2032 = \u03bb \u03b1\u2032 \u2192 (\u03b1 ==\u1d38 \u03b1\u2032) \u27f6 \u03f5 , \u03c3 \u03b1\u2032\n\nassign : \ud835\udc0b \u2192 \ud835\udc04 \u2192 \ud835\udc02 \u2192 \ud835\udc02\nassign = \u03bb \u03b1 \u03f5 \u03b8 \u03c3 \u2192 \u03b8 (\u03c3 [ \u03f5 / \u03b1 ]\u2032)\n\nhold : \ud835\udc0b \u2192 (\ud835\udc04 \u2192 \ud835\udc02) \u2192 \ud835\udc02\nhold = \u03bb \u03b1 \u03ba \u03c3 \u2192 \u03ba (\u03c3 \u03b1) \u03c3\n\npostulate new : (\ud835\udc0b \u2192 \ud835\udc02) \u2192 \ud835\udc02\n-- new \u03ba \u03c3 = \u03ba \u03b1 \u03c3\u2032 where \u03c3 \u03b1 = unallocated, \u03c3\u2032 \u03b1 \u2260 unallocated\n\nalloc : \ud835\udc04 \u2192 (\ud835\udc0b \u2192 \ud835\udc02) \u2192 \ud835\udc02\nalloc = \u03bb \u03f5 \u03ba \u2192 new (\u03bb \u03b1 \u2192 assign \u03b1 \u03f5 (\u03ba \u03b1))\n-- should be \u22a5 when \u03f5 |-\ud835\udc0c == unallocated\n\ninitial-store : \ud835\udc12\ninitial-store = \u03bb \u03b1 \u2192 \u03b7 unallocated \ud835\udc0c-in-\ud835\udc04\n\npostulate finished : \ud835\udc02\n-- normal termination with answer depending on final store\n\ntruish : \ud835\udc04 \u2192 \ud835\udc13\ntruish =\n  \u03bb \u03f5 \u2192 (\u03f5 \u2208-\ud835\udc13) \u27f6\n      (((\u03f5 |-\ud835\udc13) ==\u1d40 \u03b7 false) \u27f6 \u03b7 false , \u03b7 true) ,\n    \u03b7 true\n</pre> <p>\\clearpage</p> <pre>\n-- Lists\n\ncons : \ud835\udc05\ncons =\n  \u03bb \u03f5\u22c6 \u03ba \u2192\n      (# \u03f5\u22c6 ==\u22a5 2) \u27f6 alloc (\u03f5\u22c6 \u2193 1) (\u03bb \u03b1\u2081 \u2192\n                        alloc (\u03f5\u22c6 \u2193 2) (\u03bb \u03b1\u2082 \u2192\n                          \u03ba ((\u03b1\u2081 , \u03b1\u2082) \ud835\udc0f-in-\ud835\udc04))) , \n    \u22a5\n\nlist : \ud835\udc05\nlist = fix \u03bb list\u2032 \u2192\n  \u03bb \u03f5\u22c6 \u03ba \u2192\n    (# \u03f5\u22c6 ==\u22a5 0) \u27f6 \u03ba (\u03b7 null \ud835\udc0c-in-\ud835\udc04) ,\n      list\u2032 (\u03f5\u22c6 \u2020 1) (\u03bb \u03f5 \u2192 cons \u27e8 (\u03f5\u22c6 \u2193 1) , \u03f5 \u27e9 \u03ba)\n\ncar : \ud835\udc05\ncar =\n  \u03bb \u03f5\u22c6 \u03ba \u2192 (# \u03f5\u22c6 ==\u22a5 1) \u27f6 hold ((\u03f5\u22c6 \u2193 1) |-\ud835\udc0f \u21931) \u03ba , \u22a5\n\ncdr : \ud835\udc05\ncdr =\n  \u03bb \u03f5\u22c6 \u03ba \u2192 (# \u03f5\u22c6 ==\u22a5 1) \u27f6 hold ((\u03f5\u22c6 \u2193 1) |-\ud835\udc0f \u21932) \u03ba , \u22a5\n\nsetcar : \ud835\udc05\nsetcar =\n  \u03bb \u03f5\u22c6 \u03ba \u2192\n      (# \u03f5\u22c6 ==\u22a5 2) \u27f6 assign  ((\u03f5\u22c6 \u2193 1) |-\ud835\udc0f \u21931)\n                             (\u03f5\u22c6 \u2193 2)\n                             (\u03ba (\u03b7 unspecified \ud835\udc0c-in-\ud835\udc04)) , \n    \u22a5\n\nsetcdr : \ud835\udc05\nsetcdr =\n  \u03bb \u03f5\u22c6 \u03ba \u2192\n      (# \u03f5\u22c6 ==\u22a5 2) \u27f6 assign  ((\u03f5\u22c6 \u2193 1) |-\ud835\udc0f \u21932)\n                             (\u03f5\u22c6 \u2193 2)\n                             (\u03ba (\u03b7 unspecified \ud835\udc0c-in-\ud835\udc04)) , \n    \u22a5\n</pre> <p>\\clearpage</p> <pre>\n-- datum prefix pre\u27e6 \u0394 \u27e7 : Dat\n\npre\u27e6_\u27e7 : Dat \u2192 Dat\n\npre\u27e6 \u2985 \u2423\u2423 \u0394 \u00b7 \u2985 \u0394\u22c6 \u2986 \u2986 \u27e7 = \u27e6 \u2985 \u0394 \u2423\u2423 \u0394\u22c6 \u2986 \u27e7\n-- otherwise:\npre\u27e6 \u0394 \u27e7 = \u27e6 \u0394 \u27e7\n\n-- datum \u03f5 \u03ba applies \u03ba to the datum represented by the value \u03f5\ndatum : \ud835\udc04 \u2192 (Dat \u2192 \ud835\udc02) \u2192 \ud835\udc02\ndatum = fix \u03bb datum\u2032 \u2192 \n  \u03bb \u03f5 \u03ba \u2192\n    (\u03f5 \u2208-\ud835\udc13) \u27f6\n      ((\u03f5 |-\ud835\udc13) \u27f6 \u03ba \u27e6 con #t \u27e7 , \u03ba \u27e6 con #f \u27e7) ,\n    (\u03f5 \u2208-\ud835\udc11) \u27f6\n      ((\u03bb Z \u2192 \u03ba \u27e6 con (int Z) \u27e7) \u266f) (\u03f5 |-\ud835\udc11) ,\n    (\u03f5 \u2208-\ud835\udc0f) \u27f6 \n      car \u27e8 \u03f5 \u27e9 (\u03bb \u03f5\u2081 \u2192 cdr \u27e8 \u03f5 \u27e9 (\u03bb \u03f5\u2082 \u2192\n        datum\u2032 \u03f5\u2081 (\u03bb \u0394\u2081 \u2192 datum\u2032 \u03f5\u2082 (\u03bb \u0394\u2082 \u2192\n          \u03ba pre\u27e6 \u2985 \u2423\u2423 \u0394\u2081 \u00b7 \u0394\u2082 \u2986 \u27e7)))) ,\n    (\u03f5 \u2208-\ud835\udc0c) \u27f6 \n      (((\u03f5 |-\ud835\udc0c) ==\u1d39 \u03b7 null) \u27f6 \u03ba \u27e6 \u2985 \u2423\u2423\u2423 \u2986 \u27e7  , \u22a5) ,\n    (\u03f5 \u2208-\ud835\udc05) \u27f6 \n      \u03ba \u27e6 #proc \u27e7 ,\n    (\u03f5 \u2208-\ud835\udc10) \u27f6 \n      ((\u03bb I \u2192 \u03ba \u27e6 ide I \u27e7) \u266f) (\u03f5 |-\ud835\udc10) ,\n    (\u03f5 \u2208-\ud835\udc17) \u27f6 \n      ((\u03bb X \u2192 \u03ba \u27e6 key X \u27e7) \u266f) (\u03f5 |-\ud835\udc17) ,\n    \u22a5\n</pre> <p>\\clearpage</p> <pre>\n-- mapping datum terms to expressions\n\nexp\u27e6_\u27e7   : Dat \u2192 Exp\nexp\u22c6\u27e6_\u27e7  : Dat\u22c6 \u2192 Exp\u22c6\n\n-- datum expressions exp\u27e6 \u0394 \u27e7 : Exp\n\nexp\u27e6 con K \u27e7  = \u27e6 con K \u27e7\n\nexp\u27e6 ide I \u27e7  = \u27e6 ide I \u27e7\n\nexp\u27e6 \u2032 \u0394 \u27e7    = \u27e6 \u2985quote \u0394 \u2986 \u27e7\n\nexp\u27e6 \u2985 key quote\u2032 \u2423\u2423 \u0394 \u2423\u2423 \u2423\u2423\u2423 \u2986 \u27e7 = \u27e6 \u2985quote \u0394 \u2986 \u27e7\n\nexp\u27e6 \u2985 key lambda \u2423\u2423 ide I \u2423\u2423 \u0394 \u2423\u2423 \u2423\u2423\u2423 \u2986 \u27e7 =\n  \u27e6 \u2985lambda I \u2423 exp\u27e6 \u0394 \u27e7 \u2986 \u27e7\n\nexp\u27e6 \u2985 key if \u2423\u2423 \u0394 \u2423\u2423 \u0394\u2081 \u2423\u2423 \u0394\u2082 \u2423\u2423 \u2423\u2423\u2423 \u2986 \u27e7 =\n      \u27e6 \u2985if exp\u27e6 \u0394 \u27e7 \u2423 exp\u27e6 \u0394\u2081 \u27e7 \u2423 exp\u27e6 \u0394\u2082 \u27e7 \u2986 \u27e7\n\nexp\u27e6 \u2985 key set! \u2423\u2423 ide I \u2423\u2423 \u0394 \u2423\u2423 \u2423\u2423\u2423 \u2986 \u27e7 =\n  \u27e6 \u2985set! I \u2423 exp\u27e6 \u0394 \u27e7 \u2986 \u27e7\n\nexp\u27e6 \u2985 ide I \u2423\u2423 \u0394\u22c6 \u2986 \u27e7 =\n  \u27e6 \u2985 ide I \u2423 exp\u22c6\u27e6 \u0394\u22c6 \u27e7 \u2986 \u27e7\n\nexp\u27e6 _ \u27e7 = \u27e6 \u2985\u2423\u2986 \u27e7\n\n-- datum sequence expressions exp\u22c6\u27e6 \u0394\u22c6 : Exp\u22c6\n\nexp\u22c6\u27e6 \u2423\u2423\u2423 \u27e7 = \u27e6 \u2423\u2423\u2423 \u27e7\n\nexp\u22c6\u27e6 \u0394 \u2423\u2423 \u0394\u22c6 \u27e7 = \u27e6 exp\u27e6 \u0394 \u27e7 \u2423\u2423 exp\u22c6\u27e6 \u0394\u22c6 \u27e7 \u27e7\n</pre>"},{"location":"md/ScmQE/Domain-Equations/","title":"ScmQE.Domain-Equations","text":"<pre>\nmodule ScmQE.Domain-Equations where\n\nopen import Notation\nopen import ScmQE.Abstract-Syntax using (Ide; Key; Dat; Int)\n\n-- Domain declarations\n\npostulate  \ud835\udc0b   :  Domain  -- locations\nvariable   \u03b1   :  \ud835\udc0b\n\ud835\udc0d              :  Domain  -- natural numbers\n\ud835\udc13              :  Domain  -- booleans\n\ud835\udc11              :  Domain  -- numbers\n\ud835\udc0f              :  Domain  -- pairs\n\ud835\udc0c              :  Domain  -- miscellaneous\n\ud835\udc05              :  Domain  -- procedure values\n\ud835\udc10              :  Domain  -- symbols\n\ud835\udc17              :  Domain  -- keyword values\npostulate  \ud835\udc04   :  Domain  -- expressed values\nvariable   \u03f5   :  \ud835\udc04\n\ud835\udc12              :  Domain  -- stores\nvariable   \u03c3   :  \ud835\udc12\n\ud835\udc14              :  Domain  -- environments\nvariable   \u03c1   :  \ud835\udc14\n\ud835\udc02              :  Domain  -- command continuations\nvariable   \u03b8   :  \ud835\udc02\npostulate  \ud835\udc00   :  Domain  -- answers\n\n\ud835\udc04\u22c6             =  \ud835\udc04 \u22c6\nvariable   \u03f5\u22c6  :  \ud835\udc04\u22c6\n\n-- Domain equations\n\ndata Misc : Set where null unallocated undefined unspecified : Misc\n\n\ud835\udc0d     =  Nat\u22a5\n\ud835\udc13     =  Bool\u22a5\n\ud835\udc11     =  Int +\u22a5\n\ud835\udc0f     =  \ud835\udc0b \u00d7 \ud835\udc0b\n\ud835\udc0c     =  Misc +\u22a5\n\ud835\udc05     =  \ud835\udc04\u22c6 \u2192 (\ud835\udc04 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\ud835\udc10     =  Ide +\u22a5\n\ud835\udc17     =  Key +\u22a5\n-- \ud835\udc04  =  \ud835\udc13 + \ud835\udc11 + \ud835\udc0f + \ud835\udc0c + \ud835\udc05 + \ud835\udc10 + \ud835\udc17\n\ud835\udc12     =  \ud835\udc0b \u2192 \ud835\udc04\n\ud835\udc14     =  Ide \u2192 \ud835\udc0b\n\ud835\udc02     =  \ud835\udc12 \u2192 \ud835\udc00\n</pre> <p>\\clearpage</p> <pre>\n-- Injections, tests, and projections\n\npostulate\n  _\ud835\udc13-in-\ud835\udc04    : \ud835\udc13   \u2192 \ud835\udc04\n  _\u2208-\ud835\udc13       : \ud835\udc04   \u2192 Bool +\u22a5\n  _|-\ud835\udc13       : \ud835\udc04   \u2192 \ud835\udc13\n\n  _\ud835\udc11-in-\ud835\udc04    : \ud835\udc11   \u2192 \ud835\udc04\n  _\u2208-\ud835\udc11       : \ud835\udc04   \u2192 Bool +\u22a5\n  _|-\ud835\udc11       : \ud835\udc04   \u2192 \ud835\udc11\n\n  _\ud835\udc0f-in-\ud835\udc04    : \ud835\udc0f  \u2192 \ud835\udc04\n  _\u2208-\ud835\udc0f       : \ud835\udc04   \u2192 Bool +\u22a5\n  _|-\ud835\udc0f       : \ud835\udc04   \u2192 \ud835\udc0f\n\n  _\ud835\udc0c-in-\ud835\udc04    : \ud835\udc0c   \u2192 \ud835\udc04\n  _\u2208-\ud835\udc0c       : \ud835\udc04   \u2192 Bool +\u22a5\n  _|-\ud835\udc0c       : \ud835\udc04   \u2192 \ud835\udc0c\n\n  _\ud835\udc05-in-\ud835\udc04    : \ud835\udc05   \u2192 \ud835\udc04\n  _\u2208-\ud835\udc05       : \ud835\udc04   \u2192 Bool +\u22a5\n  _|-\ud835\udc05       : \ud835\udc04   \u2192 \ud835\udc05\n\n  _\ud835\udc10-in-\ud835\udc04    : \ud835\udc10   \u2192 \ud835\udc04\n  _\u2208-\ud835\udc10       : \ud835\udc04   \u2192 Bool +\u22a5\n  _|-\ud835\udc10       : \ud835\udc04   \u2192 \ud835\udc10\n\n  _\ud835\udc17-in-\ud835\udc04    : \ud835\udc17   \u2192 \ud835\udc04\n  _\u2208-\ud835\udc17       : \ud835\udc04   \u2192 Bool +\u22a5\n  _|-\ud835\udc17       : \ud835\udc04   \u2192 \ud835\udc17\n\n-- Operations on flat domains\n\npostulate\n  _==\u1d38_  : \ud835\udc0b \u2192 \ud835\udc0b \u2192 \ud835\udc13\n  _==\u1d39_  : \ud835\udc0c \u2192 \ud835\udc0c \u2192 \ud835\udc13\n  _==\u1d40_  : \ud835\udc13 \u2192 \ud835\udc13 \u2192 \ud835\udc13\n</pre>"},{"location":"md/ScmQE/Semantic-Functions/","title":"ScmQE.Semantic-Functions","text":"<pre>\nmodule ScmQE.Semantic-Functions where\n\nopen import Notation\nopen import ScmQE.Abstract-Syntax\nopen import ScmQE.Domain-Equations\nopen import ScmQE.Auxiliary-Functions\n\n\ud835\udca6\u27e6_\u27e7    : Con \u2192 \ud835\udc04\n\ud835\udc9f\u27e6_\u27e7    : Dat \u2192 (\ud835\udc04 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\ud835\udc9f\u22c6\u27e6_\u27e7   : Dat\u22c6 \u2192 (\ud835\udc04 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\ud835\udc9f\u207a\u27e6_\u27e7   : Dat\u207a \u2192 \ud835\udc04 \u2192 (\ud835\udc04 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\n\u2130\u27e6_\u27e7    : Exp \u2192 \ud835\udc14 \u2192 (\ud835\udc04 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\u2130\u22c6\u27e6_\u27e7   : Exp\u22c6 \u2192 \ud835\udc14 \u2192 (\ud835\udc04\u22c6 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\u2131_\u27e6_\u27e7   : (Exp \u2192 \ud835\udc14 \u2192 (\ud835\udc04 \u2192 \ud835\udc02) \u2192 \ud835\udc02) \u2192 Exp \u2192 \ud835\udc14 \u2192 (\ud835\udc04 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\u2131\u22c6_\u27e6_\u27e7  : (Exp \u2192 \ud835\udc14 \u2192 (\ud835\udc04 \u2192 \ud835\udc02) \u2192 \ud835\udc02) \u2192 Exp\u22c6 \u2192 \ud835\udc14 \u2192 (\ud835\udc04 \u22c6 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\n\u212c\u27e6_\u27e7    : Body \u2192 \ud835\udc14 \u2192 (\ud835\udc14 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\u212c\u207a\u27e6_\u27e7   : Body\u207a \u2192 \ud835\udc14 \u2192 (\ud835\udc14 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\ud835\udcab\u27e6_\u27e7    : Prog \u2192 \ud835\udc00\n\n-- Constant denotations \ud835\udca6\u27e6 K \u27e7 : \ud835\udc04\n\n\ud835\udca6\u27e6 int Z \u27e7  = \u03b7 Z \ud835\udc11-in-\ud835\udc04\n\ud835\udca6\u27e6 #t \u27e7     = \u03b7 true \ud835\udc13-in-\ud835\udc04\n\ud835\udca6\u27e6 #f \u27e7     = \u03b7 false \ud835\udc13-in-\ud835\udc04\n\n-- Datum denotations \ud835\udc9f\u27e6 \u0394 \u27e7 : (\ud835\udc04 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\n\ud835\udc9f\u27e6 con K \u27e7 \u03ba        = \u03ba(\ud835\udca6\u27e6 K \u27e7)\n\ud835\udc9f\u27e6 ide I \u27e7 \u03ba        = \u03ba(\u03b7 I \ud835\udc10-in-\ud835\udc04)\n\ud835\udc9f\u27e6 key X \u27e7 \u03ba        = \u03ba(\u03b7 X \ud835\udc17-in-\ud835\udc04)\n\ud835\udc9f\u27e6 \u2032 \u0394 \u27e7 \u03ba          = \ud835\udc9f\u27e6 \u0394 \u27e7 \u03ba\n\ud835\udc9f\u27e6 \u2985 \u0394\u22c6 \u2986 \u27e7 \u03ba       = \ud835\udc9f\u22c6\u27e6 \u0394\u22c6 \u27e7 \u03ba\n\ud835\udc9f\u27e6 \u2985 \u0394\u207a \u00b7 \u0394 \u2986 \u27e7 \u03ba   = \ud835\udc9f\u27e6 \u0394 \u27e7 (\u03bb \u03f5 \u2192 \ud835\udc9f\u207a\u27e6 \u0394\u207a \u27e7 \u03f5 \u03ba)\n\ud835\udc9f\u27e6 #proc \u27e7 \u03ba        = \u22a5\n\n-- Datum sequence denotations \ud835\udc9f\u22c6\u27e6 \u0394\u22c6 \u27e7 : (\ud835\udc04 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\n\ud835\udc9f\u22c6\u27e6 \u2423\u2423\u2423 \u27e7 \u03ba = \u03ba (\u03b7 null \ud835\udc0c-in-\ud835\udc04)\n\n\ud835\udc9f\u22c6\u27e6 \u0394\u2081 \u2423\u2423 \u0394\u22c6 \u27e7 \u03ba =\n  \ud835\udc9f\u27e6 \u0394\u2081 \u27e7 (\u03bb \u03f5\u2081 \u2192\n    \ud835\udc9f\u22c6\u27e6 \u0394\u22c6 \u27e7 (\u03bb \u03f5 \u2192\n      cons \u27e8 \u03f5\u2081 , \u03f5 \u27e9 \u03ba))\n\n-- Datum prefix sequence denotations \ud835\udc9f\u207a\u27e6 \u0394\u207a \u27e7 : \ud835\udc04 \u2192 (\ud835\udc04 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\n\ud835\udc9f\u207a\u27e6 \u2423\u2423 \u0394\u2081 \u27e7 \u03f5 \u03ba =\n  \ud835\udc9f\u27e6 \u0394\u2081 \u27e7 (\u03bb \u03f5\u2081 \u2192\n    cons \u27e8 \u03f5\u2081 , \u03f5 \u27e9 \u03ba)\n\n\ud835\udc9f\u207a\u27e6 \u0394\u207a \u2423\u2423 \u0394\u2081 \u27e7 \u03f5 \u03ba =\n  \ud835\udc9f\u27e6 \u0394\u2081 \u27e7 (\u03bb \u03f5\u2081 \u2192\n    cons \u27e8 \u03f5\u2081 , \u03f5 \u27e9 (\u03bb \u03f5\u2032 \u2192\n    \ud835\udc9f\u207a\u27e6 \u0394\u207a \u27e7 \u03f5\u2032 \u03ba))\n</pre> <p>\\clearpage</p> <pre>\n-- Fixed expression denotations \u2130\u27e6 E \u27e7 : \ud835\udc14 \u2192 (\ud835\udc04 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\n\u2130\u27e6 E \u27e7 = \u2131 (fix \u2131_\u27e6_\u27e7) \u27e6 E \u27e7\n\n-- Fixed expression sequence denotations \u2130\u22c6\u27e6_\u27e7  : Exp\u22c6 \u2192 \ud835\udc14 \u2192 (\ud835\udc04\u22c6 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\n\u2130\u22c6\u27e6 E\u22c6 \u27e7 = \u2131\u22c6 (fix \u2131_\u27e6_\u27e7) \u27e6 E\u22c6 \u27e7\n\n-- Expression denotations \u2131 \u2130\u2032 \u27e6 E \u27e7 : \ud835\udc14 \u2192 (\ud835\udc04 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\n\u2131 \u2130\u2032 \u27e6 con K \u27e7 \u03c1 \u03ba = \u03ba (\ud835\udca6\u27e6 K \u27e7)\n\n\u2131 \u2130\u2032 \u27e6 ide I \u27e7 \u03c1 \u03ba = hold (\u03c1 I) \u03ba\n\n\u2131 \u2130\u2032 \u27e6 \u2985 E \u2423 E\u22c6 \u2986 \u27e7 \u03c1 \u03ba =\n  \u2131 \u2130\u2032 \u27e6 E \u27e7 \u03c1 (\u03bb \u03f5 \u2192\n    \u2131\u22c6 \u2130\u2032 \u27e6 E\u22c6 \u27e7 \u03c1 (\u03bb \u03f5\u22c6 \u2192\n      (\u03f5 |-\ud835\udc05) \u03f5\u22c6 \u03ba))\n\n\u2131 \u2130\u2032 \u27e6 \u2985lambda I \u2423 E \u2986 \u27e7 \u03c1 \u03ba =\n  \u03ba (  (\u03bb \u03f5\u22c6 \u03ba\u2032 \u2192\n          list \u03f5\u22c6 (\u03bb \u03f5 \u2192 \n            alloc \u03f5 (\u03bb \u03b1 \u2192\n              \u2131 \u2130\u2032 \u27e6 E \u27e7 (\u03c1 [ \u03b1 / I ]) \u03ba\u2032))\n       ) \ud835\udc05-in-\ud835\udc04)\n\n\u2131 \u2130\u2032 \u27e6 \u2985if E \u2423 E\u2081 \u2423 E\u2082 \u2986 \u27e7 \u03c1 \u03ba =\n  \u2131 \u2130\u2032 \u27e6 E \u27e7 \u03c1 (\u03bb \u03f5 \u2192\n    truish \u03f5 \u27f6 \u2131 \u2130\u2032 \u27e6 E\u2081 \u27e7 \u03c1 \u03ba , \u2131 \u2130\u2032 \u27e6 E\u2082 \u27e7 \u03c1 \u03ba)\n\n\u2131 \u2130\u2032 \u27e6 \u2985set! I \u2423 E \u2986 \u27e7 \u03c1 \u03ba =\n  \u2131 \u2130\u2032 \u27e6 E \u27e7 \u03c1 (\u03bb \u03f5 \u2192\n    assign (\u03c1 I) \u03f5 (\n      \u03ba (\u03b7 unspecified \ud835\udc0c-in-\ud835\udc04)))\n\n\u2131 \u2130\u2032 \u27e6 \u2985quote \u0394 \u2986 \u27e7 \u03c1 \u03ba = \ud835\udc9f\u27e6 \u0394 \u27e7 \u03ba\n\n\u2131 \u2130\u2032 \u27e6 \u2985eval E \u2986 \u27e7 \u03c1 \u03ba =\n  \u2131 \u2130\u2032 \u27e6 E \u27e7 \u03c1 (\u03bb \u03f5 \u2192\n    datum \u03f5 (\u03bb \u0394 \u2192 \u2130\u2032 (exp\u27e6 \u0394 \u27e7) nullenv \u03ba))\n\n\u2131 \u2130\u2032 \u27e6 \u2985\u2423\u2986 \u27e7 \u03c1 \u03ba = \u22a5\n\n-- Expression sequence denotations \u2131\u22c6 \u2130\u2032 \u27e6 E\u22c6 \u27e7 : \ud835\udc14 \u2192 (\ud835\udc04\u22c6 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\n\u2131\u22c6 \u2130\u2032 \u27e6 \u2423\u2423\u2423 \u27e7 \u03c1 \u03ba = \u03ba \u27e8\u27e9\n\n\u2131\u22c6 \u2130\u2032 \u27e6 E \u2423\u2423 E\u22c6 \u27e7 \u03c1 \u03ba =\n  \u2131 \u2130\u2032 \u27e6 E \u27e7 \u03c1 (\u03bb \u03f5 \u2192\n    \u2131\u22c6 \u2130\u2032 \u27e6 E\u22c6 \u27e7 \u03c1 (\u03bb \u03f5\u22c6 \u2192\n      \u03ba (\u27e8 \u03f5 \u27e9 \u00a7 \u03f5\u22c6)))\n</pre> <p>\\clearpage</p> <pre>\n-- Body denotations \u212c\u27e6 B \u27e7 : \ud835\udc14 \u2192 (\ud835\udc14 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\n\u212c\u27e6 \u2423\u2423 E \u27e7 \u03c1 \u03ba = \u2130\u27e6 E \u27e7 \u03c1 (\u03bb \u03f5 \u2192 \u03ba \u03c1)\n\n\u212c\u27e6 \u2985define I \u2423 E \u2986 \u27e7 \u03c1 \u03ba =\n  \u2130\u27e6 E \u27e7 \u03c1 (\u03bb \u03f5 \u2192 (\u03c1 I ==\u1d38 unknown) \u27f6 \n                      alloc \u03f5 (\u03bb \u03b1 \u2192 \u03ba (\u03c1 [ \u03b1 / I ])),\n                    assign (\u03c1 I) \u03f5 (\u03ba \u03c1))\n\n\u212c\u27e6 \u2985begin B\u207a \u2986 \u27e7 \u03c1 \u03ba = \u212c\u207a\u27e6 B\u207a \u27e7 \u03c1 \u03ba\n\n-- Body sequence denotations \u212c\u207a\u27e6 B\u207a \u27e7 : \ud835\udc14 \u2192 (\ud835\udc14 \u2192 \ud835\udc02) \u2192 \ud835\udc02\n\n\u212c\u207a\u27e6 \u2423\u2423 B \u27e7 \u03c1 \u03ba = \u212c\u27e6 B \u27e7 \u03c1 \u03ba\n\n\u212c\u207a\u27e6 B \u2423\u2423 B\u207a \u27e7 \u03c1 \u03ba = \u212c\u27e6 B \u27e7 \u03c1 (\u03bb \u03c1\u2032 \u2192 \u212c\u207a\u27e6 B\u207a \u27e7 \u03c1\u2032 \u03ba)\n\n-- Program denotations \ud835\udcab\u27e6 \u03a0 \u27e7 : \ud835\udc00\n\n\ud835\udcab\u27e6 \u2423\u2423\u2423 \u27e7 = finished initial-store\n\n\ud835\udcab\u27e6 \u2423\u2423 B\u207a \u27e7 = \u212c\u207a\u27e6 B\u207a \u27e7 nullenv (\u03bb \u03c1 \u2192 finished) initial-store\n</pre>"},{"location":"md/ScmQE/Soundness-Tests/","title":"ScmQE.Soundness-Tests","text":"<pre>\n{-# OPTIONS --rewriting --confluence-check #-}\n\nopen import Agda.Builtin.Equality\nopen import Agda.Builtin.Equality.Rewrite\n\nmodule ScmQE.Soundness-Tests where\n\nopen import Notation\nopen import ScmQE.Abstract-Syntax\nopen import ScmQE.Domain-Equations\nopen import ScmQE.Auxiliary-Functions\nopen import ScmQE.Semantic-Functions\n\nopen import Relation.Binary.PropositionalEquality.Core\n  using (_\u2261_; refl; cong-app)\n\npostulate\n  fix-fix : (f : D \u2192 D) \u2192 fix f \u2261 f (fix f)\n\nfix-app : (f : (A \u2192 D) \u2192 (A \u2192 D)) (a : A) \u2192\n            fix f a \u2261 f (fix f) a\nfix-app f = cong-app (fix-fix f) \n\n{-# REWRITE fix-app #-}\n\ntest-1 : \u2200 {K \u03c1 \u03ba} \u2192\n  \u2130\u27e6 con K \u27e7 \u03c1 \u03ba \u2261 \u03ba (\ud835\udca6\u27e6 K \u27e7)\ntest-1 = refl\n\ntest-2 : \u2200 {\u03c1 \u03ba} \u2192\n  \u2130\u27e6 \u2985eval con #t \u2986 \u27e7 \u03c1 \u03ba \u2261\n    datum (\u03b7 true \ud835\udc13-in-\ud835\udc04) (\u03bb \u0394 \u2192 (fix \u2131_\u27e6_\u27e7) exp\u27e6 \u0394 \u27e7 nullenv \u03ba)\ntest-2 = refl\n</pre> <p>\\clearpage</p> <pre>\na b c d e : Dat\na = ide \"a\"\nb = ide \"b\"\nc = ide \"c\"\nd = ide \"d\"\ne = ide \"e\"\n\n-- R7RS \u00a76.4\n\n-- (a b c d e) and (a . (b . (c . (d . (e . ()))))) are equivalent\ntest-proper-list :\n  \ud835\udc9f\u27e6 \u2985 a \u2423\u2423 b \u2423\u2423 c \u2423\u2423 d \u2423\u2423 e \u2423\u2423 \u2423\u2423\u2423 \u2986 \u27e7 \u2261\n  \ud835\udc9f\u27e6 \u2985 \u2423\u2423 a \u00b7 \u2985 \u2423\u2423 b \u00b7 \u2985 \u2423\u2423 c \u00b7 \u2985 \u2423\u2423 d \u00b7  \u2985 \u2423\u2423 e \u00b7  \u2985 \u2423\u2423\u2423 \u2986 \u2986 \u2986 \u2986 \u2986 \u2986 \u27e7\ntest-proper-list = refl\n\n-- (a b c . d) is equivalent to (a . (b . (c . d)))\ntest-improper-list :\n  \ud835\udc9f\u27e6 \u2985 (((\u2423\u2423 a) \u2423\u2423 b) \u2423\u2423 c) \u00b7 d \u2986 \u27e7 \u2261\n  \ud835\udc9f\u27e6 \u2985 \u2423\u2423 a \u00b7 \u2985 \u2423\u2423 b \u00b7 \u2985 \u2423\u2423 c \u00b7 d \u2986 \u2986 \u2986 \u27e7\ntest-improper-list = refl\n</pre>"},{"location":"md/index/","title":"index","text":"<pre>\n{-# OPTIONS --rewriting --confluence-check #-}\n\nmodule index where\n\nimport Library\nimport Notation\nimport ScmQE.All\nimport ScmQE.Soundness-Tests\n</pre>"}]}